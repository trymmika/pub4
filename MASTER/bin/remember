#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../lib/json_protocol"
require_relative "../lib/db"
require_relative "../lib/weaviate_client"

MASTER::DB.initialize_schema

MASTER::Protocol.pipe do |input|
  action = input[:action] || "recall"
  context = input[:context] || ""
  content = input[:content] || input[:text] || ""
  
  if action == "store"
    # Hybrid write: Store in BOTH SQLite (structured) and Weaviate (semantic)
    
    # 1. Store in SQLite for structured/exact recall
    MASTER::DB.connection.execute(
      "INSERT INTO memories (context, content) VALUES (?, ?)",
      [context, content]
    )
    
    # 2. Store in Weaviate for semantic similarity search
    begin
      MASTER::VectorMemory.store(content, context: context)
      weaviate_stored = true
    rescue => e
      $stderr.puts "Warning: Weaviate storage failed: #{e.message}"
      weaviate_stored = false
    end
    
    input.merge(
      stored: true,
      sqlite_stored: true,
      weaviate_stored: weaviate_stored,
      message: "Memory stored in #{weaviate_stored ? 'SQLite + Weaviate' : 'SQLite only'}"
    )
  else
    # Hybrid read: Use SQLite for exact recall, Weaviate for semantic search
    query = input[:query] || context
    use_semantic = input[:semantic] || false
    
    if use_semantic && !query.empty?
      # Semantic similarity search via Weaviate
      begin
        weaviate_results = MASTER::VectorMemory.search(query, limit: input[:limit] || 5)
        memories = weaviate_results.map do |result|
          {
            content: result["content"],
            context: result["context"],
            certainty: result["_additional"]&.dig("certainty"),
            source: "weaviate"
          }
        end
      rescue => e
        $stderr.puts "Warning: Weaviate search failed: #{e.message}"
        memories = []
      end
    else
      # Structured recall via SQLite
      if query.empty?
        # Get recent memories
        memories = MASTER::DB.connection.execute(
          "SELECT * FROM memories ORDER BY created_at DESC LIMIT 10"
        )
      else
        # Search by context (simple LIKE query)
        memories = MASTER::DB.connection.execute(
          "SELECT * FROM memories WHERE context LIKE ? OR content LIKE ? ORDER BY created_at DESC LIMIT 10",
          ["%#{query}%", "%#{query}%"]
        )
      end
      
      memories = memories.map { |m| Hash[m].merge(source: "sqlite") }
    end
    
    input.merge(
      recalled: true,
      memories: memories,
      count: memories.length,
      source: use_semantic ? "weaviate" : "sqlite"
    )
  end
end
