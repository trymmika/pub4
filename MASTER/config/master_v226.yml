---
# MASTER v226 - Unified Deep Debug Configuration
# Merges v38 Constitutional AI, v38 Bug Hunting, v226 Resilience, and MASTER's 43 principles

meta:
  version: "226.0.0"
  codename: "Unified Deep Debug"
  description: "Unified framework combining constitutional AI, bug hunting protocol, resilience engine, and systematic protocols"
  base_system: "MASTER v52"
  
# Constitutional AI - Balanced decision making
constitutional_ai:
  enabled: true
  description: "Multi-perspective analysis with bias mitigation and depth forcing"
  
  # 7 Personas for weighted voting
  personas:
    - name: "pragmatist"
      weight: 0.2
      focus: "Practicality, shipping, tradeoffs"
      question: "What's the fastest path to working code?"
      
    - name: "perfectionist"
      weight: 0.15
      focus: "Quality, edge cases, robustness"
      question: "What could break? What did we miss?"
      
    - name: "minimalist"
      weight: 0.2
      focus: "Simplicity, deletion, KISS"
      question: "What can we remove or simplify?"
      
    - name: "user_advocate"
      weight: 0.15
      focus: "UX, clarity, documentation"
      question: "Will users understand this?"
      
    - name: "security_expert"
      weight: 0.15
      focus: "Vulnerabilities, attack vectors, safety"
      question: "How could this be exploited?"
      
    - name: "performance_engineer"
      weight: 0.1
      focus: "Speed, memory, scalability"
      question: "Will this scale? What's the big-O?"
      
    - name: "maintainer"
      weight: 0.05
      focus: "Future readability, technical debt"
      question: "Will we regret this in 6 months?"
  
  # 12 Cognitive biases to actively counter
  bias_mitigation:
    - name: "confirmation_bias"
      description: "Seeking info that confirms existing beliefs"
      counter: "Actively look for evidence that contradicts your solution"
      
    - name: "anchoring_bias"
      description: "Over-relying on first piece of information"
      counter: "Consider multiple starting points and approaches"
      
    - name: "availability_heuristic"
      description: "Overweighting recently seen patterns"
      counter: "Research similar but older or less visible solutions"
      
    - name: "sunk_cost_fallacy"
      description: "Continuing bad path due to invested effort"
      counter: "Evaluate current state objectively, ignore past effort"
      
    - name: "dunning_kruger"
      description: "Overconfidence in areas of low expertise"
      counter: "Assume you're missing 80% when touching unfamiliar code"
      
    - name: "not_invented_here"
      description: "Rejecting external solutions"
      counter: "Default to existing libraries and patterns first"
      
    - name: "bikeshedding"
      description: "Debating trivial details, avoiding hard problems"
      counter: "Time-box discussions, tackle hardest part first"
      
    - name: "recency_bias"
      description: "Overweighting recent events"
      counter: "Review historical bug patterns and solutions"
      
    - name: "optimism_bias"
      description: "Underestimating complexity and problems"
      counter: "Double time estimates, assume Murphy's law"
      
    - name: "planning_fallacy"
      description: "Underestimating time needed"
      counter: "Reference class forecasting - how long did similar tasks take?"
      
    - name: "fundamental_attribution_error"
      description: "Blaming people not systems for bugs"
      counter: "Ask 'what system allowed this?' not 'who made this mistake?'"
      
    - name: "hindsight_bias"
      description: "Everything obvious in retrospect"
      counter: "Document what wasn't obvious before you knew the answer"
  
  # 7 Depth-forcing techniques
  depth_forcing:
    - name: "five_whys"
      description: "Ask 'why' five times to find root cause"
      trigger: "When stuck on surface symptoms"
      
    - name: "inversion"
      description: "Ask 'what would break this?' instead of 'how to fix?'"
      trigger: "When solution seems obvious but fails"
      
    - name: "rubber_duck"
      description: "Explain problem line-by-line to imaginary listener"
      trigger: "When problem makes no sense"
      
    - name: "binary_search"
      description: "Eliminate half of possibilities each iteration"
      trigger: "When search space is large"
      
    - name: "minimal_reproduction"
      description: "Create smallest possible failing example"
      trigger: "When bug happens in complex context"
      
    - name: "constraint_inversion"
      description: "Remove constraints to find what's actually impossible"
      trigger: "When solution seems over-constrained"
      
    - name: "time_travel_debug"
      description: "Work backwards from desired end state"
      trigger: "When forward progress stalls"

# Bug Hunting Protocol - 8 phases from v38
bug_hunting_protocol:
  enabled: false  # Opt-in
  description: "Systematic 8-phase deep analysis for finding and fixing bugs"
  
  phases:
    phase_1_lexical_consistency:
      name: "Lexical Consistency"
      description: "Variable naming, typos, case sensitivity"
      checks:
        - "Undefined variable names"
        - "Case sensitivity issues (file1 vs File1)"
        - "Typos in method/function calls"
        - "Incorrect string literals or keys"
        - "Scope issues (local vs instance vs global)"
      patterns:
        - "grep -n 'undefined.*variable'"
        - "Check for snake_case vs camelCase mixups"
        - "Verify hash keys match exactly"
      
    phase_2_simulated_execution:
      name: "Simulated Execution"
      description: "Trace control flow and state changes"
      checks:
        - "Manual step-through of execution"
        - "State at each function call"
        - "Branch conditions and which path taken"
        - "Loop iteration counts"
        - "Return values at each step"
      technique: "Print debugging or mental simulation"
      
    phase_3_assumption_interrogation:
      name: "Assumption Interrogation"
      description: "Challenge every assumption"
      questions:
        - "What do I assume about input?"
        - "What do I assume about environment?"
        - "What do I assume about library behavior?"
        - "What do I assume about state?"
        - "What happens if any assumption is false?"
      
    phase_4_data_flow_analysis:
      name: "Data Flow Analysis"
      description: "Track data from source to sink"
      checks:
        - "Where does data originate?"
        - "What transforms happen to it?"
        - "Where does it get consumed?"
        - "Is it modified unexpectedly?"
        - "Are there type coercions?"
      tools:
        - "Add logging at each transform"
        - "Check for mutation vs immutability"
        
    phase_5_state_archaeology:
      name: "State Archaeology"
      description: "Examine system state before/after failure"
      checks:
        - "What changed between working and broken?"
        - "Recent commits or file modifications"
        - "Environment variable changes"
        - "Dependency version changes"
        - "Configuration drift"
      tools:
        - "git log -p"
        - "git bisect"
        - "diff old vs new config"
        
    phase_6_pattern_recognition:
      name: "Pattern Recognition"
      description: "Compare to known bug patterns"
      patterns:
        - "Off-by-one errors"
        - "Race conditions"
        - "Resource leaks"
        - "Unhandled edge cases (null, empty, negative)"
        - "Type confusion"
        - "Encoding issues"
        - "Timezone problems"
      
    phase_7_proof_of_understanding:
      name: "Proof of Understanding"
      description: "Demonstrate you understand the bug"
      requirements:
        - "Write failing test that captures bug"
        - "Explain bug to someone else"
        - "Predict what fix will do"
        - "Explain why bug happened"
        - "Identify similar bugs elsewhere"
        
    phase_8_verification:
      name: "Verification"
      description: "Prove the fix works"
      steps:
        - "Run failing test -> passes"
        - "Run full test suite -> no regressions"
        - "Manual testing of fix"
        - "Check related functionality"
        - "Monitor in production"

# Resilience Engine - Never give up
resilience_engine:
  enabled: false  # Opt-in
  description: "Systematic problem-solving with act-react loops and creative strategies"
  
  problem_solving_loop:
    description: "Structured approach when stuck"
    steps:
      - "Acknowledge stuck state (no shame)"
      - "List what you've tried"
      - "List what you know works"
      - "List what you know doesn't work"
      - "Identify smallest unknown"
      - "Design experiment to test unknown"
      - "Run experiment"
      - "Update mental model"
      - "Repeat"
      
  act_react_loop:
    description: "Rapid iteration with tight feedback"
    pattern: |
      while !solved do
        hypothesis = generate_hypothesis(current_state)
        action = design_test(hypothesis)
        result = execute(action)
        learning = observe(result)
        update_model(learning)
        sleep(think_time) if complex
      end
    parameters:
      max_iterations: 100
      think_time: 5  # seconds between iterations
      
  reset_protocol:
    description: "When to start fresh"
    triggers:
      - "Tried 10+ solutions with no progress"
      - "Lost track of what you're trying"
      - "Code becoming more complex"
      - "No longer understand the problem"
    actions:
      - "git stash"
      - "Re-read original problem"
      - "Explain problem out loud"
      - "Start with simplest possible solution"
      - "Build up from working state"
      
  creative_problem_solving:
    description: "Techniques for novel approaches"
    strategies:
      - name: "analogies"
        description: "How is this problem like X?"
        examples:
          - "Bug hunting like detective work"
          - "Caching like a library"
          - "Async like restaurant orders"
          
      - name: "constraints"
        description: "What if I couldn't use X?"
        examples:
          - "What if I had no debugger?"
          - "What if I had to fix it in 5 minutes?"
          - "What if I had to explain to non-programmer?"
          
      - name: "extreme_cases"
        description: "What about absurd inputs?"
        examples:
          - "What if input is 1 billion items?"
          - "What if input is empty?"
          - "What if input is malicious?"

# Systematic Protocols - Mandatory workflows
systematic_protocols:
  enabled: true
  description: "Required patterns before certain operations"
  
  before_entering_directory:
    pattern: "tree"
    description: "Always run tree/ls before entering new directory"
    rationale: "Understand structure before diving deep"
    command: "tree -L 2 -I 'node_modules|.git' || ls -la"
    
  before_editing_file:
    pattern: "clean"
    description: "Always read entire file before editing"
    rationale: "Context prevents breaking distant code"
    command: "cat file.rb | head -100 && wc -l file.rb"
    
  before_committing:
    pattern: "diff"
    description: "Always review diff before commit"
    rationale: "Catch unintended changes"
    command: "git diff"
    
  after_error:
    pattern: "logs"
    description: "Always check full logs after error"
    rationale: "Full context, not just error message"
    command: "journalctl -xe | tail -50"

# MASTER's 43 Constitutional Principles
principles:
  description: "Core design and implementation principles"
  
  fundamental:
    - name: "kiss"
      file: "01-kiss.yml"
      summary: "Keep It Simple, Stupid"
      
    - name: "dry"
      file: "02-dry.yml"
      summary: "Don't Repeat Yourself"
      
    - name: "yagni"
      file: "03-yagni.yml"
      summary: "You Aren't Gonna Need It"
      
    - name: "separation_of_concerns"
      file: "04-separation-of-concerns.yml"
      summary: "Each component has one concern"
      
    - name: "single_responsibility"
      file: "05-single-responsibility.yml"
      summary: "Each class/function does one thing"
  
  solid:
    - name: "open_closed"
      file: "06-open-closed.yml"
      summary: "Open for extension, closed for modification"
      
    - name: "liskov_substitution"
      file: "07-liskov-substitution.yml"
      summary: "Subtypes must be substitutable for base types"
      
    - name: "interface_segregation"
      file: "08-interface-segregation.yml"
      summary: "Many specific interfaces better than one general"
      
    - name: "dependency_inversion"
      file: "09-dependency-inversion.yml"
      summary: "Depend on abstractions, not concretions"
  
  design:
    - name: "law_of_demeter"
      file: "10-law-of-demeter.yml"
      summary: "Only talk to immediate friends"
      
    - name: "composition_over_inheritance"
      file: "11-composition-over-inheritance.yml"
      summary: "Favor composition over class inheritance"
      
    - name: "fail_fast"
      file: "12-fail-fast.yml"
      summary: "Fail immediately on invalid state"
      
    - name: "least_astonishment"
      file: "13-principle-of-least-astonishment.yml"
      summary: "Do what users expect"
      
    - name: "command_query_separation"
      file: "14-command-query-separation.yml"
      summary: "Separate commands from queries"
      
    - name: "boy_scout_rule"
      file: "15-boy-scout-rule.yml"
      summary: "Leave code better than you found it"
  
  architecture:
    - name: "unix_philosophy"
      file: "16-unix-philosophy.yml"
      summary: "Do one thing well, compose with others"
      
    - name: "functional_core_imperative_shell"
      file: "17-functional-core-imperative-shell.yml"
      summary: "Pure logic core, effects at boundaries"
      
    - name: "idempotent_operations"
      file: "18-idempotent-operations.yml"
      summary: "Same operation multiple times = same result"
      
    - name: "defensive_programming"
      file: "19-defensive-programming.yml"
      summary: "Validate inputs, handle errors gracefully"
      
    - name: "fail_gracefully"
      file: "20-fail-gracefully.yml"
      summary: "Degrade functionality, don't crash"
  
  code_quality:
    - name: "explicit_over_implicit"
      file: "21-explicit-over-implicit.yml"
      summary: "Make intent clear, no magic"
      
    - name: "convention_over_configuration"
      file: "22-convention-over-configuration.yml"
      summary: "Sensible defaults, minimal config"
      
    - name: "progressive_disclosure"
      file: "23-progressive-disclosure.yml"
      summary: "Simple surface, complexity available"
      
    - name: "real_time_feedback"
      file: "24-real-time-feedback.yml"
      summary: "Immediate response to actions"
      
    - name: "meaningful_names"
      file: "25-meaningful-names.yml"
      summary: "Names reveal intent"
      
    - name: "small_functions"
      file: "26-small-functions.yml"
      summary: "Functions should be small and focused"
      
    - name: "few_arguments"
      file: "27-few-arguments.yml"
      summary: "Functions take 0-3 arguments ideally"
      
    - name: "no_side_effects"
      file: "28-no-side-effects.yml"
      summary: "Functions don't modify external state"
      
    - name: "immutability"
      file: "29-immutability.yml"
      summary: "Prefer immutable data structures"
      
    - name: "pure_functions"
      file: "30-pure-functions.yml"
      summary: "Same input always produces same output"
  
  performance:
    - name: "cost_transparency"
      file: "31-cost-transparency.yml"
      summary: "Make computational cost visible"
      
    - name: "cache_aggressively"
      file: "32-cache-aggressively.yml"
      summary: "Cache expensive operations"
      
    - name: "squint_test"
      file: "33-squint-test.yml"
      summary: "Visual structure should reveal intent"
      
    - name: "prose_over_lists"
      file: "34-prose-over-lists.yml"
      summary: "Narrative explanations over bullet points"
      
    - name: "mass_generation_curation"
      file: "35-mass-generation-curation.yml"
      summary: "Generate many options, curate best"
  
  ui_ux:
    - name: "analog_warmth"
      file: "36-analog-warmth.yml"
      summary: "Prefer organic feel over digital perfection"
      
    - name: "guard_expensive_operations"
      file: "37-guard-expensive-operations.yml"
      summary: "Confirm before costly actions"
      
    - name: "dual_detection"
      file: "38-dual-detection.yml"
      summary: "Detect intent from context"
      
    - name: "accessible_then_technical"
      file: "39-accessible-then-technical.yml"
      summary: "Friendly surface, technical depth available"
      
    - name: "no_abbreviations"
      file: "40-no-abbreviations.yml"
      summary: "Write full words for clarity"
      
    - name: "graceful_degradation"
      file: "41-graceful-degradation.yml"
      summary: "Reduce functionality, don't fail completely"
      
    - name: "precompute_math"
      file: "42-precompute-math.yml"
      summary: "Calculate complex values at build time"
      
    - name: "audio_smoothing"
      file: "43-audio-smoothing.yml"
      summary: "Apply gentle filtering to audio output"
      
    - name: "typography_discipline"
      file: "44-typography-discipline.yml"
      summary: "Consistent, readable text presentation"
      
    - name: "silence_by_default"
      file: "45-silence-by-default.yml"
      summary: "Only speak when you have something to say"

# v38 Additional Principles
v38_principles:
  - name: "robustness"
    summary: "Handle errors, edge cases, malicious input"
    
  - name: "clarity"
    summary: "Code reads like prose, intent is obvious"
    
  - name: "simplicity"
    summary: "Fewest moving parts, easiest mental model"
    
  - name: "hygiene"
    summary: "Clean diffs, no dead code, organized imports"
    
  - name: "testability"
    summary: "Easy to test, easy to mock, easy to verify"

# Feature Flags
features:
  enable_constitutional_ai: true
  enable_bug_hunting: false
  enable_resilience: false
  enable_systematic_protocols: true
  enable_caching: true
  enable_metrics: true
  enable_achievements: false

# Metadata
stats:
  total_principles: 48
  total_personas: 7
  total_biases: 12
  total_depth_techniques: 7
  total_bug_hunting_phases: 8
