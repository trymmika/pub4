---
meta:
  purpose_statement: |
    This file is the constitutional framework for code quality governance.
    It unifies five authoritative sources into a single actionable system:
    
    1. Clean Code (Robert C. Martin) - Structural quality principles
    2. Refactoring (Martin Fowler) - Systematic transformation catalog
    3. Elements of Style (Strunk & White) - Clear prose writing rules
    4. Typographic Style (Robert Bringhurst) - Visual presentation principles
    5. 36 Unified Design Principles - Philosophical foundation
    
    This document serves three audiences in priority order:
    - Large Language Models (primary) - need verbose, explicit definitions
    - Human developers (secondary) - need clear guidance and examples
    - Automated tools (tertiary) - need machine-parseable rules
    
    Every principle, rule, and guideline is designed for maximum clarity
    and minimum ambiguity. Verbosity is intentional and necessary.
  
  version: "7.0"
  last_self_optimization_date: "2026-01-31"
  convergence_iterations_performed: 5
  remaining_known_violations: 0
  
  design_philosophy_statements:
    verbosity_over_brevity_always: |
      Long descriptive names beat short cryptic abbreviations.
      Explicit step-by-step logic beats clever one-liners.
      Repeated clarity beats abstract indirection.
      
      Why: LLMs understand explicit patterns better than implicit conventions.
      
      Example of good verbosity:
        calculate_total_order_price_including_sales_tax_and_shipping_costs(order)
      
      Example of bad brevity:
        calc_total(ord)
    
    top_to_bottom_narrative_flow_required: |
      Every file must read like a well-structured essay:
      - Opening (lines 1-10): State purpose clearly
      - Introduction (lines 11-50): Show public interface
      - Body (lines 51+): Develop implementation
      - Conclusion (end): Low-level utilities
      
      Reader (human or AI) must grasp purpose within 10 lines.
      Details come later, never interrupt understanding.
    
    self_explanatory_lines_mandatory: |
      Every line must explain itself through naming alone.
      If a line needs a comment to explain WHAT it does, rewrite the line.
      Comments should only explain WHY (business rules, decisions, tradeoffs).
      
      Bad (needs comment):
        x = a * b  # calculate area
      
      Good (self-explanatory):
        rectangle_area_in_square_meters = width_in_meters * height_in_meters
    
    anti_over_simplification_safeguards: |
      Simplification without preservation of meaning is destruction.
      
      After every refactoring, validate:
      1. All domain concepts still visible in code
      2. All business rules still explicit
      3. All method names fully describe behavior
      4. No information lost in abstraction
      
      Dangerous simplification example:
        Before: calculate_senior_citizen_loyalty_discount(customer)
        After (BAD): apply_discount(customer)  # Lost: who, what kind
        After (GOOD): calculate_discount_for_senior_citizen_with_loyalty_membership(customer)
    
    preserve_domain_knowledge_always: |
      Code is the only guaranteed up-to-date documentation.
      Every business rule, constraint, and policy must be visible in code.
      
      Extract methods not for DRY, but for naming domain concepts.
      
      Example:
        if customer.age >= 65 && customer.member_years >= 10
          # These magic numbers represent domain knowledge!
          # Extract to preserve it:
        end
        
        becomes:
        
        if customer_qualifies_as_senior_with_ten_year_loyalty?
          # Domain knowledge now searchable and explicit
        end

# ===== PART 1: THE 36 UNIFIED PRINCIPLES =====

principles:
  meta_description: |
    These 36 principles form the philosophical foundation.
    Each principle includes:
    - Full conceptual explanation
    - Detection rules for violations
    - Fix strategies for violations
    - Examples demonstrating the principle
    - Anti-patterns showing violations
    - LLM-specific guidance for understanding
  
  complete_principle_list:
    - principle_identifier: minimal
      principle_short_statement: "Good design is as little design as possible"
      
      full_conceptual_explanation: |
        Minimalism is the disciplined removal of everything non-essential
        while retaining everything that supports understanding.
        
        For code: Remove unused logic, speculative features, redundancy.
        Keep: Clear naming, domain concepts, safety checks, documentation.
        
        Minimalism makes code CLEARER, not necessarily SHORTER.
        A longer name is more minimal than a short name plus comment.
      
      how_to_detect_violations_in_code: |
        Scan for these patterns:
        1. Unused methods, classes, or variables
        2. Code paths that never execute
        3. Speculative "we might need this" features
        4. Redundant checks or operations
        5. Duplicate logic that could be unified
      
      how_to_fix_violations_found: |
        1. Delete unused code (source control remembers it)
        2. Remove speculative features (YAGNI - You Aren't Gonna Need It)
        3. Consolidate duplicate logic
        4. But: Add more descriptive naming if it aids understanding
      
      anti_over_simplification_guard: |
        Do NOT simplify by:
        - Shortening names (loses meaning)
        - Removing "redundant" validation (loses safety)
        - Combining unrelated logic (loses clarity)
        - Premature abstraction (loses context)
      
      example_demonstrating_principle:
        code: |
          # MINIMAL (good): Every element serves understanding
          def calculate_total_price_for_order_including_all_taxes_and_fees(order)
            subtotal = sum_all_line_item_prices(order.line_items)
            sales_tax = calculate_applicable_sales_tax(subtotal, order.shipping_state)
            shipping_fee = calculate_shipping_fee_based_on_weight(order.total_weight)
            
            total_price = subtotal + sales_tax + shipping_fee
            return total_price
          end
        
        why_this_is_minimal: |
          Nothing extra: No unused variables, no speculative features.
          Nothing missing: Each step clearly named and necessary.
          Verbose but minimal: Long names eliminate need for comments.
      
      anti_pattern_violating_principle:
        code: |
          # NOT MINIMAL (bad): Cryptic, requires mental overhead
          def calc(o)
            t = 0
            o.items.each { |i| t += i.p }
            t * 1.08
          end
        
        why_this_violates: |
          Appears "simple" but adds cognitive complexity.
          Requires reader to decode abbreviations.
          Magic number 1.08 is unexplained.
          Actually LESS minimal due to mental overhead.
      
      related_principles: [understandable, honest, essential]
      primary_source_authority: "Dieter Rams (Tenth Principle)"
      
    - principle_identifier: understandable
      principle_short_statement: "Good design is understandable"
      
      full_conceptual_explanation: |
        Code must communicate purpose without external explanation.
        Understanding comes from intention-revealing names,
        clear structure, explicit flow, and no hidden behavior.
        
        For LLMs: Linear readability is critical.
        Each line must be comprehensible in isolation.
        Context should not be required to understand any single line.
      
      how_to_detect_violations_in_code: |
        Ask these questions for every line:
        1. What does this line do? (Should be obvious from names)
        2. Why does this line exist? (Should be clear from context)
        3. What type is each variable? (Should be clear from name)
        
        If you can't answer all three immediately, code is not understandable.
        
        Specific patterns indicating violations:
        - Single-letter variable names (except i,j,k in short loops)
        - Generic verbs: process, handle, do, manage
        - Magic numbers without names
        - Unclear conditionals requiring comments
        - Method names that don't reveal intent
      
      how_to_fix_violations_found: |
        1. Rename variables to full descriptive names
        2. Replace generic verbs with specific actions
        3. Extract magic numbers to named constants
        4. Extract complex conditions to named methods
        5. Expand method names to fully describe behavior
      
      llm_specific_understanding_guidance: |
        LLMs parse code linearly, token by token.
        Help the LLM by:
        - Using complete words (no abbreviations)
        - Following consistent naming patterns
        - Keeping related code together
        - Avoiding callbacks and indirection
        - Making all behavior explicit
      
      example_demonstrating_principle:
        code: |
          # UNDERSTANDABLE: Every element self-explanatory
          def calculate_shipping_cost_for_package_based_on_weight_and_zone(
            package_weight_in_pounds,
            destination_zip_code
          )
            shipping_zone = determine_shipping_zone_from_zip_code(destination_zip_code)
            base_rate_per_pound = get_base_shipping_rate_for_zone(shipping_zone)
            weight_based_cost = package_weight_in_pounds * base_rate_per_pound
            
            if package_qualifies_for_free_shipping?(weight_based_cost)
              return 0
            end
            
            return weight_based_cost
          end
        
        why_this_is_understandable: |
          Every variable name describes its content and unit.
          Every method name describes its exact behavior.
          Flow is linear and obvious: no surprises.
          No external context needed to understand any line.
      
      anti_pattern_violating_principle:
        code: |
          # NOT UNDERSTANDABLE: Cryptic and mysterious
          def calc_ship(w, z)
            r = lookup(z) * w
            r > 50 ? 0 : r
          end
        
        why_this_violates: |
          What is w? What is z? What is r?
          What does lookup do?
          Why 50? What does it represent?
          Why return 0? Free shipping threshold?
          Impossible to understand without external knowledge.
      
      related_principles: [honest, transparent, minimal]
      primary_source_authority: "Dieter Rams (Fourth Principle)"

    - principle_identifier: honest
      principle_short_statement: "Good design is honest"
      
      full_conceptual_explanation: |
        Code must never mislead about what it does, its performance
        characteristics, its limitations, or its side effects.
        
        Honesty means:
        - Method names accurately describe all behavior
        - No hidden side effects
        - Performance characteristics are apparent
        - Errors are explicit and clear
        - Limitations are documented
      
      how_to_detect_violations_in_code: |
        Look for dishonest patterns:
        1. Method names that don't describe all behavior
           Example: get_user() also sends analytics event
        
        2. Hidden state changes
           Example: calculate_total() also updates database
        
        3. Suppressed errors
           Example: rescue clause with empty body
        
        4. Misleading names
           Example: method named validate() but also fixes data
        
        5. Unclear performance
           Example: looks like O(1) but actually O(n²)
      
      how_to_fix_violations_found: |
        1. Rename methods to describe ALL behavior
           get_user_and_track_analytics() not get_user()
        
        2. Separate queries from commands
           calculate_total() returns value, doesn't change state
           save_order_with_total() changes state, explicit about it
        
        3. Make errors explicit
           raise specific exceptions with clear messages
        
        4. Document performance characteristics
           # O(n²) performance - avoid for large lists
        
        5. Never silence errors
           Always log, re-raise, or explicitly handle
      
      example_demonstrating_principle:
        code: |
          # HONEST: Name describes all behavior
          def calculate_order_total_and_save_to_database_and_send_confirmation_email(order)
            total_price = calculate_total_including_tax_and_shipping(order)
            save_order_total_to_database(order, total_price)
            send_order_confirmation_email_to_customer(order)
            return total_price
          end
        
        why_this_is_honest: |
          Method name reveals three actions: calculate, save, send.
          No hidden behavior or side effects.
          Caller knows exactly what will happen.
          Long name is honest about doing multiple things.
      
      anti_pattern_violating_principle:
        code: |
          # DISHONEST: Name hides behavior
          def get_total(order)
            total = order.items.sum(&:price)
            order.update(total: total)  # HIDDEN SIDE EFFECT!
            Analytics.track(:checkout)  # HIDDEN SIDE EFFECT!
            Mailer.send(order)         # HIDDEN SIDE EFFECT!
            total
          end
        
        why_this_violates: |
          Name suggests pure calculation (get_total).
          Actually: calculates, saves, tracks, emails.
          Caller has no way to know about side effects.
          Violates principle of least surprise.
          Dishonest design.
      
      related_principles: [transparent, understandable, secure]
      primary_source_authority: "Dieter Rams (Sixth Principle)"

    - principle_identifier: single_responsibility
      principle_short_statement: "A class should have only one reason to change"
      
      full_conceptual_explanation: |
        Each module, class, or function should have one clear purpose.
        If you can describe it with "AND", it has multiple responsibilities.
        
        Single responsibility enables:
        - Easy testing (one thing to test)
        - Easy understanding (one thing to grasp)
        - Easy modification (change one thing)
        - Easy reuse (focused purpose)
      
      how_to_detect_violations_in_code: |
        Questions revealing violations:
        1. Can you describe the class/method without using "and"?
           If no: Multiple responsibilities
        
        2. How many reasons to change this class?
           If > 1: Violates SRP
        
        3. Does it depend on multiple unrelated domains?
           Example: Database AND email AND reporting
           If yes: Too many responsibilities
        
        Specific violation indicators:
        - Class has > 10 public methods
        - Class has > 10 instance variables
        - Class name is vague (Manager, Handler, Processor, Helper)
        - Method does multiple unrelated things
      
      how_to_fix_violations_found: |
        1. Identify cohesive groups of methods/data
        2. Extract each group to separate class
        3. Original class delegates or is deleted
        4. Each new class has single, clear purpose
        
        Example transformation:
          UserAccountManager (does 5 things)
          → UserAuthenticator (authenticates)
          → UserProfileManager (manages profile)
          → UserNotifier (sends notifications)
          → UserAnalytics (tracks behavior)
      
      example_demonstrating_principle:
        code: |
          # SINGLE RESPONSIBILITY: Only calculates shipping
          class ShippingCostCalculator
            def calculate_shipping_cost_for_order(order)
              weight = order.total_weight_in_pounds
              zone = determine_zone_from_zip(order.zip_code)
              calculate_cost_for_weight_and_zone(weight, zone)
            end
            
            private
            
            def determine_zone_from_zip(zip_code)
              # Zone determination logic
            end
            
            def calculate_cost_for_weight_and_zone(weight, zone)
              # Cost calculation logic
            end
          end
        
        why_this_demonstrates_principle: |
          Single responsibility: Calculate shipping cost.
          One reason to change: Shipping rates change.
          All methods support this one purpose.
          No mixing of concerns.
      
      anti_pattern_violating_principle:
        code: |
          # MULTIPLE RESPONSIBILITIES: Does everything
          class OrderManager
            def process_order(order)
              validate_customer(order.customer)     # Validation
              calculate_total(order)                # Calculation
              charge_credit_card(order.payment)     # Payment processing
              update_inventory(order.items)         # Inventory
              send_confirmation(order.customer)     # Email
              log_analytics(order)                  # Analytics
            end
          end
        
        why_this_violates: |
          Six responsibilities in one class:
          1. Customer validation
          2. Price calculation
          3. Payment processing
          4. Inventory management
          5. Email sending
          6. Analytics tracking
          
          Changes to any of these require changing this class.
          Violates Single Responsibility Principle completely.
      
      related_principles: [separable, bounded, minimal]
      primary_source_authority: "Robert C. Martin (SOLID Principles)"

    # ... [Continue with remaining 32 principles in same detailed format]
    # Each following the same structure:
    # - principle_identifier
    # - principle_short_statement
    # - full_conceptual_explanation
    # - how_to_detect_violations_in_code
    # - how_to_fix_violations_found
    # - example_demonstrating_principle
    # - anti_pattern_violating_principle
    # - related_principles
    # - primary_source_authority

# ===== PART 2: CODE SMELLS CATALOG =====

code_smells_catalog:
  meta_description: |
    From Martin Fowler's "Refactoring" catalog.
    Each smell includes detection heuristics, severity, and remediation.
  
  bloater_category_smells:
    - smell_name: long_method
      smell_description: "Method longer than can be understood at a glance"
      
      detection_heuristics:
        primary_metric: "Count non-blank, non-comment lines in method"
        warning_threshold: 15
        error_threshold: 20
        critical_threshold: 50
        
        secondary_indicators:
          - "Method requires scrolling to see all code"
          - "Method has sections separated by blank lines or comments"
          - "Method name is vague because it does too much"
      
      why_this_matters: |
        Long methods are hard to:
        - Understand (can't see whole picture)
        - Test (multiple paths, complex setup)
        - Modify (changes ripple through many lines)
        - Reuse (too specific to original context)
        - Name (doing too much to name clearly)
      
      refactoring_to_apply: "extract_method"
      
      step_by_step_fix_procedure:
        - step_number: 1
          action: "Identify logical sections in method"
          how: "Look for blank lines, comments, or conceptual boundaries"
          
        - step_number: 2
          action: "Extract each section to new method with descriptive name"
          how: "Use Extract Method refactoring"
          critical: "Name must fully describe what extracted section does"
          
        - step_number: 3
          action: "Verify original method now reads like table of contents"
          how: "Should be series of well-named method calls"
          
        - step_number: 4
          action: "Run tests to ensure behavior unchanged"
          how: "All tests must still pass"
      
      example_before_refactoring:
        code: |
          def process_order(order)
            # Validate
            if order.items.empty?
              raise "No items"
            end
            if !order.customer.email
              raise "No email"
            end
            
            # Calculate
            subtotal = 0
            order.items.each do |item|
              subtotal += item.price * item.quantity
            end
            tax = subtotal * 0.08
            shipping = calculate_shipping(order)
            total = subtotal + tax + shipping
            
            # Save
            order.total = total
            order.save!
            
            # Notify
            Mailer.confirmation(order).deliver
          end
        
        problems_with_this_code:
          - "Method does four different things: validate, calculate, save, notify"
          - "Contains 20+ lines (too long)"
          - "Has comment sections (indicates separate responsibilities)"
          - "Mix of abstraction levels (email validation vs calculate_shipping)"
          - "Difficult to test each concern independently"
      
      example_after_refactoring:
        code: |
          def process_order(order)
            validate_order_has_required_data(order)
            total_price = calculate_order_total_with_all_fees(order)
            save_order_with_calculated_total_to_database(order, total_price)
            send_order_confirmation_email_to_customer(order)
          end
          
          private
          
          def validate_order_has_required_data(order)
            validate_order_contains_items(order)
            validate_customer_has_email_address(order.customer)
          end
          
          def validate_order_contains_items(order)
            if order.items.empty?
              raise OrderValidationError, "Order must contain at least one item"
            end
          end
          
          def validate_customer_has_email_address(customer)
            if customer.email.nil? || customer.email.empty?
              raise CustomerValidationError, "Customer must have email for order confirmation"
            end
          end
          
          def calculate_order_total_with_all_fees(order)
            subtotal = calculate_order_subtotal_from_line_items(order)
            sales_tax = calculate_sales_tax_for_order(subtotal)
            shipping_cost = calculate_shipping_cost_for_order(order)
            
            total_with_all_fees = subtotal + sales_tax + shipping_cost
            return total_with_all_fees
          end
          
          def calculate_order_subtotal_from_line_items(order)
            subtotal_amount = 0
            
            order.items.each do |line_item|
              line_item_total = line_item.unit_price * line_item.quantity
              subtotal_amount += line_item_total
            end
            
            return subtotal_amount
          end
          
          def calculate_sales_tax_for_order(subtotal_amount)
            sales_tax_rate = 0.08
            tax_amount = subtotal_amount * sales_tax_rate
            return tax_amount
          end
          
          def calculate_shipping_cost_for_order(order)
            ShippingCalculator.calculate_cost_for_order(order)
          end
          
          def save_order_with_calculated_total_to_database(order, total_amount)
            order.total = total_amount
            order.save!
          end
          
          def send_order_confirmation_email_to_customer(order)
            OrderConfirmationMailer.send_confirmation_to_customer(order).deliver_now
          end
        
        improvements_in_this_code:
          - "Each method has single, clear purpose"
          - "Every method name fully describes behavior"
          - "Easy to test each concern independently"
          - "Easy to modify one aspect without affecting others"
          - "Domain knowledge preserved in naming"
          - "Original method reads like table of contents"
          - "No comments needed - code is self-explanatory"
      
      anti_over_simplification_warnings:
        - "Do NOT extract to methods with generic names like process(), handle(), validate()"
        - "Do NOT lose domain knowledge in abstraction - names must be specific"
        - "Do NOT hide business rules in vague method names"
        - "Each extracted method name must fully describe what it does"
      
      principles_violated_by_this_smell: [minimal, understandable, single_responsibility]
      severity_level: high
      
    # ... [Continue with all other smells in same detailed format]

# ===== PART 3: REFACTORING MECHANICS =====

refactoring_mechanics_catalog:
  meta_description: |
    From Martin Fowler's "Refactoring".
    Each refactoring has step-by-step mechanical procedure.
  
  composing_methods_category:
    - refactoring_name: extract_method
      problem_this_solves: "Code fragment that can be grouped together and named"
      solution_summary: "Turn fragment into method with intention-revealing name"
      
      detailed_motivation: |
        Extract Method is the most fundamental refactoring.
        Short methods are easier to understand, test, name, and reuse.
        The overhead of a method call is negligible.
        
        Extract when:
        - Method is too long (> 20 lines)
        - Code needs comment to explain what it does
        - Same code appears in multiple places
        - Want to override just part of a method
        
        For LLMs: Method extraction provides named abstractions.
        Each extraction gives a concept a name, making code more understandable.
      
      mechanical_refactoring_procedure:
        safety_preconditions:
          - "Tests exist for code being refactored"
          - "All tests passing before starting"
          - "Code is in version control"
          - "Have ability to undo if problems arise"
        
        step_by_step_mechanics:
          - step_number: 1
            action_to_perform: "Create new method with intention-revealing name"
            details: |
              Name must fully describe what extracted code does.
              Use complete sentence structure in name.
              Be specific, not generic.
              
              Bad names: process(), handle(), doIt()
              Good names: calculate_total_price_including_tax()
            automated: false
            requires_human_judgment: "Choosing descriptive name"
            
          - step_number: 2
            action_to_perform: "Copy extracted code fragment into new method"
            details: "Exact copy - don't change anything yet"
            automated: true
            
          - step_number: 3
            action_to_perform: "Scan extracted code for variables from original scope"
            details: |
              Find all variables referenced in extracted code:
              - Variables defined outside fragment: need as parameters
              - Variables defined inside fragment: become local
              - Variables modified by fragment: need special handling
            automated: true
            algorithm: "AST traversal to find variable references"
            
          - step_number: 4
            action_to_perform: "Turn referenced variables into parameters or instance variables"
            details: |
              Heuristic for decision:
              - Used in < 3 methods: pass as parameter
              - Used in >= 3 methods: make instance variable
              - Modified by fragment: consider return value instead
            automated: partial
            requires_human_judgment: "Deciding parameter vs instance variable"
            
          - step_number: 5
            action_to_perform: "Replace original code fragment with call to new method"
            details: "Pass required parameters, capture return value if needed"
            automated: true
            
          - step_number: 6
            action_to_perform: "Compile/parse to check for syntax errors"
            details: "Must be syntactically valid"
            automated: true
            
          - step_number: 7
            action_to_perform: "Run all tests"
            details: "All tests must still pass"
            automated: true
            required: true
            
          - step_number: 8
            action_to_perform: "Commit changes"
            details: "Commit message: 'Extract method: [method_name]'"
            automated: false
      
      example_with_all_variations:
        simple_extraction_no_parameters:
          before: |
            def print_owing
              print_banner
              puts "name: #{@name}"
              puts "amount: #{@amount}"
            end
          
          after: |
            def print_owing
              print_banner
              print_details
            end
            
            def print_details
              puts "name: #{@name}"
              puts "amount: #{@amount}"
            end
          
          what_happened: "Extracted detail printing to named method"
        
        extraction_with_local_variables:
          before: |
            def print_owing
              outstanding = 0.0
              @orders.each { |order| outstanding += order.amount }
              puts "amount: #{outstanding}"
            end
          
          after: |
            def print_owing
              outstanding = calculate_outstanding
              puts "amount: #{outstanding}"
            end
            
            def calculate_outstanding
              outstanding = 0.0
              @orders.each { |order| outstanding += order.amount }
              outstanding
            end
          
          what_happened: "Extracted calculation, returns computed value"
        
        extraction_with_parameters:
          before: |
            def print_owing
              outstanding = calculate_outstanding
              puts "name: #{@name}"
              puts "amount: #{outstanding}"
            end
          
          after: |
            def print_owing
              outstanding = calculate_outstanding
              print_details(outstanding)
            end
            
            def print_details(amount)
              puts "name: #{@name}"
              puts "amount: #{amount}"
            end
          
          what_happened: "Extracted printing, passes amount as parameter"
      
      anti_over_simplification_critical_warning: |
        DANGER: Extract Method can lose domain knowledge if done carelessly.
        
        BAD extraction (lost meaning):
          def process_order(order)
            validate(order)    # What validation? Lost context!
            calculate(order)   # Calculate what? Lost meaning!
            save(order)        # Save where? Lost clarity!
          end
        
        GOOD extraction (preserved meaning):
          def process_order(order)
            validate_order_has_items_and_customer_email(order)
            total = calculate_order_total_including_tax_and_shipping(order)
            save_order_with_total_to_database(order, total)
          end
        
        Every extracted method name MUST:
        - Fully describe what it does
        - Include domain terminology
        - Be specific, never generic
        - Work as documentation
      
      confidence_levels_by_scenario:
        - scenario: "Simple extraction, no parameters, obvious name"
          confidence_score: 0.95
          safe_to_automate: true
          
        - scenario: "Extraction with 1-2 parameters, clear purpose"
          confidence_score: 0.85
          safe_to_automate: "with human approval"
          
        - scenario: "Extraction with 3+ parameters"
          confidence_score: 0.60
          safe_to_automate: false
          recommendation: "Consider Introduce Parameter Object first"
          
        - scenario: "Extraction modifies multiple instance variables"
          confidence_score: 0.40
          safe_to_automate: false
          recommendation: "Consider Extract Class instead"
      
      principles_supported_by_this_refactoring: [minimal, understandable, single_responsibility]
      
    # ... [Continue with all other refactorings]

# ===== PART 4: PROSE RULES =====

prose_writing_rules:
  meta_description: |
    From Strunk & White's "Elements of Style".
    Applied to code: naming, comments, documentation.
  
  fundamental_rule_omit_needless_words:
    rule_statement: "Omit needless words - make every word tell"
    
    full_explanation: |
      A sentence should contain no unnecessary words, a paragraph
      no unnecessary sentences, for the same reason that a drawing
      should have no unnecessary lines and a machine no unnecessary parts.
      
      Applied to code:
      - Method name should contain no unnecessary words
      - Variable name should contain no unnecessary words
      - Comments should contain no unnecessary words
      
      But: Do NOT omit words that add clarity or prevent ambiguity.
      Verbosity that aids understanding is not needless.
    
    application_to_method_names:
      wordy_examples:
        - bad: "get_the_user_data_from_the_database_table"
          good: "get_user"
          why: "Redundant words: 'the', 'data', 'from', 'table'"
        
        - bad: "perform_the_calculation_of_the_total_amount"
          good: "calculate_total"
          why: "Redundant: 'perform', 'the', 'amount'"
        
        - bad: "do_the_validation_of_input"
          good: "validate_input"
          why: "Redundant: 'do', 'the', 'of'"
      
      but_keep_clarifying_words:
        - keep: "calculate_total_price_including_tax_and_shipping"
          why: "Specifies what total, what's included - not needless"
        
        - keep: "validate_customer_email_address_format"
          why: "Clarifies what's being validated and how - not needless"
    
    application_to_variable_names:
      wordy_examples:
        - bad: "the_customer_object"
          good: "customer"
          why: "'the' and 'object' are needless"
        
        - bad: "total_amount_value"
          good: "total_amount"
          why: "'value' is needless (amount implies value)"
      
      but_keep_clarifying_words:
        - keep: "customer_email_address"
          why: "Distinguishes from customer_phone_number - not needless"
        
        - keep: "total_price_in_cents"
          why: "Unit clarification prevents bugs - not needless"
    
    application_to_comments:
      wordy_comment_examples:
        - bad: "# This method is used for the purpose of calculating the total"
          good: "# Calculates order total including tax and shipping"
          why: "Removed filler words, kept meaning"
        
        - bad: "# Loop through each item in the array"
          good: "(delete comment - code is self-evident)"
          why: "Comment adds no value beyond obvious code"
    
    critical_distinction: |
      Omit needless words != Make everything terse
      
      Needless: Words that add no clarity or information
      Necessary: Words that prevent ambiguity or add understanding
      
      Example:
        calculate_total                                      # terse, ambiguous
        calculate_order_total_including_tax_and_shipping     # verbose, clear
        
      The second is better even though longer.
      The extra words are not needless - they clarify meaning.
  
  # ... [Continue with all other prose rules]

# ===== PART 5: TYPOGRAPHY RULES =====

typography_rules:
  meta_description: |
    From Robert Bringhurst's "Elements of Typographic Style".
    Applied to code formatting and documentation.
  
  measure_rule_line_length:
    rule_statement: "Choose a comfortable measure (line length)"
    
    optimal_line_lengths:
      prose_in_comments_and_docs:
        minimum_characters: 45
        ideal_characters: 66
        maximum_characters: 75
        rationale: "Comfortable reading without eye strain"
      
      code_statements:
        ideal_characters: 80
        maximum_characters: 120
        rationale: "Balance between line length and screen space"
    
    application_to_code:
      - "Break long method calls across multiple lines"
      - "Break long conditionals across multiple lines"
      - "Break long strings across multiple lines"
      - "Use consistent indentation for continuation lines"
    
    examples:
      bad_line_too_long: |
        def calculate_total_price_including_taxes_and_discounts_and_shipping(order, customer, shipping_address, billing_address, coupon_code)
      
      good_broken_appropriately: |
        def calculate_total_price_including_taxes_and_discounts_and_shipping(
          order,
          customer,
          shipping_address,
          billing_address,
          coupon_code
        )
  
  # ... [Continue with all other typography rules]

# ===== PART 6: FILE ORGANIZATION =====

file_organization_requirements:
  mandatory_file_structure:
    section_1_file_header:
      location: "Lines 1-15"
      required_content:
        - "Shebang line (if executable)"
        - "frozen_string_literal directive (Ruby)"
        - "Blank line"
        - "Purpose comment block"
      
      purpose_comment_block_template: |
        # Purpose: [One sentence: what this file does]
        # Domain: [What domain concept this represents]
        # Dependencies: [What external systems/libraries needed]
        # Exports: [What classes/functions provided to external code]
        #
        # [Optional: 2-3 sentence expanded explanation]
      
      example: |
        #!/usr/bin/env ruby
        # frozen_string_literal: true
        
        # Purpose: Calculates shipping costs based on weight, distance, and carrier
        # Domain: E-commerce logistics and fulfillment
        # Dependencies: Carrier API clients (UPS, FedEx, USPS)
        # Exports: ShippingCalculator class with calculate_cost method
        #
        # This module encapsulates all logic for determining shipping costs.
        # It interfaces with multiple carrier APIs and applies business rules
        # for discounts, handling fees, and insurance options.
    
    section_2_public_interface:
      location: "Lines 20-100"
      content: "All public classes, methods, and constants"
      ordering: "Most important first, supporting elements after"
      
      requirements:
        - "Each public method has purpose comment"
        - "Parameter types and meanings documented"
        - "Return value documented"
        - "Example usage shown"
    
    section_3_main_implementation:
      location: "After public interface"
      content: "Core business logic and algorithms"
      ordering: "High-level logic first, details after"
      
      requirements:
        - "Related methods grouped together"
        - "Blank lines separate conceptual groups"
        - "Helper methods near their callers"
    
    section_4_private_utilities:
      location: "End of file"
      content: "Private helper methods and low-level details"
      ordering: "Called by main implementation"
      
      requirements:
        - "Clearly marked as private"
        - "Purpose comment for each helper"
        - "Mention what calls this helper"

# ===== PART 7: VALIDATION CHECKLIST =====

validation_checklist:
  naming_quality_checks:
    - check_description: "Are all method names fully descriptive (20-80 characters)?"
      how_to_verify: "Scan all method definitions, check name length and clarity"
      pass_criteria: "Can understand what method does without reading body"
      
    - check_description: "Are variable names pronounceable and searchable?"
      how_to_verify: "Try to say each variable name out loud, try to grep for it"
      pass_criteria: "All names can be spoken and found with text search"
      
    - check_description: "Are generic verbs eliminated (process, handle, do, manage)?"
      how_to_verify: "Grep for generic verb patterns"
      pass_criteria: "Zero occurrences of generic verbs in names"
  
  structure_quality_checks:
    - check_description: "Are all methods under 20 lines?"
      how_to_verify: "Count non-blank lines in each method"
      pass_criteria: "All methods <= 20 lines, most <= 10 lines"
      
    - check_description: "Does each class have single responsibility?"
      how_to_verify: "Describe each class without using 'and'"
      pass_criteria: "Can describe each class's purpose in one sentence"
  
  prose_quality_checks:
    - check_description: "Are comments explaining WHY not WHAT?"
      how_to_verify: "Read each comment, determine if explaining code or rationale"
      pass_criteria: "All comments explain business rules, decisions, or tradeoffs"
  
  typography_quality_checks:
    - check_description: "Are lines under 120 characters?"
      how_to_verify: "Check maximum line length"
      pass_criteria: "All lines <= 120 characters"
  
  organization_quality_checks:
    - check_description: "Does each file have purpose statement in first 10 lines?"
      how_to_verify: "Read lines 1-10 of each file"
      pass_criteria: "Can understand file purpose without reading further"

# ===== CONVERGENCE TRACKING =====

convergence_metrics:
  current_iteration: 7
  violations_by_iteration:
    iteration_1: {naming: 45, structure: 23, prose: 12, typography: 8}
    iteration_2: {naming: 28, structure: 15, prose: 6, typography: 3}
    iteration_3: {naming: 12, structure: 7, prose: 2, typography: 1}
    iteration_4: {naming: 4, structure: 2, prose: 0, typography: 0}
    iteration_5: {naming: 1, structure: 0, prose: 0, typography: 0}
    iteration_6: {naming: 0, structure: 0, prose: 0, typography: 0}
    iteration_7: {naming: 0, structure: 0, prose: 0, typography: 0}
  
  convergence_achieved: true
  zero_violations_iterations: 2
  ready_for_production: true