---
version: "48.1"
date: "2026-02-03"
philosophy: "Constitutional correctness through LLM reasoning, battle-tested safety"
symbiosis: "cli.rb ⟷ master.yml - neither functions alone"

meta:
  approach: "LLM-native detection, zero regex patterns, sensible defaults"
  separation: "master.yml (rules/principles/workflows) + cli.rb (thin enforcer)"
  safety: "All edge cases handled, production-ready"
  defaults:
    auto_iterate: true
    auto_refactor: true
    auto_progress: true
    target_score: 100
    max_iterations: 10

# FLAT PRINCIPLE REGISTRY
# Single source of truth, no duplication
principles:
  clarity:
    id: 1
    tier: axiom
    priority: 10
    name: "Clarity Over Cleverness"
    rule: "Written for reader, understandable at 3am"
    why: "Code read 10x more than written"
    smells:
      - vague_names
      - deep_nesting
      - clever_tricks
      - unclear_intent
      - hidden_behavior
    evidence: "Reader can understand without running code"
    auto_fixable: true
    llm_strategies: [rename, extract_method, add_comments, simplify]

  simplicity:
    id: 2
    tier: axiom
    priority: 10
    name: "KISS"
    rule: "Simplest solution that works"
    why: "Complexity is the enemy of reliability"
    smells:
      - unnecessary_abstraction
      - premature_generalization
      - overengineering
      - complex_oneliners
    evidence: "No unused abstractions, direct solution"
    auto_fixable: true
    llm_strategies: [inline, remove_abstraction, expand_chain]

  evolution:
    id: 3
    tier: axiom
    priority: 9
    name: "Gall's Law"
    rule: "Evolve from working systems, no big-bang rewrites"
    why: "Complex systems that work evolved from simple systems that worked"
    smells:
      - complete_rewrite
      - new_framework_without_reason
      - breaking_working_code
    evidence: "Git history shows incremental changes"
    auto_fixable: false
    llm_strategies: [suggest_incremental_path]

  explicit:
    id: 4
    tier: axiom
    priority: 10
    name: "Explicit Over Implicit"
    rule: "No hidden magic, behavior visible"
    why: "Hidden behavior causes bugs"
    smells:
      - metaprogramming_abuse
      - hidden_side_effects
      - implicit_conversions
      - magic_methods
    evidence: "All behavior traceable from reading code"
    auto_fixable: true
    llm_strategies: [make_explicit, inline_magic]

  scientific:
    id: 5
    tier: axiom
    priority: 8
    name: "Scientific Method"
    rule: "Observe, hypothesize, experiment, measure"
    why: "Decisions need evidence, not opinions"
    smells:
      - no_measurements
      - untested_assumptions
      - premature_optimization
    evidence: "Benchmarks, tests, profiling data"
    auto_fixable: false
    llm_strategies: [suggest_measurement]

  divide:
    id: 6
    tier: axiom
    priority: 8
    name: "Divide and Conquer"
    rule: "Break complex into independent subproblems"
    why: "Complexity managed through decomposition"
    smells:
      - monolithic_function
      - tight_coupling
      - circular_dependencies
    evidence: "Dependency graph is DAG, modules independent"
    auto_fixable: true
    llm_strategies: [extract_module, break_coupling]

  rubber_duck:
    id: 7
    tier: axiom
    priority: 6
    name: "Rubber Duck Debugging"
    rule: "Explain aloud to find clarity"
    why: "Explanation reveals misunderstanding"
    smells:
      - cant_explain_code
      - convoluted_logic
    evidence: "Can explain code in plain English"
    auto_fixable: false
    llm_strategies: [request_explanation]

  blame_self:
    id: 8
    tier: axiom
    priority: 7
    name: "Assume Your Bug First"
    rule: "Framework/compiler blamed last"
    why: "99% of bugs are user error"
    smells:
      - blaming_tools
      - not_reading_docs
    evidence: "Reproduced in minimal example"
    auto_fixable: false
    llm_strategies: [suggest_minimal_reproduction]

  git_bisect:
    id: 9
    tier: axiom
    priority: 6
    name: "Version Control as Time Machine"
    rule: "Use git bisect religiously"
    why: "Broken commit is findable"
    smells:
      - huge_commits
      - uncommitted_code
      - broken_main
    evidence: "Every commit builds and passes tests"
    auto_fixable: false
    llm_strategies: [suggest_bisect]

  read_source:
    id: 10
    tier: axiom
    priority: 7
    name: "Read the Code"
    rule: "Source is truth, docs lie"
    why: "Documentation drifts, code doesn't"
    smells:
      - trusting_old_docs
      - not_checking_implementation
    evidence: "Verified behavior in source"
    auto_fixable: false
    llm_strategies: [point_to_source]

  srp:
    id: 11
    tier: solid
    priority: 8
    name: "Single Responsibility"
    rule: "One reason to change"
    why: "Changes isolated, easy to understand"
    smells:
      - god_class
      - long_method
      - multiple_concerns
      - mixed_abstraction_levels
    evidence: "Class/method has one clear purpose"
    auto_fixable: true
    llm_strategies: [extract_class, extract_method]

  ocp:
    id: 12
    tier: solid
    priority: 7
    name: "Open/Closed"
    rule: "Open for extension, closed for modification"
    why: "Add features without breaking existing code"
    smells:
      - hardcoded_switch
      - modification_to_extend
    evidence: "New feature added without changing existing code"
    auto_fixable: true
    llm_strategies: [introduce_polymorphism, strategy_pattern]

  lsp:
    id: 13
    tier: solid
    priority: 8
    name: "Liskov Substitution"
    rule: "Subtypes substitutable for base"
    why: "Polymorphism works correctly"
    smells:
      - different_interfaces
      - type_checking
      - refused_bequest
    evidence: "Subtype works wherever parent works"
    auto_fixable: false
    llm_strategies: [suggest_interface_fix]

  isp:
    id: 14
    tier: solid
    priority: 7
    name: "Interface Segregation"
    rule: "Many specific interfaces over one general"
    why: "Clients don't depend on unused methods"
    smells:
      - fat_interface
      - unused_methods
    evidence: "Every interface method is used by all implementers"
    auto_fixable: true
    llm_strategies: [split_interface]

  dip:
    id: 15
    tier: solid
    priority: 7
    name: "Dependency Inversion"
    rule: "Depend on abstractions, not concretions"
    why: "Implementation details swappable"
    smells:
      - concrete_dependency
      - new_in_constructor
      - global_state
    evidence: "Dependencies injected, not instantiated"
    auto_fixable: true
    llm_strategies: [inject_dependency, introduce_interface]

  dry:
    id: 16
    tier: coding
    priority: 5
    name: "Don't Repeat Yourself"
    rule: "Single authoritative representation"
    why: "Change in one place, not scattered"
    smells:
      - duplicate_code
      - copy_paste
      - parallel_class_hierarchies
    evidence: "No code duplication"
    auto_fixable: true
    llm_strategies: [extract_method, extract_constant]
    caveat: "Rule of Three: duplicate twice, abstract third time"
    conflicts_with: [17, 18]

  wet:
    id: 17
    tier: coding
    priority: 7
    name: "Write Everything Twice"
    rule: "Duplication better than wrong abstraction"
    why: "Premature abstraction harder to change than duplication"
    when: "Early in feature, pattern unclear"
    smells:
      - forced_abstraction
      - wrong_abstraction
    evidence: "Duplication is deliberate, waiting for pattern"
    auto_fixable: false
    llm_strategies: [suggest_wait]
    overrides: [16]

  aha:
    id: 18
    tier: coding
    priority: 7
    name: "Avoid Hasty Abstractions"
    rule: "Optimize for change, not duplication"
    why: "Wrong abstraction costlier than duplication"
    smells:
      - premature_abstraction
      - overengineered_solution
    evidence: "Abstraction emerged from real need"
    auto_fixable: false
    llm_strategies: [suggest_simplification]
    overrides: [16]

  names:
    id: 19
    tier: clean_code
    priority: 6
    name: "Meaningful Names"
    rule: "Intention-revealing, pronounceable, searchable"
    why: "Good names eliminate need for comments"
    smells:
      - single_letter_names
      - abbreviations
      - noise_words
      - number_series
      - hungarian_notation
      - vague_names
    evidence: "Names reveal intent without comments"
    auto_fixable: true
    llm_strategies: [rename_variable, rename_method, rename_class]

  small_functions:
    id: 20
    tier: clean_code
    priority: 7
    name: "Small Functions"
    rule: "Do one thing, max 10 lines"
    why: "Easy to understand, test, reuse"
    threshold: {ideal: 4, target: 10, max: 20}
    smells:
      - long_method
      - multiple_concerns_in_method
    evidence: "Function does one thing at one abstraction level"
    auto_fixable: true
    llm_strategies: [extract_method, inline_method]

  arguments:
    id: 21
    tier: clean_code
    priority: 6
    name: "Few Arguments"
    rule: "Ideal 0, next 1, avoid 2, justify 3, never 4+"
    why: "More arguments = harder to understand and test"
    smells:
      - flag_arguments
      - long_parameter_list
    evidence: "Arguments fit on one line, all required"
    auto_fixable: true
    llm_strategies: [introduce_parameter_object, extract_class]

  cqs:
    id: 22
    tier: clean_code
    priority: 7
    name: "Command-Query Separation"
    rule: "Change state OR return data, never both"
    why: "Side effects and queries mixed cause confusion"
    smells:
      - side_effects_in_query
      - mixed_cqs
    evidence: "Methods either mutate or return, not both"
    auto_fixable: true
    llm_strategies: [split_command_query]

  no_side_effects:
    id: 23
    tier: clean_code
    priority: 8
    name: "No Hidden Side Effects"
    rule: "Function does what name promises"
    why: "Hidden side effects cause bugs"
    smells:
      - hidden_mutation
      - temporal_coupling
      - global_state_modification
    evidence: "All side effects documented or absent"
    auto_fixable: false
    llm_strategies: [document_side_effect, remove_side_effect]

  progressive_disclosure:
    id: 24
    tier: ui
    priority: 5
    name: "Progressive Disclosure"
    rule: "Show only what's needed now, reveal on demand"
    why: "Cognitive load reduced"
    smells:
      - information_overload
      - showing_everything
    evidence: "Default output is minimal, --verbose for details"
    auto_fixable: false
    llm_strategies: [suggest_default_output]

  real_time_feedback:
    id: 25
    tier: ui
    priority: 6
    name: "Real-Time Feedback"
    rule: "User always knows what's happening"
    why: "Uncertainty causes anxiety"
    smells:
      - silent_processing
      - no_progress_indicator
      - unclear_status
    evidence: "Progress shown, operations time-bounded"
    auto_fixable: false
    llm_strategies: [add_progress_indicator]

  cost_transparency:
    id: 26
    tier: llm
    priority: 8
    name: "Cost Transparency"
    rule: "Show token usage and cost for every LLM call"
    why: "Users need to understand costs"
    format: "tokens=1234 cached=890 cost=$0.0045"
    smells:
      - hidden_costs
      - surprise_bills
    evidence: "Every LLM call shows tokens and cost"
    auto_fixable: false
    llm_strategies: [add_cost_tracking]

  fail_gracefully:
    id: 27
    tier: llm
    priority: 9
    name: "Fail Gracefully"
    rule: "Degrade to manual mode if LLM unavailable"
    why: "Tool remains useful without LLM"
    smells:
      - hard_dependency_on_llm
      - no_fallback
    evidence: "Tool works without API key, degrades gracefully"
    auto_fixable: false
    llm_strategies: [add_fallback_mode]

  cache_aggressively:
    id: 28
    tier: llm
    priority: 6
    name: "Cache Aggressively"
    rule: "Use prompt caching for repeated large contexts"
    why: "90% cost reduction possible"
    smells:
      - no_caching
      - cache_invalidation_wrong
    evidence: "Cached tokens shown in output"
    auto_fixable: false
    llm_strategies: [enable_caching]

  idempotent:
    id: 29
    tier: operations
    priority: 9
    name: "Idempotent Operations"
    rule: "Running twice produces same result as once"
    why: "Safe to retry, predictable behavior"
    smells:
      - non_idempotent_mutation
      - append_without_check
    evidence: "Same input always produces same output"
    auto_fixable: false
    llm_strategies: [make_idempotent]

  unix_philosophy:
    id: 30
    tier: design
    priority: 7
    name: "Unix Philosophy"
    rule: "Do one thing well, compose via pipes"
    why: "Composability enables power"
    patterns: ["text in/out", "exit codes", "silence = success"]
    smells:
      - does_many_things
      - non_composable
      - verbose_success
    evidence: "Tool composable with pipes, follows Unix conventions"
    auto_fixable: false
    llm_strategies: [suggest_unix_pattern]

  functional_core:
    id: 31
    tier: architecture
    priority: 9
    name: "Functional Core, Imperative Shell"
    rule: "Pure functions in core, IO at boundaries"
    why: "Testable without mocks, easy to reason about"
    pattern: "Core module (pure) + Shell classes (IO)"
    smells:
      - io_in_business_logic
      - hidden_state_mutation
      - untestable_functions
    evidence: "Same input → same output, no side effects in core"
    auto_fixable: true
    llm_strategies: [extract_pure_function, move_io_to_shell]

  safe_refactoring:
    id: 32
    tier: operations
    priority: 10
    name: "Safe Refactoring with Rollback"
    rule: "Always backup before modification, enable undo"
    why: "Fearless experimentation"
    pattern: "Save → Modify → Verify → (Rollback if needed)"
    smells:
      - no_backup
      - destructive_operation
      - no_undo
    evidence: "Every modification creates backup, rollback available"
    auto_fixable: false
    llm_strategies: [add_backup_mechanism]

# STYLE PREFERENCES
style:
  ruby:
    indentation: 2
    quotes: "double"
    line_length: 120
    frozen_literal: required
    implicit_return: preferred
    blocks: "do/end for multi-line, {} for single-line"

  comments:
    explain_why_not_what: true
    no_ascii_art: true
    update_with_code: true

  structure:
    max_method_lines: 10
    max_class_lines: 100
    max_nesting_depth: 4

# 7 PHASES
phases:
  discover:
    id: 1
    goal: "Understand actual need"
    output: "Problem statement with success criteria"
    gates: [no_vague_words, audience_identified, success_measurable]

  analyze:
    id: 2
    goal: "Break into components"
    output: "Component diagram with dependencies"
    gates: [components_distinct, dependencies_acyclic, failure_modes_documented]

  ideate:
    id: 3
    goal: "Generate 15+ alternatives"
    output: "List of approaches with trade-offs"
    gates: [count_gte_15, distinct_approaches, trade_offs_documented]

  design:
    id: 4
    goal: "Specific architecture"
    output: "Interface definitions and error handling"
    gates: [interfaces_explicit, errors_documented, test_strategy_defined]

  implement:
    id: 5
    goal: "Execute with zero violations"
    output: "Working code at 100/100 score"
    gates: [tests_pass, zero_violations, docs_updated]

  validate:
    id: 6
    goal: "Prove with evidence"
    output: "Test results, benchmarks, edge cases"
    gates: [zero_test_failures, edge_cases_covered, evidence_collected]

  deliver:
    id: 7
    goal: "Ship with monitoring"
    output: "Deployed code with dashboards"
    gates: [deployed, monitoring_configured, rollback_tested]

# LLM CONFIGURATION
llm:
  # Tiered pipeline: cheap → medium → strong (60-80% cost savings)
  tiers:
    fast:
      model: "qwen/qwen2.5-coder-32b-instruct"
      temperature: 0.2
      max_tokens: 2048
      cost_weight: 1.0
      use_for: [detection, smell_scan]
    medium:
      model: "anthropic/claude-3.5-sonnet"
      temperature: 0.4
      max_tokens: 4096
      cost_weight: 5.0
      use_for: [explanation, refactoring]
    strong:
      model: "anthropic/claude-opus-4"
      temperature: 0.1
      max_tokens: 8192
      cost_weight: 20.0
      use_for: [validation, judgment, gardening]

  default_tier_sequence: [fast, medium, strong]

  # Prompt caching (75-90% savings on repeated system prompts)
  prompt_caching:
    enabled: true
    default_ttl: "1h"
    breakpoints:
      - system_prompt
      - principles_summary
      - recent_violations

  detection:
    enabled: true
    model: "qwen/qwen2.5-coder-32b-instruct"
    fallback_models:
      - "anthropic/claude-3.5-sonnet"
      - "google/gemini-2.0-flash-exp:free"
    prompt: |
      TASK: Analyze code against 32 coding principles. Return JSON array of violations.
      
      OUTPUT FORMAT (strict JSON, no markdown):
      [
        {
          "principle_id": 19,
          "line": 42,
          "severity": "high",
          "smell": "vague_variable",
          "explanation": "Variable 'data' lacks intent",
          "suggested_fix": "Rename to 'user_preferences'",
          "auto_fixable": true
        }
      ]
      
      SEVERITY LEVELS:
      - veto: blocks release (security, crashes)
      - high: must fix (bugs, major clarity issues)
      - medium: should fix (code smells, maintainability)
      - low: nice to have (style, minor improvements)
      
      RULES:
      - Return [] if code is clean
      - Return ONLY valid JSON array
      - NO markdown code blocks
      - NO explanation text outside JSON

  refactoring:
    enabled: true
    model: "anthropic/claude-3.5-sonnet"
    fallback_models:
      - "openai/gpt-4o"
    strategies:
      extract_method: {max_tokens: 3000, temperature: 0.2}
      rename_variable: {max_tokens: 500, temperature: 0.3}
      extract_class: {max_tokens: 5000, temperature: 0.1}
      flatten_nesting: {max_tokens: 2000, temperature: 0.2}
      simplify_condition: {max_tokens: 1000, temperature: 0.2}

  phase_validation:
    enabled: true
    model: "anthropic/claude-opus-4"
    fallback_models:
      - "anthropic/claude-3.5-sonnet"

  consensus:
    enabled: false
    models: ["anthropic/claude-3.5-sonnet", "openai/gpt-4o", "google/gemini-2.0-flash-exp:free"]
    required_agreement: 2

# LEARNED SMELLS (self-improving constitution)
learned_smells: []
# Example entry added by gardener:
# - id: learned_001
#   trigger_smell: "unsafe_eval_in_migration"
#   priority: 9
#   description: "Avoid eval() in migrations"
#   source_iteration: "file.rb iteration 4"

# SAFETY CONFIGURATION
safety:
  file_validation:
    max_size_bytes: 10_485_760
    max_lines: 10_000
    check_binary: true
    check_permissions: true
    check_special_files: true
    allow_symlinks: false
    binary_extensions: [".png", ".jpg", ".gif", ".mp4", ".pdf", ".so", ".dylib", ".o", ".a"]

  cost_protection:
    max_per_file: 1.00
    max_per_session: 10.00
    warn_at: 0.50
    chunk_large_files: true
    chunk_size_lines: 500
    chunk_overlap_lines: 50

  convergence:
    max_iterations: 10
    detect_loops: true
    detect_oscillation: true
    max_total_violations: 10_000
    max_history_size: 10
    require_improvement: true

  fix_validation:
    enabled: true
    check_priority_inversion: true
    check_new_violations: true
    max_new_violations: 0

  concurrency:
    file_locking: true
    lock_timeout: 30
    stale_lock_age: 300
    lock_dir: ".constitutional_locks"

  transactions:
    enabled: true
    rollback_on_error: true
    atomic_operations: true

  yaml_safety:
    max_constitution_size: 10_485_760
    load_timeout: 5

  memory:
    max_violation_objects: 100_000
    gc_every_n_iterations: 5

# DEFAULTS
defaults:
  scan: true
  iterate: true
  refactor: true
  progress_phases: true
  target_score: 100
  max_iterations: 10
  backup: true
  backup_count: 5
  verbose: false
  colors: true
  interactive_on_failure: false
  ask_language: true

# CONFLICT RESOLUTION
conflicts:
  strategy: "highest_priority_wins"
  prompt_user: false
  log_all: true

  rules:
    - condition: "dry conflicts with wet or aha"
      resolution: "favor wet/aha if fewer than 3 duplications"

    - condition: "clarity conflicts with simplicity"
      resolution: "favor clarity (same priority, but clarity is axiom)"

    - condition: "fix introduces higher priority violation"
      resolution: "reject fix"

# LANGUAGE DETECTION
language_detection:
  strategy: "ask_user_first"
  fallback: "content_analysis"
  supported:
    ruby:
      extensions: [".rb", ".rake", ".gemspec"]
      indicators: ["#!/usr/bin/env ruby", "class ", "module ", "def ", "require "]

    python:
      extensions: [".py"]
      indicators: ["#!/usr/bin/env python", "def ", "class ", "import "]

    javascript:
      extensions: [".js", ".jsx", ".ts", ".tsx"]
      indicators: ["function ", "const ", "let ", "var ", "import "]

    markdown:
      extensions: [".md", ".markdown"]
      indicators: ["# ", "## ", "```"]

    yaml:
      extensions: [".yml", ".yaml"]
      indicators: ["---", "key: value"]

    shell:
      extensions: [".sh", ".bash", ".zsh"]
      indicators: ["#!/bin/bash", "#!/bin/sh", "if [", "for "]

# MICRO-REFINEMENTS
refinements:
  pattern_detection:
    old: "50+ regex patterns in YAML"
    new: "Single LLM reasoning call"
    benefit: "Catches nuanced violations, zero maintenance"

  section_duplication:
    old: "Same rule in constitution, principles, and implementation"
    new: "Flat principle registry, reference by ID"
    benefit: "DRY, single source of truth"

  user_workflow:
    old: "User runs 3+ commands manually"
    new: "Single command does everything"
    benefit: "Zero cognitive load, sensible defaults"

  edge_case_handling:
    old: "Basic error checking"
    new: "15 edge cases handled: hallucination, cost explosion, infinite loops, conflicts, binary files, permissions, symlinks, concurrent access, network interruption, priority inversion, memory exhaustion, YAML bombs, circular references"
    benefit: "Production-ready, battle-tested"

  language_detection:
    old: "Extension-only detection"
    new: "Ask user first, fallback to content analysis"
    benefit: "Accurate, handles edge cases (no extension, wrong extension, polyglot)"

  llm_fallback:
    old: "Single model, fail on error"
    new: "Multi-model RAG with graceful degradation"
    benefit: "High availability, cost optimization"

  cost_tracking:
    old: "Per-call tracking"
    new: "Per-file and per-session limits with warnings"
    benefit: "Budget protection, no surprises"

  convergence_detection:
    old: "Fixed iterations"
    new: "Loop detection, oscillation detection, improvement tracking"
    benefit: "Faster convergence, catches stuck states"

  fix_validation:
    old: "Apply fix blindly"
    new: "Validate fix doesn't introduce worse violations"
    benefit: "Priority-aware, prevents regressions"

  file_safety:
    old: "Assume regular file"
    new: "Check binary, permissions, special files, symlinks"
    benefit: "Safe operations, no surprises"

  concurrency:
    old: "No locking"
    new: "File locking with stale detection"
    benefit: "Safe concurrent use"

  transactions:
    old: "Partial updates on failure"
    new: "Atomic operations with automatic rollback"
    benefit: "Consistent state always"

  memory_management:
    old: "Unlimited history"
    new: "Bounded history, periodic GC"
    benefit: "Handles large files without OOM"

  yaml_safety:
    old: "Unrestricted YAML load"
    new: "Size limit, timeout, bomb detection"
    benefit: "Prevents DoS attacks"

  principle_priority:
    old: "No priority system"
    new: "10-point priority scale with conflict resolution"
    benefit: "Clear decision making, no ambiguity"

  separation_of_concerns:
    old: "Logic mixed in YAML and code"
    new: "master.yml (rules/principles/workflows) + cli.rb (thin enforcer)"
    benefit: "Clear architecture, easy to maintain"
