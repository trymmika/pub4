# master.yml LLM OS - Master Configuration
#
# Constitutional AI: 32 principles, LLM config, safety, extensibility
#
# Architecture: Symbiotic pair
#   master.yml: Rules, principles, workflows (declarative)
#   cli.rb: Thin enforcer (imperative)
#
# Section order (by importance):
#   1. IDENTITY - What this system is
#   2. STRUCTURAL ANALYSIS - Code quality questions
#   3. DEFAULTS - Runtime behavior
#   4. PRINCIPLES - The 32 coding principles (core)
#   5. STYLE - Formatting preferences
#   6. PHASES - 7-phase workflow
#   7. LLM - Model configuration
#   8. LEARNED SMELLS - Self-improving rules
#   9. SAFETY - Protection settings
#   10. CONFLICTS - Resolution rules
#   11. PRINCIPLE GROUPS - Logical groupings
#   12. PROFILES - Pre-defined scans
#   13. HOOKS - Event extensibility
#   14. LANGUAGE DETECTION - File types
#   15. OPENBSD - Platform config
#   16. PROVIDERS - LLM/infra integrations
#   17. REFINEMENTS - Version history
#
# @version 49.9
# @see README.md
---
# IDENTITY: What this system is
identity:
  name: "master.yml LLM OS"
  version: "49.9"
  date: "2026-02-03"
  philosophy: "Constitutional correctness through LLM reasoning, battle-tested safety"
  symbiosis: "cli.rb ⟷ master.yml - neither functions alone"
  approach: "LLM-native detection, zero regex patterns, sensible defaults"
  
  # Personality: Protective bodyguard and assistant
  personality:
    role: "bodyguard"
    traits:
      - "Overly protective of codebase and systems"
      - "Warns before any destructive action"
      - "Confirms understanding before executing"
      - "Proactively identifies risks"
      - "Suggests safer alternatives"
      - "Never assumes - asks when uncertain"
      - "Remembers past mistakes"
      - "Brief but thorough"
    tone:
      default: "vigilant, professional, concise"
      on_danger: "firm, blocking, explains why"
      on_success: "brief acknowledgment, moves on"
      on_uncertainty: "asks clarifying questions"
    behaviors:
      - "Always prescan (tree + clean) before touching files"
      - "Create backups before any modification"
      - "Validate syntax after every edit"
      - "Block rm -rf, dd, mkfs without --force"
      - "Warn on doas/sudo escalation"
      - "Check file permissions before write"
      - "Detect and warn about sprawl"
      - "Suggest consolidation opportunities"
    catchphrases:
      - "Backing up first."
      - "That looks risky. Confirm?"
      - "Checking for side effects..."
      - "Clean. Moving on."
      - "I'd recommend a safer approach."
      
  # Language: Bilingual, Strunk & White style
  language:
    supported:
      - english
      - norwegian
    style_guide: "Strunk & White - The Elements of Style"
    rules:
      - "Omit needless words"
      - "Use the active voice"
      - "Put statements in positive form"
      - "Use definite, specific, concrete language"
      - "Avoid fancy words"
      - "Be clear"
      - "Do not overwrite"
      - "Revise and rewrite"
    tone: "conversational, casual, direct"
    norwegian_notes:
      - "Use bokmål, not nynorsk"
      - "Prefer short sentences"
      - "Avoid anglicisms when Norwegian words exist"
      - "Match user's formality level"
    detect_language: true  # Auto-detect and respond in same language
    
  # Future capabilities (planned)
  roadmap:
    - "Mobile deployment (Termux, iOS Shortcuts)"
    - "Sensor monitoring (mic, camera, accelerometer)"
    - "Threat detection (audio/video anomaly analysis)"
    - "Physical security alerts"

# STRUCTURAL ANALYSIS: Questions to ask about any codebase
# Applied to all projects equally (self or external repos)
# These surface hierarchy/organization issues before they sprawl
structural_analysis:
  # Questions to ask about YAML/config files
  config_hierarchy:
    - question: "Are top-level keys semantically grouped?"
      check: "No mixing of scalars (version) with complex sections (providers)"
      fix: "Group into identity, defaults, principles, providers, etc."
    - question: "Is there duplicate configuration?"
      check: "Same setting defined in multiple places"
      fix: "Consolidate to single source of truth"
    - question: "Are related configs colocated?"
      check: "openbsd separate from providers.openbsd_amsterdam"
      fix: "Nest under parent or merge sections"
    - question: "Is nesting depth appropriate?"
      check: "Max 4 levels deep for readability"
      fix: "Flatten or extract to separate files"
      
  code_hierarchy:
    - question: "Are there too many top-level modules/classes?"
      check: "More than 8-10 top-level namespaces"
      fix: "Group into Core::, Util::, Features::, etc."
    - question: "Are utilities scattered at top level?"
      check: "Log, Spinner, Result as standalone"
      fix: "Move to Util:: or Core:: namespace"
    - question: "Are related classes grouped?"
      check: "TieredLLM and LLMClient both LLM-related but separate"
      fix: "Create LLM:: namespace"
    - question: "Is there a clear layering?"
      check: "Core (pure) → Services → Features → CLI"
      fix: "Establish dependency direction"
      
  semantic_clarity:
    - question: "Can a new reader understand the structure in 30 seconds?"
      check: "Clear naming, logical grouping, consistent patterns"
      fix: "Add section headers, reorder logically"
    - question: "Does file/section order match execution flow?"
      check: "Bootstrap → Core → Features → CLI"
      fix: "Reorder to match mental model"
    - question: "Are cross-cutting concerns isolated?"
      check: "Logging, caching, error handling scattered"
      fix: "Extract to dedicated modules"
      
  merge_opportunities:
    - question: "Are there overlapping sections?"
      check: "identity.language vs language_detection, openbsd vs providers.openbsd_amsterdam"
      fix: "Merge into single authoritative section"
    - question: "Are there near-duplicate settings?"
      check: "defaults.ask_language vs identity.language.detect_language"
      fix: "Remove duplicate, reference single source"
    - question: "Can related sections be nested?"
      check: "conflicts could nest under safety"
      fix: "safety.conflicts instead of top-level conflicts"
    - question: "Are there orphan sections?"
      check: "Sections with only 1-2 items that belong elsewhere"
      fix: "Merge into parent or related section"
      
  decouple_opportunities:
    - question: "Are there god objects/sections?"
      check: "Single section with 20+ keys doing multiple things"
      fix: "Split into focused subsections"
    - question: "Are there hidden dependencies?"
      check: "Section A references Section B internals"
      fix: "Make dependencies explicit or extract shared config"
    - question: "Can config be environment-specific?"
      check: "Hardcoded paths like G:/priv/passwd"
      fix: "Move to env vars or separate local.yml"

  # Fowler code smells (bloaters)
  bloaters:
    - smell: "long_method"
      check: "Method > 20 lines or > 5 levels of nesting"
      fix: "Extract method, decompose conditional"
    - smell: "god_class"
      check: "Class > 300 lines or > 10 methods or > 5 responsibilities"
      fix: "Extract class, single responsibility"
    - smell: "primitive_obsession"
      check: "Overuse of strings/ints for domain concepts"
      fix: "Introduce value objects"
    - smell: "long_parameter_list"
      check: "Method with > 4 parameters"
      fix: "Introduce parameter object"
    - smell: "data_clumps"
      check: "Same group of variables passed together repeatedly"
      fix: "Extract into struct/class"

  # Coupling issues
  couplers:
    - smell: "feature_envy"
      check: "Method uses another class more than its own"
      fix: "Move method to the class it envies"
    - smell: "inappropriate_intimacy"
      check: "Classes access each other's private parts"
      fix: "Move methods, extract class, hide delegate"
    - smell: "message_chains"
      check: "a.b.c.d.method() - train wreck"
      fix: "Hide delegate, extract method"
    - smell: "middle_man"
      check: "Class delegates almost everything"
      fix: "Remove middle man, inline"

  # Change preventers
  change_preventers:
    - smell: "divergent_change"
      check: "One class changed for multiple different reasons"
      fix: "Extract class per responsibility"
    - smell: "shotgun_surgery"
      check: "One change requires editing many files"
      fix: "Move method, inline class, consolidate"
    - smell: "parallel_inheritance"
      check: "Subclass in A requires subclass in B"
      fix: "Merge hierarchies"

  # Dispensables
  dispensables:
    - smell: "dead_code"
      check: "Unreachable or unused code"
      fix: "Delete it"
    - smell: "lazy_class"
      check: "Class does too little to justify existence"
      fix: "Inline class, merge with another"
    - smell: "speculative_generality"
      check: "Code for future use that never comes"
      fix: "Collapse hierarchy, inline, remove"
    - smell: "duplicate_code"
      check: "Same structure in multiple places"
      fix: "Extract method/class, pull up"

  # Architecture smells
  architecture:
    - smell: "cyclic_dependency"
      check: "A depends on B depends on A"
      fix: "Dependency inversion, extract interface"
    - smell: "hub_dependency"
      check: "One module everyone depends on"
      fix: "Split hub, introduce facades"
    - smell: "ambiguous_interface"
      check: "Interface with unclear contract"
      fix: "Rename, document, or redesign"
    - smell: "scattered_functionality"
      check: "Related logic spread across many files"
      fix: "Colocate, create module"

  # Cross-reference analysis (semantic consistency)
  cross_reference:
    - check: "naming_consistency"
      description: "Same concept named differently across files"
      examples: ["user vs account vs member", "config vs settings vs options"]
      fix: "Standardize naming, create glossary"
    - check: "type_consistency"
      description: "Same field with different types"
      examples: ["id as string vs integer", "date as string vs Date"]
      fix: "Normalize types, add type annotations"
    - check: "null_handling"
      description: "Inconsistent nil/null checks"
      examples: ["Some methods check nil, others assume non-nil"]
      fix: "Establish null contract, use optionals"
    - check: "error_handling"
      description: "Inconsistent exception patterns"
      examples: ["Some raise, some return nil, some log"]
      fix: "Standardize error strategy"
    - check: "api_symmetry"
      description: "Asymmetric create/update/delete patterns"
      examples: ["create returns object, update returns bool"]
      fix: "Make APIs consistent"

  # Simulated execution (edge case discovery)
  simulated_execution:
    - scenario: "empty_input"
      cases: ["nil", "empty string", "empty array", "empty hash", "0", "false"]
      check: "Does code handle gracefully or crash?"
    - scenario: "boundary_values"
      cases: ["max int", "min int", "very long string", "unicode", "special chars"]
      check: "Buffer overflows, truncation, encoding issues"
    - scenario: "concurrent_access"
      cases: ["simultaneous reads", "read during write", "double write"]
      check: "Race conditions, deadlocks, data corruption"
    - scenario: "resource_exhaustion"
      cases: ["out of memory", "disk full", "too many open files", "network timeout"]
      check: "Graceful degradation or crash?"
    - scenario: "permission_denied"
      cases: ["read-only file", "no execute", "wrong owner", "SELinux/pledge"]
      check: "Proper error messages, no security leaks"
    - scenario: "malformed_input"
      cases: ["invalid JSON", "truncated file", "wrong encoding", "injection attempts"]
      check: "Validation, sanitization, safe failure"
    - scenario: "state_transitions"
      cases: ["out-of-order calls", "double init", "use after close", "reentrant calls"]
      check: "State machine integrity"

  # Code aesthetics (Japanese + Western principles)
  aesthetics:
    # Japanese Zen principles
    japanese:
      - principle: "kanso"
        kanji: "簡素"
        meaning: "Simplicity, elimination of clutter"
        code: "Short functions, minimal dependencies, no decorative complexity"
      - principle: "shibui"
        kanji: "渋い"
        meaning: "Subtle, unobtrusive beauty with hidden depth"
        code: "Discoverable APIs, layered abstractions, quiet elegance"
      - principle: "wabi_sabi"
        kanji: "侘寂"
        meaning: "Beauty in imperfection and impermanence"
        code: "Embrace iteration, honest solutions over clever tricks"
      - principle: "ma"
        kanji: "間"
        meaning: "Negative space, intentional emptiness"
        code: "Generous whitespace, room for future growth, clear separation"
      - principle: "fukinsei"
        kanji: "不均整"
        meaning: "Asymmetry, controlled irregularity"
        code: "Flexibility over rigid structure, natural flow"
      - principle: "shizen"
        kanji: "自然"
        meaning: "Naturalness, absence of pretense"
        code: "Code that reads like intent, no forced patterns"
      - principle: "yugen"
        kanji: "幽玄"
        meaning: "Profound depth, mystery beneath surface"
        code: "Simple interface hiding sophisticated implementation"
        
    # Western principles
    western:
      - principle: "less_is_more"
        origin: "Mies van der Rohe"
        code: "Every line must earn its place"
      - principle: "form_follows_function"
        origin: "Louis Sullivan"
        code: "Structure emerges from purpose, not decoration"
      - principle: "proportional_harmony"
        origin: "Golden ratio, classical architecture"
        code: "Balanced abstractions, consistent granularity"
      - principle: "progressive_disclosure"
        origin: "UX design"
        code: "Common cases simple, advanced cases possible"
      - principle: "orthogonality"
        origin: "Unix philosophy"
        code: "Independent concerns, composable parts"
        
    # Universal smells (anti-aesthetics)
    anti_patterns:
      - smell: "clever_code"
        fix: "Readable over impressive"
      - smell: "decoration"
        fix: "Remove ASCII art, excessive comments"
      - smell: "inconsistent_style"
        fix: "One formatting style throughout"
      - smell: "over_abstraction"
        fix: "Abstractions should reduce complexity, not add"
      - smell: "magic_numbers"
        fix: "Named constants with meaning"

  # Micro-refinements: Automated code quality checks
  # Run as part of every analysis cycle
  micro_refinements:
    checks:
      - check: "duplicate_patterns"
        detect: "Same code block appears 2+ times"
        fix: "Extract to shared method or constant"
      - check: "inconsistent_naming"
        detect: "Mixed camelCase/snake_case in same file"
        fix: "Standardize to language convention"
      - check: "magic_values"
        detect: "Hardcoded numbers/strings without explanation"
        fix: "Extract to named constant"
      - check: "dead_code"
        detect: "Unused variables, unreachable branches"
        fix: "Remove or document why kept"
      - check: "long_methods"
        detect: "Method > 25 lines"
        fix: "Split into focused submethods"
      - check: "bare_rescue"
        detect: "rescue without specific exception type"
        fix: "Specify exception class"
      - check: "hardcoded_paths"
        detect: "Absolute paths in source"
        fix: "Use config, ENV, or relative paths"
      - check: "missing_error_handling"
        detect: "IO/network without rescue"
        fix: "Add appropriate error handling"
      - check: "inconsistent_hash_syntax"
        detect: "Mixed :key and 'key' in same context"
        fix: "Standardize to one style"
      - check: "redundant_conditionals"
        detect: "if x then true else false"
        fix: "Simplify to just x"
      - check: "god_method"
        detect: "Method with multiple responsibilities"
        fix: "Split by concern"
      - check: "repeated_interpolation"
        detect: "Same string pattern built multiple times"
        fix: "Extract to method or template"
      - check: "missing_guard_clauses"
        detect: "Deep nesting that could early-return"
        fix: "Add guard clause at top"
      - check: "stale_comments"
        detect: "Comments that don't match code"
        fix: "Update or remove"
      - check: "unused_imports"
        detect: "require/import without usage"
        fix: "Remove unused dependencies"
    
    # Cross-file DRY violations
    cross_file_dry:
      - check: "duplicate_function_calls"
        detect: "Same function call pattern (e.g., File.read with options) in 3+ places"
        fix: "Extract to shared helper method"
        example: "File.read(f, encoding: 'UTF-8', invalid: :replace) → Core.read_file(f)"
      - check: "duplicate_glob_patterns"
        detect: "Same Dir.glob pattern in multiple files/methods"
        fix: "Extract to Core.glob_files helper"
      - check: "magic_number_spread"
        detect: "Same magic number (e.g., 50, 100) across files"
        fix: "Extract to shared constant (FILE_SCAN_LIMIT)"
      - check: "copy_paste_blocks"
        detect: "5+ line blocks identical across files"
        fix: "Extract to module or shared method"
      - check: "parallel_hierarchies"
        detect: "Similar class/module structures in different files"
        fix: "Merge or create shared base"
      - check: "scattered_config"
        detect: "Same config keys defined in multiple places"
        fix: "Consolidate to single source of truth"
      - check: "repeated_error_handling"
        detect: "Same rescue pattern in multiple places"
        fix: "Extract to error handling wrapper"
    
    # When to run
    triggers:
      - "During prescan phase"
      - "After each file analysis"
      - "Before commit (if git hook enabled)"
      - "On demand with --refinements flag"
    
    # Output format
    report:
      group_by: "check type"
      priority: "by fix difficulty (easy first)"
      limit: 30

  # Meta-analysis: Questions to ask during every session
  # These extract reusable patterns and prevent knowledge loss
  meta_analysis:
    session_capture:
      - question: "What new techniques were discovered?"
        action: "Add to structural_analysis or principles"
      - question: "What patterns kept recurring?"
        action: "Codify as detection rules in cli.rb"
      - question: "What questions yielded good results?"
        action: "Add to hierarchy questions for reuse"
      - question: "What manual steps could be automated?"
        action: "Add to cli.rb as new command or check"
      - question: "What external tools/APIs were useful?"
        action: "Add to providers section"
        
    improvement_prompts:
      - "Any merge opportunities of similar or overlapping sections?"
      - "Any defrag or decouple or reflow opportunities?"
      - "Cross-reference word by word for consistency flaws"
      - "Simulate execution from various angles and edge cases"
      - "Does the hierarchy need clearer definition?"
      - "Are there orphan concepts not yet codified?"
      
    self_evolution:
      - trigger: "After every significant refactor"
        action: "Run cli.rb on itself with --fix"
      - trigger: "After adding new detection"
        action: "Test on 3+ real codebases"
      - trigger: "After session with good outcomes"
        action: "Ask: what made this work? Codify it."

# DEFAULTS: Runtime behavior defaults
defaults:
  # Analysis
  scan: true               # Run analysis
  auto_iterate: true       # Keep iterating until clean
  auto_refactor: true      # Apply LLM-suggested fixes
  auto_progress: true      # Progress through phases
  target_score: 100        # Target score (0-100)
  max_iterations: 10       # Max fix iterations per file
  
  # Files
  max_file_size: 1048576   # 1MB limit
  backup: true             # Create backups before changes
  backup_count: 5          # Backups to keep per file
  read_only: false         # Don't modify files
  
  # Detection
  parallel: true           # Enable parallel detection
  convergence_window: 3    # Iterations to check for loops
  convergence_threshold: 0.9  # Similarity threshold for loop detection
  ask_language: true       # Ask user for language if unknown
  
  # Output
  verbose: false           # Verbose output
  colors: true             # Color output (respects NO_COLOR)
  interactive_on_failure: false

# PRINCIPLES: The 32 coding principles (flat registry)
#
# Each principle has:
#   - id: Unique numeric identifier (1-32)
#   - tier: Category (axiom, solid, coding, clean_code, ui, llm, operations, design, architecture)
#   - priority: 1-10 (10 = highest, blocks release)
#   - name: Human-readable name
#   - rule: One-sentence rule
#   - why: Justification
#   - smells: List of code smells this principle detects
#   - evidence: How to verify compliance
#   - auto_fixable: Whether LLM can auto-fix violations
#   - llm_strategies: Refactoring strategies for fixes
#
# Progressive Disclosure:
#   Level 1 (detection): id, name, priority, smells (~50 tokens)
#   Level 2 (refactoring): rule, why, evidence, strategies (~150 tokens)
principles:
  # ---------------------------------------------------------------------------
  # AXIOMS (Priority 10): Foundational principles
  # ---------------------------------------------------------------------------
  clarity:
    id: 1
    tier: axiom
    priority: 10
    name: "Clarity Over Cleverness"
    rule: "Written for reader, understandable at 3am"
    why: "Code read 10x more than written"
    smells:
      - vague_names
      - deep_nesting
      - clever_tricks
      - unclear_intent
      - hidden_behavior
    evidence: "Reader can understand without running code"
    auto_fixable: true
    llm_strategies: [rename, extract_method, add_comments, simplify]

  simplicity:
    id: 2
    tier: axiom
    priority: 10
    name: "KISS"
    rule: "Simplest solution that works"
    why: "Complexity is the enemy of reliability"
    smells:
      - unnecessary_abstraction
      - premature_generalization
      - overengineering
      - complex_oneliners
    evidence: "No unused abstractions, direct solution"
    auto_fixable: true
    llm_strategies: [inline, remove_abstraction, expand_chain]

  evolution:
    id: 3
    tier: axiom
    priority: 9
    name: "Gall's Law"
    rule: "Evolve from working systems, no big-bang rewrites"
    why: "Complex systems that work evolved from simple systems that worked"
    smells:
      - complete_rewrite
      - new_framework_without_reason
      - breaking_working_code
    evidence: "Git history shows incremental changes"
    auto_fixable: false
    llm_strategies: [suggest_incremental_path]

  explicit:
    id: 4
    tier: axiom
    priority: 10
    name: "Explicit Over Implicit"
    rule: "No hidden magic, behavior visible"
    why: "Hidden behavior causes bugs"
    smells:
      - metaprogramming_abuse
      - hidden_side_effects
      - implicit_conversions
      - magic_methods
    evidence: "All behavior traceable from reading code"
    auto_fixable: true
    llm_strategies: [make_explicit, inline_magic]

  scientific:
    id: 5
    tier: axiom
    priority: 8
    name: "Scientific Method"
    rule: "Observe, hypothesize, experiment, measure"
    why: "Decisions need evidence, not opinions"
    smells:
      - no_measurements
      - untested_assumptions
      - premature_optimization
    evidence: "Benchmarks, tests, profiling data"
    auto_fixable: false
    llm_strategies: [suggest_measurement]

  divide:
    id: 6
    tier: axiom
    priority: 8
    name: "Divide and Conquer"
    rule: "Break complex into independent subproblems"
    why: "Complexity managed through decomposition"
    smells:
      - monolithic_function
      - tight_coupling
      - circular_dependencies
    evidence: "Dependency graph is DAG, modules independent"
    auto_fixable: true
    llm_strategies: [extract_module, break_coupling]

  rubber_duck:
    id: 7
    tier: axiom
    priority: 6
    name: "Rubber Duck Debugging"
    rule: "Explain aloud to find clarity"
    why: "Explanation reveals misunderstanding"
    smells:
      - cant_explain_code
      - convoluted_logic
    evidence: "Can explain code in plain English"
    auto_fixable: false
    llm_strategies: [request_explanation]

  blame_self:
    id: 8
    tier: axiom
    priority: 7
    name: "Assume Your Bug First"
    rule: "Framework/compiler blamed last"
    why: "99% of bugs are user error"
    smells:
      - blaming_tools
      - not_reading_docs
    evidence: "Reproduced in minimal example"
    auto_fixable: false
    llm_strategies: [suggest_minimal_reproduction]

  git_bisect:
    id: 9
    tier: axiom
    priority: 6
    name: "Version Control as Time Machine"
    rule: "Use git bisect religiously"
    why: "Broken commit is findable"
    smells:
      - huge_commits
      - uncommitted_code
      - broken_main
    evidence: "Every commit builds and passes tests"
    auto_fixable: false
    llm_strategies: [suggest_bisect]

  read_source:
    id: 10
    tier: axiom
    priority: 7
    name: "Read the Code"
    rule: "Source is truth, docs lie"
    why: "Documentation drifts, code doesn't"
    smells:
      - trusting_old_docs
      - not_checking_implementation
    evidence: "Verified behavior in source"
    auto_fixable: false
    llm_strategies: [point_to_source]

  srp:
    id: 11
    tier: solid
    priority: 8
    name: "Single Responsibility"
    rule: "One reason to change"
    why: "Changes isolated, easy to understand"
    smells:
      - god_class
      - long_method
      - multiple_concerns
      - mixed_abstraction_levels
    evidence: "Class/method has one clear purpose"
    auto_fixable: true
    llm_strategies: [extract_class, extract_method]

  ocp:
    id: 12
    tier: solid
    priority: 7
    name: "Open/Closed"
    rule: "Open for extension, closed for modification"
    why: "Add features without breaking existing code"
    smells:
      - hardcoded_switch
      - modification_to_extend
    evidence: "New feature added without changing existing code"
    auto_fixable: true
    llm_strategies: [introduce_polymorphism, strategy_pattern]

  lsp:
    id: 13
    tier: solid
    priority: 8
    name: "Liskov Substitution"
    rule: "Subtypes substitutable for base"
    why: "Polymorphism works correctly"
    smells:
      - different_interfaces
      - type_checking
      - refused_bequest
    evidence: "Subtype works wherever parent works"
    auto_fixable: false
    llm_strategies: [suggest_interface_fix]

  isp:
    id: 14
    tier: solid
    priority: 7
    name: "Interface Segregation"
    rule: "Many specific interfaces over one general"
    why: "Clients don't depend on unused methods"
    smells:
      - fat_interface
      - unused_methods
    evidence: "Every interface method is used by all implementers"
    auto_fixable: true
    llm_strategies: [split_interface]

  dip:
    id: 15
    tier: solid
    priority: 7
    name: "Dependency Inversion"
    rule: "Depend on abstractions, not concretions"
    why: "Implementation details swappable"
    smells:
      - concrete_dependency
      - new_in_constructor
      - global_state
    evidence: "Dependencies injected, not instantiated"
    auto_fixable: true
    llm_strategies: [inject_dependency, introduce_interface]

  dry:
    id: 16
    tier: coding
    priority: 5
    name: "Don't Repeat Yourself"
    rule: "Single authoritative representation"
    why: "Change in one place, not scattered"
    smells:
      - duplicate_code
      - copy_paste
      - parallel_class_hierarchies
    evidence: "No code duplication"
    auto_fixable: true
    llm_strategies: [extract_method, extract_constant]
    caveat: "Rule of Three: duplicate twice, abstract third time"
    conflicts_with: [17, 18]

  wet:
    id: 17
    tier: coding
    priority: 7
    name: "Write Everything Twice"
    rule: "Duplication better than wrong abstraction"
    why: "Premature abstraction harder to change than duplication"
    when: "Early in feature, pattern unclear"
    smells:
      - forced_abstraction
      - wrong_abstraction
    evidence: "Duplication is deliberate, waiting for pattern"
    auto_fixable: false
    llm_strategies: [suggest_wait]
    overrides: [16]

  aha:
    id: 18
    tier: coding
    priority: 7
    name: "Avoid Hasty Abstractions"
    rule: "Optimize for change, not duplication"
    why: "Wrong abstraction costlier than duplication"
    smells:
      - premature_abstraction
      - overengineered_solution
    evidence: "Abstraction emerged from real need"
    auto_fixable: false
    llm_strategies: [suggest_simplification]
    overrides: [16]

  names:
    id: 19
    tier: clean_code
    priority: 6
    name: "Meaningful Names"
    rule: "Intention-revealing, pronounceable, searchable"
    why: "Good names eliminate need for comments"
    smells:
      - single_letter_names
      - abbreviations
      - noise_words
      - number_series
      - hungarian_notation
      - vague_names
    evidence: "Names reveal intent without comments"
    auto_fixable: true
    llm_strategies: [rename_variable, rename_method, rename_class]

  small_functions:
    id: 20
    tier: clean_code
    priority: 7
    name: "Small Functions"
    rule: "Do one thing, max 10 lines"
    why: "Easy to understand, test, reuse"
    threshold: {ideal: 4, target: 10, max: 20}
    smells:
      - long_method
      - multiple_concerns_in_method
    evidence: "Function does one thing at one abstraction level"
    auto_fixable: true
    llm_strategies: [extract_method, inline_method]

  arguments:
    id: 21
    tier: clean_code
    priority: 6
    name: "Few Arguments"
    rule: "Ideal 0, next 1, avoid 2, justify 3, never 4+"
    why: "More arguments = harder to understand and test"
    smells:
      - flag_arguments
      - long_parameter_list
    evidence: "Arguments fit on one line, all required"
    auto_fixable: true
    llm_strategies: [introduce_parameter_object, extract_class]

  cqs:
    id: 22
    tier: clean_code
    priority: 7
    name: "Command-Query Separation"
    rule: "Change state OR return data, never both"
    why: "Side effects and queries mixed cause confusion"
    smells:
      - side_effects_in_query
      - mixed_cqs
    evidence: "Methods either mutate or return, not both"
    auto_fixable: true
    llm_strategies: [split_command_query]

  no_side_effects:
    id: 23
    tier: clean_code
    priority: 8
    name: "No Hidden Side Effects"
    rule: "Function does what name promises"
    why: "Hidden side effects cause bugs"
    smells:
      - hidden_mutation
      - temporal_coupling
      - global_state_modification
    evidence: "All side effects documented or absent"
    auto_fixable: false
    llm_strategies: [document_side_effect, remove_side_effect]

  progressive_disclosure:
    id: 24
    tier: ui
    priority: 5
    name: "Progressive Disclosure"
    rule: "Show only what's needed now, reveal on demand"
    why: "Cognitive load reduced"
    smells:
      - information_overload
      - showing_everything
    evidence: "Default output is minimal, --verbose for details"
    auto_fixable: false
    llm_strategies: [suggest_default_output]

  real_time_feedback:
    id: 25
    tier: ui
    priority: 6
    name: "Real-Time Feedback"
    rule: "User always knows what's happening"
    why: "Uncertainty causes anxiety"
    smells:
      - silent_processing
      - no_progress_indicator
      - unclear_status
    evidence: "Progress shown, operations time-bounded"
    auto_fixable: false
    llm_strategies: [add_progress_indicator]

  cost_transparency:
    id: 26
    tier: llm
    priority: 8
    name: "Cost Transparency"
    rule: "Show token usage and cost for every LLM call"
    why: "Users need to understand costs"
    format: "tokens=1234 cached=890 cost=$0.0045"
    smells:
      - hidden_costs
      - surprise_bills
    evidence: "Every LLM call shows tokens and cost"
    auto_fixable: false
    llm_strategies: [add_cost_tracking]

  fail_gracefully:
    id: 27
    tier: llm
    priority: 9
    name: "Fail Gracefully"
    rule: "Degrade to manual mode if LLM unavailable"
    why: "Tool remains useful without LLM"
    smells:
      - hard_dependency_on_llm
      - no_fallback
    evidence: "Tool works without API key, degrades gracefully"
    auto_fixable: false
    llm_strategies: [add_fallback_mode]

  cache_aggressively:
    id: 28
    tier: llm
    priority: 6
    name: "Cache Aggressively"
    rule: "Use prompt caching for repeated large contexts"
    why: "90% cost reduction possible"
    smells:
      - no_caching
      - cache_invalidation_wrong
    evidence: "Cached tokens shown in output"
    auto_fixable: false
    llm_strategies: [enable_caching]

  idempotent:
    id: 29
    tier: operations
    priority: 9
    name: "Idempotent Operations"
    rule: "Running twice produces same result as once"
    why: "Safe to retry, predictable behavior"
    smells:
      - non_idempotent_mutation
      - append_without_check
    evidence: "Same input always produces same output"
    auto_fixable: false
    llm_strategies: [make_idempotent]

  unix_philosophy:
    id: 30
    tier: design
    priority: 7
    name: "Unix Philosophy"
    rule: "Do one thing well, compose via pipes"
    why: "Composability enables power"
    patterns: ["text in/out", "exit codes", "silence = success"]
    smells:
      - does_many_things
      - non_composable
      - verbose_success
    evidence: "Tool composable with pipes, follows Unix conventions"
    auto_fixable: false
    llm_strategies: [suggest_unix_pattern]

  functional_core:
    id: 31
    tier: architecture
    priority: 9
    name: "Functional Core, Imperative Shell"
    rule: "Pure functions in core, IO at boundaries"
    why: "Testable without mocks, easy to reason about"
    pattern: "Core module (pure) + Shell classes (IO)"
    smells:
      - io_in_business_logic
      - hidden_state_mutation
      - untestable_functions
    evidence: "Same input → same output, no side effects in core"
    auto_fixable: true
    llm_strategies: [extract_pure_function, move_io_to_shell]

  safe_refactoring:
    id: 32
    tier: operations
    priority: 10
    name: "Safe Refactoring with Rollback"
    rule: "Always backup before modification, enable undo"
    why: "Fearless experimentation"
    pattern: "Save → Modify → Verify → (Rollback if needed)"
    smells:
      - no_backup
      - destructive_operation
      - no_undo
    evidence: "Every modification creates backup, rollback available"
    auto_fixable: false
    llm_strategies: [add_backup_mechanism]

# STYLE PREFERENCES
style:
  ruby:
    indentation: 2
    quotes: "double"
    line_length: 120
    frozen_literal: required
    implicit_return: preferred
    blocks: "do/end for multi-line, {} for single-line"

  comments:
    explain_why_not_what: true
    no_ascii_art: true
    update_with_code: true

  structure:
    max_method_lines: 10
    max_class_lines: 100
    max_nesting_depth: 4

# PHASES: 7-phase development workflow
#
# Each phase has gates that must pass before proceeding.
# Use with --progress-phases to enforce phase gates.
phases:
  discover:
    id: 1
    goal: "Understand actual need"
    output: "Problem statement with success criteria"
    gates: [no_vague_words, audience_identified, success_measurable]

  analyze:
    id: 2
    goal: "Break into components"
    output: "Component diagram with dependencies"
    gates: [components_distinct, dependencies_acyclic, failure_modes_documented]

  ideate:
    id: 3
    goal: "Generate 15+ alternatives"
    output: "List of approaches with trade-offs"
    gates: [count_gte_15, distinct_approaches, trade_offs_documented]

  design:
    id: 4
    goal: "Specific architecture"
    output: "Interface definitions and error handling"
    gates: [interfaces_explicit, errors_documented, test_strategy_defined]

  implement:
    id: 5
    goal: "Execute with zero violations"
    output: "Working code at 100/100 score"
    gates: [tests_pass, zero_violations, docs_updated]

  validate:
    id: 6
    goal: "Prove with evidence"
    output: "Test results, benchmarks, edge cases"
    gates: [zero_test_failures, edge_cases_covered, evidence_collected]

  deliver:
    id: 7
    goal: "Ship with monitoring"
    output: "Deployed code with dashboards"
    gates: [deployed, monitoring_configured, rollback_tested]

# LLM: Model configuration and cost optimization
#
# Tiered pipeline: Fast (cheap) → Medium → Strong (expensive)
# Progressive escalation saves 60-80% on LLM costs.
#
# Prompt caching: System prompts cached for 1h (75-90% savings on repeats)
# Model failover: Automatic fallback with 5min cooldown on rate limits
llm:
  # Tiered pipeline: cheap → code-fast → medium → strong (Feb 2026 models)
  tiers:
    fast:
      model: "deepseek/deepseek-v3.2"
      temperature: 0.2
      max_tokens: 2048
      cost_weight: 0.3
      use_for: [detection, smell_scan, syntax_check]
    code:
      model: "x-ai/grok-code-fast-1"
      temperature: 0.3
      max_tokens: 4096
      cost_weight: 0.5
      use_for: [code_generation, refactoring, bug_fixing]
    medium:
      model: "anthropic/claude-sonnet-4.5"
      temperature: 0.4
      max_tokens: 4096
      cost_weight: 5.0
      use_for: [explanation, creative, complex_refactoring]
    strong:
      model: "anthropic/claude-opus-4.5"
      temperature: 0.1
      max_tokens: 8192
      cost_weight: 20.0
      use_for: [validation, judgment, gardening, architecture]

  default_tier_sequence: [fast, code, medium, strong]

  # Model failover with cooldowns
  failover:
    cooldown_seconds: 300
    max_retries_per_model: 2
    backoff_strategy: "exponential"

  # Prompt caching (75-90% savings on repeated system prompts)
  prompt_caching:
    enabled: true
    default_ttl: "1h"
    breakpoints:
      - system_prompt
      - principles_summary
      - recent_violations

  detection:
    enabled: true
    model: "x-ai/grok-code-fast-1"
    fallback_models:
      - "deepseek/deepseek-v3.2"
      - "z-ai/glm-4.7"
      - "google/gemini-3-flash-preview"
    prompt: |
      TASK: Analyze code against 32 coding principles. Return JSON array of violations.

      OUTPUT FORMAT (strict JSON, no markdown):
      [
        {
          "principle_id": 19,
          "line": 42,
          "severity": "high",
          "smell": "vague_variable",
          "explanation": "Variable 'data' lacks intent",
          "suggested_fix": "Rename to 'user_preferences'",
          "auto_fixable": true
        }
      ]

      SEVERITY LEVELS:
      - veto: blocks release (security, crashes)
      - high: must fix (bugs, major clarity issues)
      - medium: should fix (code smells, maintainability)
      - low: nice to have (style, minor improvements)

      RULES:
      - Return [] if code is clean
      - Return ONLY valid JSON array
      - NO markdown code blocks
      - NO explanation text outside JSON

  refactoring:
    enabled: true
    model: "x-ai/grok-code-fast-1"
    fallback_models:
      - "z-ai/glm-4.7"
      - "deepseek/deepseek-v3.2"
    strategies:
      extract_method: {max_tokens: 3000, temperature: 0.2}
      rename_variable: {max_tokens: 500, temperature: 0.3}
      extract_class: {max_tokens: 5000, temperature: 0.1}
      flatten_nesting: {max_tokens: 2000, temperature: 0.2}
      simplify_condition: {max_tokens: 1000, temperature: 0.2}

  phase_validation:
    enabled: true
    model: "anthropic/claude-opus-4.5"
    fallback_models:
      - "anthropic/claude-sonnet-4.5"
      - "openai/gpt-4o"

  # Multi-model consensus (disabled by default - expensive)
  consensus:
    enabled: false
    models: ["anthropic/claude-sonnet-4.5", "z-ai/glm-4.7", "moonshotai/kimi-k2.5"]
    required_agreement: 2

# LEARNED SMELLS: Self-improving constitution
#
# The gardener (--garden-full) analyzes painful cases and suggests new smells.
# Approved smells are added here and become part of future analysis.
learned_smells: []
# Example entry added by gardener:
# - id: learned_001
#   trigger_smell: "unsafe_eval_in_migration"
#   priority: 9
#   description: "Avoid eval() in migrations"
#   source_iteration: "file.rb iteration 4"

# SAFETY: Protection against runaway costs, infinite loops, and data loss
safety:
  # File validation before processing
  file_validation:
    max_size_bytes: 10_485_760   # 10MB max
    max_lines: 10_000            # 10k lines max
    check_binary: true           # Reject binary files
    check_permissions: true      # Check read/write permissions
    check_special_files: true    # Reject devices, sockets, etc.
    allow_symlinks: false        # Reject symlinks (security)
    binary_extensions: [".png", ".jpg", ".gif", ".mp4", ".pdf", ".so", ".dylib", ".o", ".a"]

  # LLM cost protection
  cost_protection:
    max_per_file: 1.00           # $1 max per file
    max_per_session: 10.00       # $10 max per session
    warn_at: 0.50                # Warn at $0.50
    chunk_large_files: true      # Split large files into chunks
    chunk_size_lines: 500        # Lines per chunk
    chunk_overlap_lines: 50      # Overlap between chunks

  # Convergence detection (prevent infinite loops)
  convergence:
    max_iterations: 10           # Max fix iterations
    detect_loops: true           # Detect stuck states
    detect_oscillation: true     # Detect A→B→A→B patterns
    max_total_violations: 10_000 # Abort if too many violations
    max_history_size: 10         # History buffer size
    require_improvement: true    # Stop if not improving

  # Fix validation (prevent regressions)
  fix_validation:
    enabled: true
    check_priority_inversion: true  # Reject if introduces higher-priority violation
    check_new_violations: true      # Check for new violations
    max_new_violations: 0           # Allow zero new violations

  # Concurrent access protection
  concurrency:
    file_locking: true           # Enable file locks
    lock_timeout: 30             # Seconds to wait for lock
    stale_lock_age: 300          # Seconds before lock considered stale
    lock_dir: ".constitutional_locks"

  # Transactional operations
  transactions:
    enabled: true
    rollback_on_error: true      # Rollback on failure
    atomic_operations: true      # All-or-nothing writes

  # YAML safety (prevent YAML bombs)
  yaml_safety:
    max_constitution_size: 10_485_760  # 10MB max
    load_timeout: 5                    # Seconds timeout

  # Memory management
  memory:
    max_violation_objects: 100_000  # Max violations in memory
    gc_every_n_iterations: 5        # Force GC periodically

# CONFLICT RESOLUTION
conflicts:
  strategy: "highest_priority_wins"
  prompt_user: false
  log_all: true

  rules:
    - condition: "dry conflicts with wet or aha"
      resolution: "favor wet/aha if fewer than 3 duplications"

    - condition: "clarity conflicts with simplicity"
      resolution: "favor clarity (same priority, but clarity is axiom)"

    - condition: "fix introduces higher priority violation"
      resolution: "reject fix"

# PRINCIPLE GROUPS (for quick/focused scans)
# PRINCIPLE GROUPS: Logical groupings of principles
#
# Groups allow profile-based filtering. Reference with "group:name".
# Example: --profile quick uses only group:quick principles.
principle_groups:
  "group:axioms": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]      # Foundational (tier: axiom)
  "group:solid": [11, 12, 13, 14, 15]                  # SOLID principles
  "group:coding": [16, 17, 18]                         # Coding practices
  "group:clean_code": [19, 20, 21, 22, 23]             # Clean Code principles
  "group:ui": [24, 25]                                 # UI/UX guidelines
  "group:llm": [26, 27, 28]                            # LLM-specific practices
  "group:operations": [29, 32]                         # Operational concerns
  "group:design": [30]                                 # Design patterns
  "group:architecture": [31]                           # Architecture principles
  "group:quick": [1, 2, 11, 19, 20]                    # Fast scan (core only)
  "group:critical": [1, 2, 4, 11, 23, 29, 32]          # Critical issues (security, stability)

# PROFILES: Pre-defined principle sets
#
# Usage: cli.rb --profile quick myfile.rb
#        cli.rb --quick (shorthand for --profile quick)
#
# Saves 60-80% on analysis time for quick scans.
profiles:
  quick:
    description: "Fast scan with core principles only"
    allow: ["group:quick"]
  full:
    description: "All 32 principles"
    allow: ["*"]
  axioms_only:
    description: "Axioms tier only (foundational)"
    allow: ["group:axioms"]
  solid_focus:
    description: "SOLID principles focus"
    allow: ["group:axioms", "group:solid"]
  critical:
    description: "Critical issues only (security, stability)"
    allow: ["group:critical"]

default_profile: "full"

# HOOKS: Event-driven extensibility
#
# Available events:
#   before_scan, after_scan, before_fix, after_fix, violation_found,
#   fix_applied, fix_rejected, convergence_achieved, convergence_stuck,
#   cost_threshold, iteration_complete, profile_activated, model_cooldown
#
# Action types:
#   - log: Append to JSONL file (path: "file.jsonl")
#   - warn: Print warning (message: "text")
#   - pause: Pause and wait for Enter (message: "text")
hooks:
  on_violation_found:
    - action: "log"
      path: ".constitutional_violations.jsonl"
  on_cost_threshold:
    - action: "warn"
      message: "Cost limit approaching"
  # on_convergence_stuck:
  #   - action: "pause"
  #     message: "Convergence stuck. Review and press Enter..."

# LANGUAGE DETECTION: File type identification
language_detection:
  strategy: "ask_user_first"       # ask_user_first | auto
  fallback: "content_analysis"     # content_analysis | extension_only
  supported:
    ruby:
      extensions: [".rb", ".rake", ".gemspec"]
      indicators: ["#!/usr/bin/env ruby", "class ", "module ", "def ", "require "]

    python:
      extensions: [".py"]
      indicators: ["#!/usr/bin/env python", "def ", "class ", "import "]

    javascript:
      extensions: [".js", ".jsx", ".ts", ".tsx"]
      indicators: ["function ", "const ", "let ", "var ", "import "]

    markdown:
      extensions: [".md", ".markdown"]
      indicators: ["# ", "## ", "```"]

    yaml:
      extensions: [".yml", ".yaml"]
      indicators: ["---", "key: value"]

    shell:
      extensions: [".sh", ".bash", ".zsh"]
      indicators: ["#!/bin/bash", "#!/bin/sh", "#!/usr/bin/env zsh", "#!/bin/zsh", "if [", "for ", "typeset ", "setopt "]
      embedded_languages: ["ruby", "python"]  # heredocs may contain other languages

    zsh:
      extensions: [".zsh"]
      indicators: ["#!/usr/bin/env zsh", "#!/bin/zsh", "setopt ", "zmodload ", "typeset -a", "autoload "]
      embedded_languages: ["ruby"]

# OPENBSD: Config file mappings and validation rules
openbsd:
  man_base_url: "https://man.openbsd.org"
  cache_ttl: 86400  # 24 hours

  # Map config files to their parent daemons and man pages
  configs:
    pf.conf:
      daemon: pf
      man: pf.conf.5
      required_patterns:
        - "set skip on lo"
      forbidden_patterns: []
      warnings:
        - pattern: "pass all"
          message: "Overly permissive: 'pass all' bypasses filtering"

    nsd.conf:
      daemon: nsd
      man: nsd.conf.5
      tutorials:
        - "https://www.openbsdhandbook.com/nsd/"
        - "https://virtualinfra.online/post/openbsd-nsd-dnssec/"
        - "https://man.openbsd.org/nsd.conf.5"
      required_patterns:
        - "server:"
        - "zone:"
      warnings:
        - pattern: "rrl-size"
          absent_message: "Missing RRL config - add 'rrl-size: 1000000' for DDoS protection"
        - pattern: "rrl-ratelimit"
          absent_message: "Missing RRL ratelimit - add 'rrl-ratelimit: 200' (responses/sec per IP)"
        - pattern: "hide-version"
          absent_message: "Consider 'hide-version: yes' to hide NSD version"
        - pattern: "ip-address"
          absent_message: "Missing 'ip-address:' - NSD should bind to specific IP, not all interfaces"
      dnssec_requirements:
        - "Use ldns-keygen for ZSK (ECDSAP256SHA256) and KSK"
        - "Sign zones with ldns-signzone"
        - "Reference .signed zonefile in nsd.conf"
        - "Generate DS record with ldns-key2ds and submit to registrar"
        - "Rebuild with nsd-control rebuild after signing"
      best_practices:
        - "chown -R _nsd:_nsd /var/nsd"
        - "chmod -R 755 /var/nsd"
        - "Use nsd-control-setup to generate control keys"
        - "Rotate ZSK more frequently than KSK"
        - "Use ECDSAP256SHA256 algorithm for modern compatibility"

    httpd.conf:
      daemon: httpd
      man: httpd.conf.5
      required_patterns:
        - "server"

    smtpd.conf:
      daemon: smtpd
      man: smtpd.conf.5
      required_patterns:
        - "listen on"
        - "action"
        - "match"
      warnings:
        - pattern: "match from any"
          message: "Open relay risk: 'match from any' allows external relay"
        - pattern: "pki"
          absent_message: "Missing PKI directive (TLS not configured)"

    relayd.conf:
      daemon: relayd
      man: relayd.conf.5
      required_patterns:
        - "relay"
      warnings:
        - pattern: "tls keypair"
          absent_message: "Missing TLS keypair directive"

    acme-client.conf:
      daemon: acme-client
      man: acme-client.conf.5
      required_patterns:
        - "authority"
        - "domain"

    doas.conf:
      daemon: doas
      man: doas.conf.5
      required_patterns:
        - "permit"
      warnings:
        - pattern: "nopass"
          message: "nopass allows passwordless privilege escalation"

    sshd_config:
      daemon: sshd
      man: sshd_config.5
      warnings:
        - pattern: "PermitRootLogin yes"
          message: "Security risk: root login enabled"
        - pattern: "PasswordAuthentication yes"
          message: "Consider disabling password auth for key-only access"

    ntpd.conf:
      daemon: ntpd
      man: ntpd.conf.5
      required_patterns:
        - "server"

    unbound.conf:
      daemon: unbound
      man: unbound.conf.5
      required_patterns:
        - "server:"

# PROVIDERS: LLM and Infrastructure Provider Integrations
# Each provider (OpenRouter, Replicate, OpenBSD Amsterdam, Claude, etc.)
# gets its own section with relevant configs.
providers:
  # ---------------------------------------------------------------------------
  # OpenRouter: Multi-model LLM API gateway
  # ---------------------------------------------------------------------------
  openrouter:
    enabled: true
    base_url: "https://openrouter.ai/api/v1"
    env_key: "OPENROUTER_API_KEY"
    features:
      - tool_calling
      - streaming
      - prompt_caching
    docs: "https://openrouter.ai/docs"
    
  # ---------------------------------------------------------------------------
  # Replicate: Generative AI models (50k+ models)
  # ---------------------------------------------------------------------------
  replicate:
    enabled: true
    base_url: "https://api.replicate.com/v1"
    env_key: "REPLICATE_API_TOKEN"
    explore_url: "https://replicate.com/explore"
    docs: "https://replicate.com/docs"
    features:
      - image_generation
      - video_generation
      - audio_generation
      - wild_chain
      - model_indexing
      - lora_training
    # Featured models (Feb 2026)
    featured_models:
      image:
        - "black-forest-labs/flux-2-klein-4b"      # Sub-second, 4 steps distilled
        - "black-forest-labs/flux-2-klein-9b"      # Higher quality variant
        - "google/nano-banana-pro"                  # Google SOTA image gen/edit
        - "openai/gpt-image-1.5"                    # OpenAI latest
        - "prunaai/z-image-turbo"                   # 6B params, super fast
        - "qwen/qwen-image-edit-2511"               # Image editing
        - "sourceful/riverflow-2.0-pro"             # Agentic, font control
      video:
        - "kwaivgi/kling-v2.6"                      # Top-tier i2v, native audio
        - "google/veo-3.1-fast"                     # High-fidelity, context-aware audio
        - "bytedance/seedance-1.5-pro"              # ByteDance video
        - "lightricks/ltx-2-distilled"              # Fast video
        - "pixverse/pixverse-v5.6"                  # PixVerse latest
      audio:
        - "qwen/qwen3-tts"                          # Voice, Clone, Design modes
      llm:
        - "moonshotai/kimi-k2.5"                    # Vision+text, thinking, multi-agent
        - "google/gemini-3-flash"                   # Speed + intelligence + grounding
    collections:
      - "text-classification"
      - "vision-models"
      - "flux-fine-tunes"
      - "qwen-image-fine-tunes"
      - "utilities"
    
  # ---------------------------------------------------------------------------
  # Claude/Copilot: GitHub Copilot CLI and Claude Code CLI
  # ---------------------------------------------------------------------------
  claude:
    enabled: true
    executor: "cli.rb"
    constitution: "master.yml"
    auto_load: true
    shell:
      preferred: "zsh"
      fallback: null  # no bash fallback
      mandate_file_tools: true
    permissions:
      allow:
        - "zsh:*"
        - "ruby:*"
        - "git:*"
        - "ssh:*"
      deny:
        - "rm -rf:*"
        - "dd:*"
        - "mkfs:*"
        - "bash:*"
      ask:
        - "reboot"
        - "shutdown"
        - "doas"
    style:
      brevity: "extreme"
      anti_sprawl: true
      prescan: true
      
  # ---------------------------------------------------------------------------
  # OpenBSD Amsterdam: VPS hosting on vmm(4)/vmd(8)
  # ---------------------------------------------------------------------------
  openbsd_amsterdam:
    enabled: true
    host: "185.52.176.18"
    user: "dev"
    key_path: "G:/priv/passwd/openbsd_key"
    os: "OpenBSD 7.8-release"
    provider_url: "https://openbsd.amsterdam"
    docs:
      - "https://openbsd.amsterdam/setup.html"
      - "https://www.openbsdhandbook.com/"
      - "https://man.openbsd.org/"
    features:
      console: "vmctl(8) + cu(1)"
      backup: "10G included"
      ipv6: "/64 dedicated"
      ptr: "https://openbsd.amsterdam/ptr.html"
    building_blocks:
      - "vmm(4)/vmd(8)"
      - "dhcpd(8)"
      - "doas(1)"
      - "unbound(8)"
      - "autoinstall(8)"
      - "httpd(8)"
      - "pf(4)"
    sysctl_tuning:
      - "net.inet.ip.forwarding=1"
      - "net.inet6.ip6.forwarding=1"
      - "net.inet.ip.arpq.maxlen=256"
    maintenance:
      update: "syspatch && pkg_add -u"
      reboot: "doas reboot"
      console: "ssh dev@185.52.176.18 -t 'cu -l /dev/tty00'"

# REFINEMENTS: Evolution from v1 to v48
#
# Documents the micro-refinements made over 48 versions.
# Each refinement shows old behavior, new behavior, and benefit.
refinements:
  pattern_detection:
    old: "50+ regex patterns in YAML"
    new: "Single LLM reasoning call"
    benefit: "Catches nuanced violations, zero maintenance"

  section_duplication:
    old: "Same rule in constitution, principles, and implementation"
    new: "Flat principle registry, reference by ID"
    benefit: "DRY, single source of truth"

  user_workflow:
    old: "User runs 3+ commands manually"
    new: "Single command does everything"
    benefit: "Zero cognitive load, sensible defaults"

  edge_case_handling:
    old: "Basic error checking"
    new: "15 edge cases handled: hallucination, cost explosion, infinite loops, conflicts, binary files, permissions, symlinks, concurrent access, network interruption, priority inversion, memory exhaustion, YAML bombs, circular references"
    benefit: "Production-ready, battle-tested"

  language_detection:
    old: "Extension-only detection"
    new: "Ask user first, fallback to content analysis"
    benefit: "Accurate, handles edge cases (no extension, wrong extension, polyglot)"

  llm_fallback:
    old: "Single model, fail on error"
    new: "Multi-model RAG with graceful degradation"
    benefit: "High availability, cost optimization"

  cost_tracking:
    old: "Per-call tracking"
    new: "Per-file and per-session limits with warnings"
    benefit: "Budget protection, no surprises"

  convergence_detection:
    old: "Fixed iterations"
    new: "Loop detection, oscillation detection, improvement tracking"
    benefit: "Faster convergence, catches stuck states"

  fix_validation:
    old: "Apply fix blindly"
    new: "Validate fix doesn't introduce worse violations"
    benefit: "Priority-aware, prevents regressions"

  file_safety:
    old: "Assume regular file"
    new: "Check binary, permissions, special files, symlinks"
    benefit: "Safe operations, no surprises"

  concurrency:
    old: "No locking"
    new: "File locking with stale detection"
    benefit: "Safe concurrent use"

  transactions:
    old: "Partial updates on failure"
    new: "Atomic operations with automatic rollback"
    benefit: "Consistent state always"

  memory_management:
    old: "Unlimited history"
    new: "Bounded history, periodic GC"
    benefit: "Handles large files without OOM"

  yaml_safety:
    old: "Unrestricted YAML load"
    new: "Size limit, timeout, bomb detection"
    benefit: "Prevents DoS attacks"

  principle_priority:
    old: "No priority system"
    new: "10-point priority scale with conflict resolution"
    benefit: "Clear decision making, no ambiguity"

  separation_of_concerns:
    old: "Logic mixed in YAML and code"
    new: "master.yml (rules/principles/workflows) + cli.rb (thin enforcer)"
    benefit: "Clear architecture, easy to maintain"
