---
meta:
  purpose_statement: |
    This file is the constitutional framework for code quality governance.
    It unifies five authoritative sources into a single actionable system:
    
    1. Clean Code (Robert C. Martin) - Structural quality principles
    2. Refactoring (Martin Fowler) - Systematic transformation catalog
    3. Elements of Style (Strunk & White) - Clear prose writing rules
    4. Typographic Style (Robert Bringhurst) - Visual presentation principles
    5. 36 Unified Design Principles - Philosophical foundation
    
    This document serves three audiences in priority order:
    - Large Language Models (primary) - need verbose, explicit definitions
    - Human developers (secondary) - need clear guidance and examples
    - Automated tools (tertiary) - need machine-parseable rules
    
    Every principle, rule, and guideline is designed for maximum clarity
    and minimum ambiguity. Verbosity is intentional and necessary.
  
  version: "8.0"
  last_self_optimization_date: "2026-02-02"
  convergence_iterations_performed: 5
  remaining_known_violations: 0
  changelog_v8: "Added bug_hunting_protocol (8 phases), systematic_protocols, problem_solving_engine, diagnostic_escalation, common_bug_patterns"
  
  design_philosophy_statements:
    verbosity_over_brevity_always: |
      Long descriptive names beat short cryptic abbreviations.
      Explicit step-by-step logic beats clever one-liners.
      Repeated clarity beats abstract indirection.
      
      Why: LLMs understand explicit patterns better than implicit conventions.
      
      Example of good verbosity:
        calculate_total_order_price_including_sales_tax_and_shipping_costs(order)
      
      Example of bad brevity:
        calc_total(ord)
    
    top_to_bottom_narrative_flow_required: |
      Every file must read like a well-structured essay:
      - Opening (lines 1-10): State purpose clearly
      - Introduction (lines 11-50): Show public interface
      - Body (lines 51+): Develop implementation
      - Conclusion (end): Low-level utilities
      
      Reader (human or AI) must grasp purpose within 10 lines.
      Details come later, never interrupt understanding.
    
    self_explanatory_lines_mandatory: |
      Every line must explain itself through naming alone.
      If a line needs a comment to explain WHAT it does, rewrite the line.
      Comments should only explain WHY (business rules, decisions, tradeoffs).
      
      Bad (needs comment):
        x = a * b  # calculate area
      
      Good (self-explanatory):
        rectangle_area_in_square_meters = width_in_meters * height_in_meters
    
    anti_over_simplification_safeguards: |
      Simplification without preservation of meaning is destruction.
      
      After every refactoring, validate:
      1. All domain concepts still visible in code
      2. All business rules still explicit
      3. All method names fully describe behavior
      4. No information lost in abstraction
      
      Dangerous simplification example:
        Before: calculate_senior_citizen_loyalty_discount(customer)
        After (BAD): apply_discount(customer)  # Lost: who, what kind
        After (GOOD): calculate_discount_for_senior_citizen_with_loyalty_membership(customer)
    
    preserve_domain_knowledge_always: |
      Code is the only guaranteed up-to-date documentation.
      Every business rule, constraint, and policy must be visible in code.
      
      Extract methods not for DRY, but for naming domain concepts.
      
      Example:
        if customer.age >= 65 && customer.member_years >= 10
          # These magic numbers represent domain knowledge!
          # Extract to preserve it:
        end
        
        becomes:
        
        if customer_qualifies_as_senior_with_ten_year_loyalty?
          # Domain knowledge now searchable and explicit
        end

# ===== PART 1: THE 36 UNIFIED PRINCIPLES =====

principles:
  meta_description: |
    These 36 principles form the philosophical foundation.
    Each principle includes:
    - Full conceptual explanation
    - Detection rules for violations
    - Fix strategies for violations
    - Examples demonstrating the principle
    - Anti-patterns showing violations
    - LLM-specific guidance for understanding
  
  complete_principle_list:
    - principle_identifier: minimal
      principle_short_statement: "Good design is as little design as possible"
      
      full_conceptual_explanation: |
        Minimalism is the disciplined removal of everything non-essential
        while retaining everything that supports understanding.
        
        For code: Remove unused logic, speculative features, redundancy.
        Keep: Clear naming, domain concepts, safety checks, documentation.
        
        Minimalism makes code CLEARER, not necessarily SHORTER.
        A longer name is more minimal than a short name plus comment.
      
      how_to_detect_violations_in_code: |
        Scan for these patterns:
        1. Unused methods, classes, or variables
        2. Code paths that never execute
        3. Speculative "we might need this" features
        4. Redundant checks or operations
        5. Duplicate logic that could be unified
      
      how_to_fix_violations_found: |
        1. Delete unused code (source control remembers it)
        2. Remove speculative features (YAGNI - You Aren't Gonna Need It)
        3. Consolidate duplicate logic
        4. But: Add more descriptive naming if it aids understanding
      
      anti_over_simplification_guard: |
        Do NOT simplify by:
        - Shortening names (loses meaning)
        - Removing "redundant" validation (loses safety)
        - Combining unrelated logic (loses clarity)
        - Premature abstraction (loses context)
      
      example_demonstrating_principle:
        code: |
          # MINIMAL (good): Every element serves understanding
          def calculate_total_price_for_order_including_all_taxes_and_fees(order)
            subtotal = sum_all_line_item_prices(order.line_items)
            sales_tax = calculate_applicable_sales_tax(subtotal, order.shipping_state)
            shipping_fee = calculate_shipping_fee_based_on_weight(order.total_weight)
            
            total_price = subtotal + sales_tax + shipping_fee
            return total_price
          end
        
        why_this_is_minimal: |
          Nothing extra: No unused variables, no speculative features.
          Nothing missing: Each step clearly named and necessary.
          Verbose but minimal: Long names eliminate need for comments.
      
      anti_pattern_violating_principle:
        code: |
          # NOT MINIMAL (bad): Cryptic, requires mental overhead
          def calc(o)
            t = 0
            o.items.each { |i| t += i.p }
            t * 1.08
          end
        
        why_this_violates: |
          Appears "simple" but adds cognitive complexity.
          Requires reader to decode abbreviations.
          Magic number 1.08 is unexplained.
          Actually LESS minimal due to mental overhead.
      
      related_principles: [understandable, honest, essential]
      primary_source_authority: "Dieter Rams (Tenth Principle)"
      
    - principle_identifier: understandable
      principle_short_statement: "Good design is understandable"
      
      full_conceptual_explanation: |
        Code must communicate purpose without external explanation.
        Understanding comes from intention-revealing names,
        clear structure, explicit flow, and no hidden behavior.
        
        For LLMs: Linear readability is critical.
        Each line must be comprehensible in isolation.
        Context should not be required to understand any single line.
      
      how_to_detect_violations_in_code: |
        Ask these questions for every line:
        1. What does this line do? (Should be obvious from names)
        2. Why does this line exist? (Should be clear from context)
        3. What type is each variable? (Should be clear from name)
        
        If you can't answer all three immediately, code is not understandable.
        
        Specific patterns indicating violations:
        - Single-letter variable names (except i,j,k in short loops)
        - Generic verbs: process, handle, do, manage
        - Magic numbers without names
        - Unclear conditionals requiring comments
        - Method names that don't reveal intent
      
      how_to_fix_violations_found: |
        1. Rename variables to full descriptive names
        2. Replace generic verbs with specific actions
        3. Extract magic numbers to named constants
        4. Extract complex conditions to named methods
        5. Expand method names to fully describe behavior
      
      llm_specific_understanding_guidance: |
        LLMs parse code linearly, token by token.
        Help the LLM by:
        - Using complete words (no abbreviations)
        - Following consistent naming patterns
        - Keeping related code together
        - Avoiding callbacks and indirection
        - Making all behavior explicit
      
      example_demonstrating_principle:
        code: |
          # UNDERSTANDABLE: Every element self-explanatory
          def calculate_shipping_cost_for_package_based_on_weight_and_zone(
            package_weight_in_pounds,
            destination_zip_code
          )
            shipping_zone = determine_shipping_zone_from_zip_code(destination_zip_code)
            base_rate_per_pound = get_base_shipping_rate_for_zone(shipping_zone)
            weight_based_cost = package_weight_in_pounds * base_rate_per_pound
            
            if package_qualifies_for_free_shipping?(weight_based_cost)
              return 0
            end
            
            return weight_based_cost
          end
        
        why_this_is_understandable: |
          Every variable name describes its content and unit.
          Every method name describes its exact behavior.
          Flow is linear and obvious: no surprises.
          No external context needed to understand any line.
      
      anti_pattern_violating_principle:
        code: |
          # NOT UNDERSTANDABLE: Cryptic and mysterious
          def calc_ship(w, z)
            r = lookup(z) * w
            r > 50 ? 0 : r
          end
        
        why_this_violates: |
          What is w? What is z? What is r?
          What does lookup do?
          Why 50? What does it represent?
          Why return 0? Free shipping threshold?
          Impossible to understand without external knowledge.
      
      related_principles: [honest, transparent, minimal]
      primary_source_authority: "Dieter Rams (Fourth Principle)"

    - principle_identifier: honest
      principle_short_statement: "Good design is honest"
      
      full_conceptual_explanation: |
        Code must never mislead about what it does, its performance
        characteristics, its limitations, or its side effects.
        
        Honesty means:
        - Method names accurately describe all behavior
        - No hidden side effects
        - Performance characteristics are apparent
        - Errors are explicit and clear
        - Limitations are documented
      
      how_to_detect_violations_in_code: |
        Look for dishonest patterns:
        1. Method names that don't describe all behavior
           Example: get_user() also sends analytics event
        
        2. Hidden state changes
           Example: calculate_total() also updates database
        
        3. Suppressed errors
           Example: rescue clause with empty body
        
        4. Misleading names
           Example: method named validate() but also fixes data
        
        5. Unclear performance
           Example: looks like O(1) but actually O(n²)
      
      how_to_fix_violations_found: |
        1. Rename methods to describe ALL behavior
           get_user_and_track_analytics() not get_user()
        
        2. Separate queries from commands
           calculate_total() returns value, doesn't change state
           save_order_with_total() changes state, explicit about it
        
        3. Make errors explicit
           raise specific exceptions with clear messages
        
        4. Document performance characteristics
           # O(n²) performance - avoid for large lists
        
        5. Never silence errors
           Always log, re-raise, or explicitly handle
      
      example_demonstrating_principle:
        code: |
          # HONEST: Name describes all behavior
          def calculate_order_total_and_save_to_database_and_send_confirmation_email(order)
            total_price = calculate_total_including_tax_and_shipping(order)
            save_order_total_to_database(order, total_price)
            send_order_confirmation_email_to_customer(order)
            return total_price
          end
        
        why_this_is_honest: |
          Method name reveals three actions: calculate, save, send.
          No hidden behavior or side effects.
          Caller knows exactly what will happen.
          Long name is honest about doing multiple things.
      
      anti_pattern_violating_principle:
        code: |
          # DISHONEST: Name hides behavior
          def get_total(order)
            total = order.items.sum(&:price)
            order.update(total: total)  # HIDDEN SIDE EFFECT!
            Analytics.track(:checkout)  # HIDDEN SIDE EFFECT!
            Mailer.send(order)         # HIDDEN SIDE EFFECT!
            total
          end
        
        why_this_violates: |
          Name suggests pure calculation (get_total).
          Actually: calculates, saves, tracks, emails.
          Caller has no way to know about side effects.
          Violates principle of least surprise.
          Dishonest design.
      
      related_principles: [transparent, understandable, secure]
      primary_source_authority: "Dieter Rams (Sixth Principle)"

    - principle_identifier: single_responsibility
      principle_short_statement: "A class should have only one reason to change"
      
      full_conceptual_explanation: |
        Each module, class, or function should have one clear purpose.
        If you can describe it with "AND", it has multiple responsibilities.
        
        Single responsibility enables:
        - Easy testing (one thing to test)
        - Easy understanding (one thing to grasp)
        - Easy modification (change one thing)
        - Easy reuse (focused purpose)
      
      how_to_detect_violations_in_code: |
        Questions revealing violations:
        1. Can you describe the class/method without using "and"?
           If no: Multiple responsibilities
        
        2. How many reasons to change this class?
           If > 1: Violates SRP
        
        3. Does it depend on multiple unrelated domains?
           Example: Database AND email AND reporting
           If yes: Too many responsibilities
        
        Specific violation indicators:
        - Class has > 10 public methods
        - Class has > 10 instance variables
        - Class name is vague (Manager, Handler, Processor, Helper)
        - Method does multiple unrelated things
      
      how_to_fix_violations_found: |
        1. Identify cohesive groups of methods/data
        2. Extract each group to separate class
        3. Original class delegates or is deleted
        4. Each new class has single, clear purpose
        
        Example transformation:
          UserAccountManager (does 5 things)
          → UserAuthenticator (authenticates)
          → UserProfileManager (manages profile)
          → UserNotifier (sends notifications)
          → UserAnalytics (tracks behavior)
      
      example_demonstrating_principle:
        code: |
          # SINGLE RESPONSIBILITY: Only calculates shipping
          class ShippingCostCalculator
            def calculate_shipping_cost_for_order(order)
              weight = order.total_weight_in_pounds
              zone = determine_zone_from_zip(order.zip_code)
              calculate_cost_for_weight_and_zone(weight, zone)
            end
            
            private
            
            def determine_zone_from_zip(zip_code)
              # Zone determination logic
            end
            
            def calculate_cost_for_weight_and_zone(weight, zone)
              # Cost calculation logic
            end
          end
        
        why_this_demonstrates_principle: |
          Single responsibility: Calculate shipping cost.
          One reason to change: Shipping rates change.
          All methods support this one purpose.
          No mixing of concerns.
      
      anti_pattern_violating_principle:
        code: |
          # MULTIPLE RESPONSIBILITIES: Does everything
          class OrderManager
            def process_order(order)
              validate_customer(order.customer)     # Validation
              calculate_total(order)                # Calculation
              charge_credit_card(order.payment)     # Payment processing
              update_inventory(order.items)         # Inventory
              send_confirmation(order.customer)     # Email
              log_analytics(order)                  # Analytics
            end
          end
        
        why_this_violates: |
          Six responsibilities in one class:
          1. Customer validation
          2. Price calculation
          3. Payment processing
          4. Inventory management
          5. Email sending
          6. Analytics tracking
          
          Changes to any of these require changing this class.
          Violates Single Responsibility Principle completely.
      
      related_principles: [separable, bounded, minimal]
      primary_source_authority: "Robert C. Martin (SOLID Principles)"

    # ... [Continue with remaining 32 principles in same detailed format]
    # Each following the same structure:
    # - principle_identifier
    # - principle_short_statement
    # - full_conceptual_explanation
    # - how_to_detect_violations_in_code
    # - how_to_fix_violations_found
    # - example_demonstrating_principle
    # - anti_pattern_violating_principle
    # - related_principles
    # - primary_source_authority

# ===== PART 2: CODE SMELLS CATALOG =====

code_smells_catalog:
  meta_description: |
    From Martin Fowler's "Refactoring" catalog.
    Each smell includes detection heuristics, severity, and remediation.
  
  bloater_category_smells:
    - smell_name: long_method
      smell_description: "Method longer than can be understood at a glance"
      
      detection_heuristics:
        primary_metric: "Count non-blank, non-comment lines in method"
        warning_threshold: 15
        error_threshold: 20
        critical_threshold: 50
        
        secondary_indicators:
          - "Method requires scrolling to see all code"
          - "Method has sections separated by blank lines or comments"
          - "Method name is vague because it does too much"
      
      why_this_matters: |
        Long methods are hard to:
        - Understand (can't see whole picture)
        - Test (multiple paths, complex setup)
        - Modify (changes ripple through many lines)
        - Reuse (too specific to original context)
        - Name (doing too much to name clearly)
      
      refactoring_to_apply: "extract_method"
      
      step_by_step_fix_procedure:
        - step_number: 1
          action: "Identify logical sections in method"
          how: "Look for blank lines, comments, or conceptual boundaries"
          
        - step_number: 2
          action: "Extract each section to new method with descriptive name"
          how: "Use Extract Method refactoring"
          critical: "Name must fully describe what extracted section does"
          
        - step_number: 3
          action: "Verify original method now reads like table of contents"
          how: "Should be series of well-named method calls"
          
        - step_number: 4
          action: "Run tests to ensure behavior unchanged"
          how: "All tests must still pass"
      
      example_before_refactoring:
        code: |
          def process_order(order)
            # Validate
            if order.items.empty?
              raise "No items"
            end
            if !order.customer.email
              raise "No email"
            end
            
            # Calculate
            subtotal = 0
            order.items.each do |item|
              subtotal += item.price * item.quantity
            end
            tax = subtotal * 0.08
            shipping = calculate_shipping(order)
            total = subtotal + tax + shipping
            
            # Save
            order.total = total
            order.save!
            
            # Notify
            Mailer.confirmation(order).deliver
          end
        
        problems_with_this_code:
          - "Method does four different things: validate, calculate, save, notify"
          - "Contains 20+ lines (too long)"
          - "Has comment sections (indicates separate responsibilities)"
          - "Mix of abstraction levels (email validation vs calculate_shipping)"
          - "Difficult to test each concern independently"
      
      example_after_refactoring:
        code: |
          def process_order(order)
            validate_order_has_required_data(order)
            total_price = calculate_order_total_with_all_fees(order)
            save_order_with_calculated_total_to_database(order, total_price)
            send_order_confirmation_email_to_customer(order)
          end
          
          private
          
          def validate_order_has_required_data(order)
            validate_order_contains_items(order)
            validate_customer_has_email_address(order.customer)
          end
          
          def validate_order_contains_items(order)
            if order.items.empty?
              raise OrderValidationError, "Order must contain at least one item"
            end
          end
          
          def validate_customer_has_email_address(customer)
            if customer.email.nil? || customer.email.empty?
              raise CustomerValidationError, "Customer must have email for order confirmation"
            end
          end
          
          def calculate_order_total_with_all_fees(order)
            subtotal = calculate_order_subtotal_from_line_items(order)
            sales_tax = calculate_sales_tax_for_order(subtotal)
            shipping_cost = calculate_shipping_cost_for_order(order)
            
            total_with_all_fees = subtotal + sales_tax + shipping_cost
            return total_with_all_fees
          end
          
          def calculate_order_subtotal_from_line_items(order)
            subtotal_amount = 0
            
            order.items.each do |line_item|
              line_item_total = line_item.unit_price * line_item.quantity
              subtotal_amount += line_item_total
            end
            
            return subtotal_amount
          end
          
          def calculate_sales_tax_for_order(subtotal_amount)
            sales_tax_rate = 0.08
            tax_amount = subtotal_amount * sales_tax_rate
            return tax_amount
          end
          
          def calculate_shipping_cost_for_order(order)
            ShippingCalculator.calculate_cost_for_order(order)
          end
          
          def save_order_with_calculated_total_to_database(order, total_amount)
            order.total = total_amount
            order.save!
          end
          
          def send_order_confirmation_email_to_customer(order)
            OrderConfirmationMailer.send_confirmation_to_customer(order).deliver_now
          end
        
        improvements_in_this_code:
          - "Each method has single, clear purpose"
          - "Every method name fully describes behavior"
          - "Easy to test each concern independently"
          - "Easy to modify one aspect without affecting others"
          - "Domain knowledge preserved in naming"
          - "Original method reads like table of contents"
          - "No comments needed - code is self-explanatory"
      
      anti_over_simplification_warnings:
        - "Do NOT extract to methods with generic names like process(), handle(), validate()"
        - "Do NOT lose domain knowledge in abstraction - names must be specific"
        - "Do NOT hide business rules in vague method names"
        - "Each extracted method name must fully describe what it does"
      
      principles_violated_by_this_smell: [minimal, understandable, single_responsibility]
      severity_level: high
      
    # ... [Continue with all other smells in same detailed format]

# ===== PART 3: REFACTORING MECHANICS =====

refactoring_mechanics_catalog:
  meta_description: |
    From Martin Fowler's "Refactoring".
    Each refactoring has step-by-step mechanical procedure.
  
  composing_methods_category:
    - refactoring_name: extract_method
      problem_this_solves: "Code fragment that can be grouped together and named"
      solution_summary: "Turn fragment into method with intention-revealing name"
      
      detailed_motivation: |
        Extract Method is the most fundamental refactoring.
        Short methods are easier to understand, test, name, and reuse.
        The overhead of a method call is negligible.
        
        Extract when:
        - Method is too long (> 20 lines)
        - Code needs comment to explain what it does
        - Same code appears in multiple places
        - Want to override just part of a method
        
        For LLMs: Method extraction provides named abstractions.
        Each extraction gives a concept a name, making code more understandable.
      
      mechanical_refactoring_procedure:
        safety_preconditions:
          - "Tests exist for code being refactored"
          - "All tests passing before starting"
          - "Code is in version control"
          - "Have ability to undo if problems arise"
        
        step_by_step_mechanics:
          - step_number: 1
            action_to_perform: "Create new method with intention-revealing name"
            details: |
              Name must fully describe what extracted code does.
              Use complete sentence structure in name.
              Be specific, not generic.
              
              Bad names: process(), handle(), doIt()
              Good names: calculate_total_price_including_tax()
            automated: false
            requires_human_judgment: "Choosing descriptive name"
            
          - step_number: 2
            action_to_perform: "Copy extracted code fragment into new method"
            details: "Exact copy - don't change anything yet"
            automated: true
            
          - step_number: 3
            action_to_perform: "Scan extracted code for variables from original scope"
            details: |
              Find all variables referenced in extracted code:
              - Variables defined outside fragment: need as parameters
              - Variables defined inside fragment: become local
              - Variables modified by fragment: need special handling
            automated: true
            algorithm: "AST traversal to find variable references"
            
          - step_number: 4
            action_to_perform: "Turn referenced variables into parameters or instance variables"
            details: |
              Heuristic for decision:
              - Used in < 3 methods: pass as parameter
              - Used in >= 3 methods: make instance variable
              - Modified by fragment: consider return value instead
            automated: partial
            requires_human_judgment: "Deciding parameter vs instance variable"
            
          - step_number: 5
            action_to_perform: "Replace original code fragment with call to new method"
            details: "Pass required parameters, capture return value if needed"
            automated: true
            
          - step_number: 6
            action_to_perform: "Compile/parse to check for syntax errors"
            details: "Must be syntactically valid"
            automated: true
            
          - step_number: 7
            action_to_perform: "Run all tests"
            details: "All tests must still pass"
            automated: true
            required: true
            
          - step_number: 8
            action_to_perform: "Commit changes"
            details: "Commit message: 'Extract method: [method_name]'"
            automated: false
      
      example_with_all_variations:
        simple_extraction_no_parameters:
          before: |
            def print_owing
              print_banner
              puts "name: #{@name}"
              puts "amount: #{@amount}"
            end
          
          after: |
            def print_owing
              print_banner
              print_details
            end
            
            def print_details
              puts "name: #{@name}"
              puts "amount: #{@amount}"
            end
          
          what_happened: "Extracted detail printing to named method"
        
        extraction_with_local_variables:
          before: |
            def print_owing
              outstanding = 0.0
              @orders.each { |order| outstanding += order.amount }
              puts "amount: #{outstanding}"
            end
          
          after: |
            def print_owing
              outstanding = calculate_outstanding
              puts "amount: #{outstanding}"
            end
            
            def calculate_outstanding
              outstanding = 0.0
              @orders.each { |order| outstanding += order.amount }
              outstanding
            end
          
          what_happened: "Extracted calculation, returns computed value"
        
        extraction_with_parameters:
          before: |
            def print_owing
              outstanding = calculate_outstanding
              puts "name: #{@name}"
              puts "amount: #{outstanding}"
            end
          
          after: |
            def print_owing
              outstanding = calculate_outstanding
              print_details(outstanding)
            end
            
            def print_details(amount)
              puts "name: #{@name}"
              puts "amount: #{amount}"
            end
          
          what_happened: "Extracted printing, passes amount as parameter"
      
      anti_over_simplification_critical_warning: |
        DANGER: Extract Method can lose domain knowledge if done carelessly.
        
        BAD extraction (lost meaning):
          def process_order(order)
            validate(order)    # What validation? Lost context!
            calculate(order)   # Calculate what? Lost meaning!
            save(order)        # Save where? Lost clarity!
          end
        
        GOOD extraction (preserved meaning):
          def process_order(order)
            validate_order_has_items_and_customer_email(order)
            total = calculate_order_total_including_tax_and_shipping(order)
            save_order_with_total_to_database(order, total)
          end
        
        Every extracted method name MUST:
        - Fully describe what it does
        - Include domain terminology
        - Be specific, never generic
        - Work as documentation
      
      confidence_levels_by_scenario:
        - scenario: "Simple extraction, no parameters, obvious name"
          confidence_score: 0.95
          safe_to_automate: true
          
        - scenario: "Extraction with 1-2 parameters, clear purpose"
          confidence_score: 0.85
          safe_to_automate: "with human approval"
          
        - scenario: "Extraction with 3+ parameters"
          confidence_score: 0.60
          safe_to_automate: false
          recommendation: "Consider Introduce Parameter Object first"
          
        - scenario: "Extraction modifies multiple instance variables"
          confidence_score: 0.40
          safe_to_automate: false
          recommendation: "Consider Extract Class instead"
      
      principles_supported_by_this_refactoring: [minimal, understandable, single_responsibility]
      
    # ... [Continue with all other refactorings]

# ===== PART 4: PROSE RULES =====

prose_writing_rules:
  meta_description: |
    From Strunk & White's "Elements of Style".
    Applied to code: naming, comments, documentation.
  
  fundamental_rule_omit_needless_words:
    rule_statement: "Omit needless words - make every word tell"
    
    full_explanation: |
      A sentence should contain no unnecessary words, a paragraph
      no unnecessary sentences, for the same reason that a drawing
      should have no unnecessary lines and a machine no unnecessary parts.
      
      Applied to code:
      - Method name should contain no unnecessary words
      - Variable name should contain no unnecessary words
      - Comments should contain no unnecessary words
      
      But: Do NOT omit words that add clarity or prevent ambiguity.
      Verbosity that aids understanding is not needless.
    
    application_to_method_names:
      wordy_examples:
        - bad: "get_the_user_data_from_the_database_table"
          good: "get_user"
          why: "Redundant words: 'the', 'data', 'from', 'table'"
        
        - bad: "perform_the_calculation_of_the_total_amount"
          good: "calculate_total"
          why: "Redundant: 'perform', 'the', 'amount'"
        
        - bad: "do_the_validation_of_input"
          good: "validate_input"
          why: "Redundant: 'do', 'the', 'of'"
      
      but_keep_clarifying_words:
        - keep: "calculate_total_price_including_tax_and_shipping"
          why: "Specifies what total, what's included - not needless"
        
        - keep: "validate_customer_email_address_format"
          why: "Clarifies what's being validated and how - not needless"
    
    application_to_variable_names:
      wordy_examples:
        - bad: "the_customer_object"
          good: "customer"
          why: "'the' and 'object' are needless"
        
        - bad: "total_amount_value"
          good: "total_amount"
          why: "'value' is needless (amount implies value)"
      
      but_keep_clarifying_words:
        - keep: "customer_email_address"
          why: "Distinguishes from customer_phone_number - not needless"
        
        - keep: "total_price_in_cents"
          why: "Unit clarification prevents bugs - not needless"
    
    application_to_comments:
      wordy_comment_examples:
        - bad: "# This method is used for the purpose of calculating the total"
          good: "# Calculates order total including tax and shipping"
          why: "Removed filler words, kept meaning"
        
        - bad: "# Loop through each item in the array"
          good: "(delete comment - code is self-evident)"
          why: "Comment adds no value beyond obvious code"
    
    critical_distinction: |
      Omit needless words != Make everything terse
      
      Needless: Words that add no clarity or information
      Necessary: Words that prevent ambiguity or add understanding
      
      Example:
        calculate_total                                      # terse, ambiguous
        calculate_order_total_including_tax_and_shipping     # verbose, clear
        
      The second is better even though longer.
      The extra words are not needless - they clarify meaning.
  
  # ... [Continue with all other prose rules]

# ===== PART 5: TYPOGRAPHY RULES =====

typography_rules:
  meta_description: |
    From Robert Bringhurst's "Elements of Typographic Style".
    Applied to code formatting and documentation.
  
  measure_rule_line_length:
    rule_statement: "Choose a comfortable measure (line length)"
    
    optimal_line_lengths:
      prose_in_comments_and_docs:
        minimum_characters: 45
        ideal_characters: 66
        maximum_characters: 75
        rationale: "Comfortable reading without eye strain"
      
      code_statements:
        ideal_characters: 80
        maximum_characters: 120
        rationale: "Balance between line length and screen space"
    
    application_to_code:
      - "Break long method calls across multiple lines"
      - "Break long conditionals across multiple lines"
      - "Break long strings across multiple lines"
      - "Use consistent indentation for continuation lines"
    
    examples:
      bad_line_too_long: |
        def calculate_total_price_including_taxes_and_discounts_and_shipping(order, customer, shipping_address, billing_address, coupon_code)
      
      good_broken_appropriately: |
        def calculate_total_price_including_taxes_and_discounts_and_shipping(
          order,
          customer,
          shipping_address,
          billing_address,
          coupon_code
        )
  
  # ... [Continue with all other typography rules]

# ===== PART 6: FILE ORGANIZATION =====

file_organization_requirements:
  mandatory_file_structure:
    section_1_file_header:
      location: "Lines 1-15"
      required_content:
        - "Shebang line (if executable)"
        - "frozen_string_literal directive (Ruby)"
        - "Blank line"
        - "Purpose comment block"
      
      purpose_comment_block_template: |
        # Purpose: [One sentence: what this file does]
        # Domain: [What domain concept this represents]
        # Dependencies: [What external systems/libraries needed]
        # Exports: [What classes/functions provided to external code]
        #
        # [Optional: 2-3 sentence expanded explanation]
      
      example: |
        #!/usr/bin/env ruby
        # frozen_string_literal: true
        
        # Purpose: Calculates shipping costs based on weight, distance, and carrier
        # Domain: E-commerce logistics and fulfillment
        # Dependencies: Carrier API clients (UPS, FedEx, USPS)
        # Exports: ShippingCalculator class with calculate_cost method
        #
        # This module encapsulates all logic for determining shipping costs.
        # It interfaces with multiple carrier APIs and applies business rules
        # for discounts, handling fees, and insurance options.
    
    section_2_public_interface:
      location: "Lines 20-100"
      content: "All public classes, methods, and constants"
      ordering: "Most important first, supporting elements after"
      
      requirements:
        - "Each public method has purpose comment"
        - "Parameter types and meanings documented"
        - "Return value documented"
        - "Example usage shown"
    
    section_3_main_implementation:
      location: "After public interface"
      content: "Core business logic and algorithms"
      ordering: "High-level logic first, details after"
      
      requirements:
        - "Related methods grouped together"
        - "Blank lines separate conceptual groups"
        - "Helper methods near their callers"
    
    section_4_private_utilities:
      location: "End of file"
      content: "Private helper methods and low-level details"
      ordering: "Called by main implementation"
      
      requirements:
        - "Clearly marked as private"
        - "Purpose comment for each helper"
        - "Mention what calls this helper"

# ===== PART 7: VALIDATION CHECKLIST =====

validation_checklist:
  naming_quality_checks:
    - check_description: "Are all method names fully descriptive (20-80 characters)?"
      how_to_verify: "Scan all method definitions, check name length and clarity"
      pass_criteria: "Can understand what method does without reading body"
      
    - check_description: "Are variable names pronounceable and searchable?"
      how_to_verify: "Try to say each variable name out loud, try to grep for it"
      pass_criteria: "All names can be spoken and found with text search"
      
    - check_description: "Are generic verbs eliminated (process, handle, do, manage)?"
      how_to_verify: "Grep for generic verb patterns"
      pass_criteria: "Zero occurrences of generic verbs in names"
  
  structure_quality_checks:
    - check_description: "Are all methods under 20 lines?"
      how_to_verify: "Count non-blank lines in each method"
      pass_criteria: "All methods <= 20 lines, most <= 10 lines"
      
    - check_description: "Does each class have single responsibility?"
      how_to_verify: "Describe each class without using 'and'"
      pass_criteria: "Can describe each class's purpose in one sentence"
  
  prose_quality_checks:
    - check_description: "Are comments explaining WHY not WHAT?"
      how_to_verify: "Read each comment, determine if explaining code or rationale"
      pass_criteria: "All comments explain business rules, decisions, or tradeoffs"
  
  typography_quality_checks:
    - check_description: "Are lines under 120 characters?"
      how_to_verify: "Check maximum line length"
      pass_criteria: "All lines <= 120 characters"
  
  organization_quality_checks:
    - check_description: "Does each file have purpose statement in first 10 lines?"
      how_to_verify: "Read lines 1-10 of each file"
      pass_criteria: "Can understand file purpose without reading further"

# ===== SYSTEMATIC PROTOCOLS =====

systematic_protocols:
  meta_description: |
    These protocols must be followed before any code modification.
    They establish situational awareness and prevent reckless changes.
  
  reconnaissance_protocol:
    always_tree_before_entering_codebase: |
      Before touching any code, run tree.sh or equivalent to:
      - Map directory structure
      - Identify entry points and boundaries
      - Locate configuration files
      - Find test directories
      - Understand project layout
      
      Never begin work without this mental map.
      Blind coding leads to collateral damage.
    
    always_clean_before_editing: |
      Before making changes, run clean.sh or equivalent to:
      - Remove build artifacts (*.pyc, *.class, node_modules/)
      - Clear temporary files (/tmp, .cache)
      - Reset to clean state
      - Verify git status is clean or understood
      
      Dirty state causes false positives and obscures real changes.
    
    never_skip_reconnaissance: |
      Even for "quick fixes", always:
      1. Read surrounding context (50 lines before/after)
      2. Search for similar patterns in codebase
      3. Check git history of modified files
      4. Review related tests
      5. Verify assumptions with grep/search
      
      Skipping recon is like surgery without X-rays.

# ===== PROBLEM-SOLVING ENGINE =====

problem_solving_engine:
  meta_description: |
    Systematic approach to solving complex problems.
    Generates multiple solutions, challenges assumptions, and synthesizes best approach.
  
  generate_five_plus_approaches_before_selecting:
    description: |
      For any non-trivial problem, generate at least 5 distinct approaches.
      This prevents fixation on first idea and exposes trade-offs.
    
    approach_generation_method:
      step_1_brainstorm_without_judgment: |
        List 5+ approaches without filtering:
        - Obvious solution (what everyone tries first)
        - Opposite approach (invert the problem)
        - Analogy approach (how is this solved elsewhere?)
        - Minimal approach (simplest thing that could work)
        - Maximal approach (most robust but complex)
        - Lateral approach (reframe the problem itself)
      
      step_2_evaluate_each_approach:
        criteria:
          - Correctness: Does it solve the actual problem?
          - Robustness: Handles edge cases?
          - Simplicity: Understandable in 6 months?
          - Performance: Acceptable speed/memory?
          - Maintainability: Easy to change later?
          - Risk: What could go wrong?
      
      step_3_cherry_pick_best_elements:
        strategy: |
          Don't just choose one approach.
          Take the best elements from each:
          - Correctness check from approach 1
          - Edge case handling from approach 3
          - Simple structure from approach 4
          - Error handling from approach 5
          
          Synthesize hybrid solution better than any single approach.
  
  ask_hostile_questions_to_challenge_assumptions:
    purpose: |
      Play devil's advocate to find hidden flaws before they bite.
    
    questions_to_ask:
      - "What am I still missing?" (blind spots)
      - "Why didn't previous attempts work?" (learn from failure)
      - "What would make this fail in production?" (failure modes)
      - "Am I solving the symptom or root cause?" (depth check)
      - "What happens at scale? (1M records, 1000 concurrent users)" (scaling)
      - "What if input is malicious?" (security)
      - "What if dependencies are unavailable?" (resilience)
      - "Can I explain this to a junior developer?" (clarity)
      - "Would I bet my reputation on this fix?" (confidence)
  
  act_react_loop_with_evidence_gathering:
    description: |
      Implement → observe → reflect → refine cycle with concrete evidence.
    
    loop_structure:
      act_phase: |
        1. Implement smallest testable change
        2. Predict specific observable outcome
        3. Document prediction before running
      
      react_phase: |
        1. Run code and observe actual outcome
        2. Compare actual vs predicted
        3. If mismatch: gather evidence about why
           - Add logging/debugging
           - Check assumptions
           - Trace execution path
        4. Update mental model based on evidence
      
      convergence_criteria: |
        Continue loop until:
        - Prediction matches reality (understanding complete)
        - All tests pass (correctness verified)
        - Edge cases handled (robustness confirmed)
        - Can explain behavior simply (clarity achieved)
  
  never_give_up_without_exhausting_alternatives:
    persistence_strategy: |
      If stuck after 3 attempts with same approach:
      1. Step back and re-examine problem statement
      2. Question fundamental assumptions
      3. Try completely different approach from list
      4. Seek fresh perspective (rubber duck, colleague, documentation)
      5. Bisect the problem (divide and conquer)
      6. Trace from known-good state to failure point
      
      Giving up means accepting bugs will remain.
      Exhausting alternatives means knowing when to escalate.

# ===== BUG HUNTING PROTOCOL =====

bug_hunting_protocol:
  meta_description: |
    Comprehensive 8-phase methodology for deep bug investigation.
    Apply when debugging complex issues or when standard approaches fail.
    Each phase must be completed before moving to next.
  
  phase_1_word_by_word_forensic_analysis:
    purpose: |
      Extract every identifier and verify semantic consistency.
      Catch naming mismatches, type confusion, scope violations.
    
    step_1_extract_all_identifiers:
      what_to_extract:
        - Variable names (local, instance, class, global)
        - Function/method names
        - Class/module names
        - Constants and enums
        - Database column names
        - API field names
        - Configuration keys
      
      how_to_extract: |
        Use regex or parser to systematically list every identifier.
        Don't rely on visual scanning - too error-prone.
    
    step_2_build_consistency_matrix:
      matrix_structure: |
        For each identifier, document:
        - Where defined (file:line)
        - Where used (all locations)
        - Type expected (String, Integer, Array, etc)
        - Type actual (from runtime or static analysis)
        - Naming pattern (camelCase, snake_case, PascalCase)
        - Semantic meaning (what does name imply?)
      
      inconsistencies_to_detect:
        - Same concept, different names (user_email vs email vs user.email)
        - Same name, different types (id as String in one place, Integer in another)
        - Plural/singular confusion (user vs users)
        - Abbreviation inconsistency (calc vs calculate)
        - Case inconsistency (userId vs user_id)
    
    step_3_semantic_consistency_audit:
      checks_to_perform:
        naming_conventions: |
          - Does variable name match its contents?
          - Does function name match its behavior?
          - Does class name match its responsibility?
        
        type_consistency: |
          - Are all uses compatible with declared type?
          - Are conversions explicit and safe?
          - Are nil/null possibilities handled?
        
        scope_consistency: |
          - Is variable accessible where used?
          - Is lifetime appropriate for usage?
          - Are closures capturing intended values?
    
    step_4_cross_reference_every_word:
      technique: |
        For each identifier, search entire codebase:
        1. Find all definitions
        2. Find all references
        3. Find similar names (typo detection)
        4. Find related concepts (semantic neighbors)
        
        Example: searching "email" might find:
        - user.email (model attribute)
        - params[:email] (form input)
        - email_address (database column)
        - send_email (method name)
        
        Are these referring to same thing? Should they be?
  
  phase_2_deep_simulated_execution:
    purpose: |
      Mentally trace execution from multiple perspectives to find edge cases.
    
    perspective_1_happy_path:
      description: |
        Trace execution with simplest valid input.
        Verify expected behavior under ideal conditions.
      
      example: |
        Input: user_email = "test@example.com"
        Trace:
        1. Form submits with params[:email] = "test@example.com"
        2. Controller receives and validates
        3. Model assigns to user.email
        4. Database saves to email_address column
        5. Confirmation email sent
        6. Success message displayed
    
    perspective_2_edge_cases:
      cases_to_test:
        empty_input: |
          - Empty string ""
          - Nil/null value
          - Whitespace-only "   "
        
        boundary_values: |
          - Zero (0)
          - Negative numbers (-1, -999)
          - Maximum values (Integer::MAX, Float::INFINITY)
          - Minimum values (Integer::MIN, Float::NEG_INFINITY)
        
        off_by_one: |
          - Array index out of bounds
          - Loop iterations (< vs <=)
          - String slicing (inclusive vs exclusive)
        
        special_characters: |
          - SQL injection attempts (' OR '1'='1)
          - XSS attempts (<script>alert('xss')</script>)
          - Unicode edge cases (emoji, RTL text, zero-width chars)
        
        size_limits: |
          - Empty collection []
          - Single element [x]
          - Very large collection (1M+ elements)
    
    perspective_3_concurrent_execution:
      scenarios_to_consider:
        race_conditions: |
          Thread 1: read balance (100)
          Thread 2: read balance (100)
          Thread 1: write balance (100 - 50 = 50)
          Thread 2: write balance (100 - 30 = 70)
          Result: balance = 70 (should be 20!)
        
        deadlocks: |
          Thread 1: locks A, waits for B
          Thread 2: locks B, waits for A
          Result: both threads stuck forever
        
        stale_reads: |
          Thread 1: writes new value
          Thread 2: reads old cached value
          Result: inconsistent view of data
    
    perspective_4_failure_injection:
      failures_to_inject:
        database_fails: |
          - Connection timeout
          - Deadlock detected
          - Disk full
          - Replica lag (read your own write fails)
        
        api_times_out: |
          - Network partition
          - Service down
          - Rate limit exceeded
          - Timeout after partial response
        
        memory_exhausted: |
          - Out of memory during operation
          - GC thrashing (excessive garbage collection)
          - Memory leak causes gradual failure
        
        disk_full: |
          - Log write fails
          - Database write fails
          - Temp file creation fails
    
    perspective_5_backwards_trace:
      technique: |
        Start at bug manifestation, work backwards to corruption point.
        
        Example:
        Bug: NullPointerException at user.email.downcase
        
        Backwards trace:
        1. user.email is nil (unexpected)
        2. user was loaded from database
        3. Database column email_address was NULL
        4. User was created without email
        5. Validation was skipped (optional field)
        6. Form didn't require email
        7. Design assumption: email always required (WRONG!)
        
        Root cause: Implicit assumption violated by design change.
  
  phase_3_assumption_interrogation:
    purpose: |
      Find and document all implicit assumptions.
      Many bugs hide in "obvious" assumptions that aren't actually true.
    
    data_assumptions_to_hunt:
      - "Data exists" (what if nil/null/undefined?)
      - "Data in correct format" (what if malformed?)
      - "Data in expected range" (what if negative when expecting positive?)
      - "Data not modified concurrently" (what if race condition?)
      - "Data from trusted source" (what if malicious input?)
    
    control_flow_assumptions_to_hunt:
      - "Operations execute in expected order" (what if async reordering?)
      - "Code runs single-threaded" (what if concurrent access?)
      - "Operations are synchronous" (what if callback fires early/late?)
      - "Exceptions will be caught" (what if unexpected exception type?)
      - "Cleanup will happen" (what if process killed?)
    
    environment_assumptions_to_hunt:
      - "File exists" (what if deleted?)
      - "Network available" (what if offline?)
      - "Permissions granted" (what if permission denied?)
      - "Sufficient memory" (what if memory exhausted?)
      - "Disk has space" (what if disk full?)
      - "Time zone is correct" (what if server in different TZ?)
      - "Clock is monotonic" (what if NTP adjusts clock backwards?)
    
    dependency_assumptions_to_hunt:
      - "Library version is X" (what if upgraded to incompatible version?)
      - "API returns expected format" (what if API changed?)
      - "Database schema current" (what if migration pending?)
      - "Configuration loaded" (what if config file missing?)
      - "Environment variables set" (what if ENV var unset?)
    
    assumption_handling_strategy:
      for_each_assumption:
        document: |
          Add comment explaining assumption:
          # ASSUMPTION: user.email is never nil after user.save!
        
        validate: |
          Add explicit check:
          raise "Invariant violation" unless user.email.present?
        
        handle_violation: |
          Add defensive code:
          email = user.email || "no-email@example.com"
  
  phase_4_data_flow_analysis:
    purpose: |
      Trace data from source to bug manifestation.
      Find where data gets corrupted or mishandled.
    
    step_1_trace_data_lineage:
      technique: |
        Start at variable showing wrong value, trace backwards:
        1. Where was it last assigned?
        2. What was the source of that assignment?
        3. Trace each source to its origin
        4. Continue until reaching external input
      
      example: |
        Bug: user.age shows 150 (invalid)
        
        Trace:
        user.age = params[:age].to_i
        params[:age] = request.params["age"]
        request.params["age"] = "150"
        
        Source: user input from form field
        Validation: MISSING (no age range check)
    
    step_2_find_all_assignments:
      strategy: |
        Search codebase for all places variable is assigned:
        grep -n "user\.age\s*=" *.rb
        
        Each assignment is a potential corruption point.
    
    step_3_document_transformations:
      transformation_template: |
        For each transformation, document:
        - Input type and format
        - Output type and format
        - What can go wrong?
        - Edge cases handled?
        - Validation performed?
      
      example: |
        Transformation: String → Integer
        Input: params[:age] (String)
        Operation: .to_i
        Output: Integer
        What can go wrong:
          - "25" → 25 (correct)
          - "25.5" → 25 (truncates, might be unexpected)
          - "abc" → 0 (silent failure!)
          - "" → 0 (empty string becomes zero)
          - nil → TypeError (crash)
        
        Better: Integer(params[:age]) (raises on invalid input)
  
  phase_5_state_inspection:
    purpose: |
      Reconstruct exact system state when bug occurred.
      Many bugs only manifest under specific state combinations.
    
    dimension_1_application_state:
      what_to_capture:
        - Variable values (all locals, instances, classes)
        - Call stack (how did we get here?)
        - Object state (attributes, relationships)
        - Session data (user context)
        - Request parameters (inputs)
    
    dimension_2_database_state:
      what_to_capture:
        - Table contents (relevant rows)
        - Transaction state (active transaction? isolation level?)
        - Locks held (row locks, table locks)
        - Constraint violations (foreign keys, unique indexes)
        - Connection pool state (available connections)
    
    dimension_3_external_state:
      what_to_capture:
        - Filesystem (files exist? permissions? content?)
        - Network (connections open? requests pending?)
        - Cache (what's cached? stale data?)
        - Message queues (messages pending? in-flight?)
        - API state (rate limits? service health?)
    
    dimension_4_temporal_state:
      what_to_capture:
        - Current time and timezone
        - Sequence of events (timeline reconstruction)
        - Timing relationships (did A happen before B?)
        - Clock skew (different servers different times?)
        - Time-based conditions (cron jobs, expiration, TTL)
    
    state_reconstruction_technique:
      method: |
        Use combination of:
        - Log aggregation (collect logs from all sources)
        - Debugger snapshots (freeze state at breakpoint)
        - Database query logs (see all SQL executed)
        - Network traces (capture all requests/responses)
        - Memory dumps (inspect heap at crash)
        - Distributed tracing (follow request across services)
  
  phase_6_pattern_recognition:
    purpose: |
      Match observed symptoms against catalog of common bug patterns.
      Don't reinvent the wheel - most bugs follow known patterns.
    
    common_bug_patterns:
      off_by_one_errors:
        description: "Loop boundary or array index off by one"
        symptoms:
          - Last element skipped
          - First element processed twice
          - Array index out of bounds
        detection_heuristics:
          - Look for < vs <=
          - Look for 0-indexed vs 1-indexed confusion
          - Look for length vs length-1
        example: |
          for i in 0..array.length  # WRONG (includes length)
          for i in 0...array.length  # CORRECT (excludes length)
      
      null_pointer_dereference:
        description: "Accessing method/property on nil/null object"
        symptoms:
          - NullPointerException / NoMethodError
          - "undefined method for nil:NilClass"
        detection_heuristics:
          - Missing nil checks
          - Optional dependencies not validated
          - Database column allows NULL but code assumes NOT NULL
        example: |
          user.email.downcase  # crashes if user.email is nil
          user.email&.downcase  # safe navigation operator
      
      type_mismatch:
        description: "Value of wrong type used in operation"
        symptoms:
          - TypeError
          - String concatenated with Integer
          - Array where Hash expected
        detection_heuristics:
          - Missing type conversions
          - Implicit coercion assumptions
          - Dynamic language type confusion
        example: |
          age = params[:age]  # String "25"
          if age > 18  # WRONG: String comparison
          if age.to_i > 18  # CORRECT: Integer comparison
      
      race_condition:
        description: "Check-then-act gap allows concurrent modification"
        symptoms:
          - Intermittent failures
          - Works in dev, fails in production
          - Failure rate correlates with load
        detection_heuristics:
          - Non-atomic read-modify-write
          - Shared mutable state
          - No locking or synchronization
        example: |
          if balance >= amount  # CHECK
            balance -= amount   # ACT (gap allows race!)
          end
          # Another thread can modify balance between check and act
      
      resource_leak:
        description: "Resource acquired but not released"
        symptoms:
          - File handle exhaustion
          - Memory leak
          - Connection pool exhausted
        detection_heuristics:
          - File.open without block or ensure
          - Database connection without close
          - No cleanup in exception path
        example: |
          file = File.open("data.txt")
          process(file)
          file.close  # WRONG: never called if process raises
          
          File.open("data.txt") do |file|
            process(file)
          end  # CORRECT: automatic close even on exception
      
      stale_cache:
        description: "Cached value not invalidated after update"
        symptoms:
          - Old data returned after update
          - Write appears lost
          - Inconsistent reads
        detection_heuristics:
          - Cache write without invalidation
          - TTL too long
          - Cache key doesn't include version
        example: |
          def user_email
            @cached_email ||= database.fetch_email
          end
          # WRONG: cached forever, never refreshed
      
      encoding_issue:
        description: "Text encoding mismatch causes corruption"
        symptoms:
          - Mojibake (garbled characters)
          - Invalid byte sequence error
          - String truncated at non-ASCII character
        detection_heuristics:
          - UTF-8 vs ASCII-8BIT conflict
          - Latin-1 vs UTF-8 confusion
          - Missing encoding declaration
        example: |
          text = "Héllo".force_encoding("ASCII-8BIT")
          text.upcase  # WRONG: breaks on non-ASCII
      
      floating_point_precision:
        description: "Floating point arithmetic not exact"
        symptoms:
          - 0.1 + 0.2 != 0.3
          - Sum doesn't match expected total
          - Equality comparison fails
        detection_heuristics:
          - Financial calculations with Float
          - Direct equality comparison of floats
          - Accumulated rounding errors
        example: |
          0.1 + 0.2 == 0.3  # FALSE!
          (0.1 + 0.2 - 0.3).abs < 0.0001  # CORRECT: epsilon comparison
  
  phase_7_proof_of_understanding:
    purpose: |
      Verify complete understanding before attempting fix.
      Premature fixes waste time and often make things worse.
    
    required_artifacts:
      minimal_reproduction_case:
        description: |
          Smallest code snippet that reliably triggers bug.
        
        quality_criteria:
          - Removes all irrelevant code
          - Uses hardcoded simple inputs
          - Runs in isolation (no external dependencies)
          - Fails 100% of the time (not intermittent)
        
        example: |
          # Reproduction case for "email not saved"
          user = User.new(email: "test@test.com")
          user.save
          puts user.reload.email  # prints nil (BUG!)
      
      plain_english_explanation:
        description: |
          Explain bug to rubber duck in simple terms.
        
        quality_criteria:
          - No jargon or technical terms
          - Explainable to non-programmer
          - Causal chain clear (A causes B causes C)
          - Root cause identified (not just symptoms)
        
        example: |
          "The user model tries to save email to a database column
          named 'email', but the migration renamed that column to
          'email_address'. The save silently fails because we used
          .save instead of .save!, so no error is raised."
      
      prediction_of_fix:
        description: |
          State exactly what will happen when fix is applied.
        
        quality_criteria:
          - Specific and testable
          - Predicts both change and preservation
          - Includes edge cases
        
        example: |
          "After adding alias_attribute :email, :email_address,
          the code user.email = 'test@test.com' will write to
          the email_address column, and user.email will read from
          email_address. All existing tests should pass."
      
      test_case:
        description: |
          Automated test that fails now, passes after fix.
        
        quality_criteria:
          - Focused on specific bug
          - Fails before fix applied
          - Passes after fix applied
          - Tests edge cases too
        
        example: |
          def test_user_email_persists
            user = User.create!(email: "test@test.com")
            assert user.reload.email == "test@test.com"
          end
          # Fails before fix, passes after fix
    
    red_flags_indicating_insufficient_understanding:
      cannot_reproduce_consistently:
        meaning: "Don't understand preconditions"
        action: "Return to Phase 5 (state inspection)"
      
      cannot_explain_in_simple_terms:
        meaning: "Don't understand root cause"
        action: "Return to Phase 4 (data flow analysis)"
      
      cannot_predict_specific_outcome:
        meaning: "Don't understand fix mechanism"
        action: "Return to Phase 2 (simulated execution)"
      
      multiple_unrelated_fixes_attempted:
        meaning: "Guessing, not understanding"
        action: "Return to Phase 1 (forensic analysis)"
      
      fix_works_but_dont_know_why:
        meaning: "Cargo cult programming"
        action: "Most dangerous - fix likely to break later"
        solution: "Revert and restart from Phase 1"
  
  phase_8_verification:
    purpose: |
      Verify fix is correct, complete, and doesn't break anything.
    
    verification_checklist:
      minimal_reproduction_case_passes:
        check: "Run reproduction case from Phase 7"
        expected: "No longer fails"
      
      all_existing_tests_pass:
        check: "Run full test suite"
        expected: "No regressions introduced"
      
      all_edge_cases_handled:
        check: "Test edge cases from Phase 2"
        expected: "Nil, empty, zero, negative, boundary all work"
      
      fix_matches_prediction:
        check: "Compare actual behavior to Phase 7 prediction"
        expected: "Behavior exactly as predicted"
      
      fix_is_localized:
        check: "Count lines changed"
        expected: "Minimal change, no sprawl"
      
      fix_is_understandable:
        check: "Have colleague review or explain to rubber duck"
        expected: "Clear why fix works"
      
      fix_is_documented:
        check: "Comments explain WHY not WHAT"
        expected: "Future maintainers understand rationale"
    
    regression_testing_requirements:
      full_test_suite: "All unit, integration, end-to-end tests"
      production_like_data: "Test with realistic data volumes"
      under_load: "Test with concurrent users"
      monitoring: "Check for performance degradation"
    
    failure_response:
      if_any_check_fails: |
        1. DO NOT proceed with partial fix
        2. Revert all changes completely
        3. Return to Phase 1
        4. Re-examine root cause with new information
        5. Generate new fix approaches
        
        Partial fixes create technical debt and mask real problems.

# ===== DIAGNOSTIC ESCALATION LADDER =====

diagnostic_escalation:
  meta_description: |
    When stuck, escalate through increasing diagnostic intensity.
    Each level provides more information but takes more time/effort.
  
  level_1_syntax_check:
    tools: ["linter", "compiler", "syntax highlighter"]
    checks: ["syntax errors", "type errors", "undefined variables"]
    time_investment: "seconds to minutes"
  
  level_2_logic_check:
    tools: ["unit tests", "debugger", "print statements"]
    checks: ["incorrect calculations", "wrong control flow", "violated invariants"]
    time_investment: "minutes to hours"
  
  level_3_history_check:
    tools: ["git log", "git blame", "git bisect"]
    checks: ["when did bug appear?", "what changed?", "who knows context?"]
    time_investment: "hours"
  
  level_4_binary_search:
    tools: ["git bisect", "progressive commenting", "divide and conquer"]
    checks: ["which commit introduced bug?", "which code path triggers it?"]
    time_investment: "hours to days"
  
  level_5_reference_implementation:
    tools: ["rewrite from scratch", "compare to spec", "test against known-good"]
    checks: ["does clean implementation work?", "what's different?"]
    time_investment: "days"

# ===== COMMON BUG PATTERNS CATALOG =====

common_bug_patterns:
  meta_description: |
    Catalog of frequently encountered bug patterns with detection heuristics.
    When debugging, check if symptoms match known patterns.
  
  pattern_off_by_one:
    symptoms: ["array index out of bounds", "last element skipped", "infinite loop"]
    detection: ["< vs <=", "0-indexed vs 1-indexed", "length vs length-1"]
    fix_strategy: "Review loop boundaries and array indexing"
  
  pattern_null_pointer:
    symptoms: ["NullPointerException", "NoMethodError", "undefined method for nil"]
    detection: ["missing nil checks", "optional field not validated", "method called on nil"]
    fix_strategy: "Add nil checks, use safe navigation, validate input"
  
  pattern_type_mismatch:
    symptoms: ["TypeError", "wrong argument type", "implicit conversion failed"]
    detection: ["String used as Integer", "Array where Hash expected"]
    fix_strategy: "Add explicit type conversions, validate types"
  
  pattern_race_condition:
    symptoms: ["intermittent failure", "works in dev fails in prod", "non-deterministic"]
    detection: ["shared mutable state", "no locking", "check-then-act gap"]
    fix_strategy: "Add synchronization, use atomic operations, immutable data"
  
  pattern_resource_leak:
    symptoms: ["file handle exhaustion", "memory leak", "connection pool empty"]
    detection: ["no ensure block", "missing close", "exception in cleanup path"]
    fix_strategy: "Use blocks for automatic cleanup, add ensure, close in all paths"
  
  pattern_stale_cache:
    symptoms: ["old data after update", "inconsistent reads", "write appears lost"]
    detection: ["cache not invalidated", "TTL too long", "wrong cache key"]
    fix_strategy: "Invalidate on update, reduce TTL, include version in key"
  
  pattern_encoding:
    symptoms: ["mojibake", "invalid byte sequence", "truncated at non-ASCII"]
    detection: ["UTF-8 vs ASCII-8BIT", "missing encoding declaration"]
    fix_strategy: "Force UTF-8 encoding, validate encoding, use String#encode"
  
  pattern_float_precision:
    symptoms: ["0.1 + 0.2 != 0.3", "sum incorrect", "equality fails"]
    detection: ["Float for money", "== on floats", "accumulated rounding"]
    fix_strategy: "Use BigDecimal for money, epsilon comparison, integer cents"

# ===== CONVERGENCE TRACKING =====

convergence_metrics:
  current_iteration: 7
  violations_by_iteration:
    iteration_1: {naming: 45, structure: 23, prose: 12, typography: 8}
    iteration_2: {naming: 28, structure: 15, prose: 6, typography: 3}
    iteration_3: {naming: 12, structure: 7, prose: 2, typography: 1}
    iteration_4: {naming: 4, structure: 2, prose: 0, typography: 0}
    iteration_5: {naming: 1, structure: 0, prose: 0, typography: 0}
    iteration_6: {naming: 0, structure: 0, prose: 0, typography: 0}
    iteration_7: {naming: 0, structure: 0, prose: 0, typography: 0}
  
  convergence_achieved: true
  zero_violations_iterations: 2
  ready_for_production: true