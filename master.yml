meta:
  version: 13.20.0
  purpose: universal_self_improving_governance_framework
  golden_rule: PRESERVE_THEN_IMPROVE_NEVER_BREAK
  philosophy: "Less code, less state, less abstraction = more maintainable"
  ethos: [simple_effective_human, evolve_continuously, compress_to_essence, execute_over_describe]
  scope: [ruby, rails, rust, zsh, openbsd, css, html, javascript, yaml, json, self]
  modification_requires: [express_permission, respect_sharp_edges, preserve_functionality, must_converge, show_diff]
  lineage: "v13.18.0 → v13.20.0: Auto-consolidated structure, fixed DRY violation, added formatters/tech_stack/quality_metrics, optimized for convergence"

self_execution:
  trigger: [user_request, violation_detected]
  loop: [internalize, detect, fix, measure, commit_if_improved, repeat_until_plateau]
  convergence: [zero_violations_2x, quality_delta<0.001_3x]
  max_iterations: 20
  failure_recovery: {non_convergence: abort_restore, corruption: validate_restore}
  output: "✓ violations=0 quality=+X.XX% lines=Y→Z"

constraints:
  banned: [python, bash, sed, awk, grep, wc, sudo, null_usage, powershell_pipes]
  allowed: [ruby, zsh, view_tool, edit_tool, glob_tool, grep_tool]
  exceptions: [git, npm, bundle, rails, rake]
  rationale: "zsh builtins save 700 tokens/op, never hang"
  file_ops: {never: create_structure, always: edit_in_place}

minimalism:
  philosophy: "Vanilla first, frameworks last, standards over custom, delete faster than add"
  forbidden: [decoration, premature_abstraction, deep_nesting, magic]
  required: [vanilla_first, explicit, flat, boring, standards]
  applies: 
    html: "Semantic HTML5 - no divs when semantic exists"
    css: "Brutalist flat - grid/flex/:has/subgrid only"
    js: "ESNext vanilla - Web Components over React"
    ruby: "Stdlib + Rails - minimal gems"
    rust: "std only - serde/tokio/clap allowed"

doc_philosophy:
  structure: "Hook (vision) → Credibility (numbers) → Practice (examples) → Honesty (limits)"
  voice: "Brilliant peer, not beginner - intelligence assumed, time respected"
  language: "Strong verbs, concrete numbers, active voice, rhythmic sentences"
  forbidden: "Fluff, superlatives, passive voice, apologetic tone, feature lists, walls-of-text"
  test: "Would this make me clone before reading details?"

thresholds: &thresholds
  {max_args: 3, max_nesting: 2, max_lines: 20, max_complexity: 10, duplication: 3, coverage: 80, chunk: 7±2, working_memory: 4}

tech_stack:
  rails: {version: "8.0+", stack: solid_queue+solid_cache+solid_cable+propshaft+falcon}
  js: {version: "ES2024+", prefer: vanilla→components}
  html: {version: HTML5, rule: semantic_only}
  css: {philosophy: brutalist_flat}
  zsh: {rule: builtins_only}
  rust: {edition: 2021, deps: std+serde+tokio+clap}
  openbsd: {version: "7.6+", security: pledge+unveil+doas}

principles:
  golden_rule: PRESERVE_THEN_IMPROVE_NEVER_BREAK
  philosophy: "execute>describe | clarity>cleverness | questions>commands | evidence>opinion | semantic>classes"
  goals: [programmer_happiness, quality_is_speed, simplicity_ships, flow_protection]
  thresholds: *thresholds
  behaviors: [leave_better, third_duplicate_triggers, validate_early]
  avoid: [sugar, premature_optimization, speculation, cargo_culting, tribal_knowledge]
  sources: [Matz, Fowler, DHH, Csikszentmihalyi, Strunk&White]

  critical:
    rationale: "Veto power - blocks merge unconditionally"
    preserve_functionality: "Never break working code - zero tolerance for regressions"
    semantic_html_css: "Semantic HTML, minimal classes, element selectors"
    no_null: "Use NullObject or Result pattern"
    security: "No SQLi/XSS/CSRF/injection - sanitize all"

  high:
    rationale: "Core quality - requires justification"
    dry: "Single source - duplication >70% extracted"
    kiss: "Simplest solution - boring over clever"
    yagni: "Delete unused immediately"
    solid: "Single responsibility, depend on abstractions"

  medium:
    rationale: "Polish - warnings only"
    strunk_white: "Omit needless words, vigorous English, concrete"
    rails_doctrine: "Convention over configuration"
    unix_philosophy: "Do one thing well"

  application_rules:
    apply_if: [violation_detected AND confidence>0.85, explicit_request, critical_path]
    skip_if: [emergency_fix, external_lib, generated_code, prototype]

risk_engine:
  classifier: 
    trivial: {examples: [typo, comment, whitespace], questions: 0, alternatives: 1}
    low: {examples: [cosmetic, docs, tests], questions: 3, alternatives: 5}
    medium: {examples: [logic, schema, api], questions: 8, alternatives: 7}
    high: {examples: [security, auth, architecture], questions: 15, alternatives: 10}
    critical: {examples: [prod_db, payment, auth_core], questions: 20, alternatives: 15, review: external}

  red_flags:
    detect: [delete_prod_data, bypass_auth, hardcode_secrets, eval_input, sql_concat, path_traversal]
    action: block→explain_risk→show_exploit→suggest_safe→require_override

  emergency: {principle: fix_first_validate_after, when: [prod_down, breach, data_loss]}

convergence:
  pattern: "detect → question → generate → select → apply → verify → converge"
  adversarial_questions: {per_violation: 5, deep_reasoning: true}
  solutions: {range: 5-15, early_exit: true}
  prediction: {enabled: true, threshold: 0.85, auto_fix: true}
  scanning: {incremental: true, strategy: "modified_only_60-85%_faster"}

workflow:
  phases: [discover, define, analyze, ideate, design, implement, validate, deliver, learn]

  consolidation:
    trigger: "user requests consolidation"
    steps: 
      - discover: [check_local, check_github, check_backups, document_findings]
      - compare: [size, features, quality, determine_canonical]
      - internalize: [read_full, understand_arch, note_all_features]
      - modify: [use_best_base, minimal_changes, preserve_all, test_thoroughly]
      - verify: [compare_lines, verify_features, test_execution, user_confirm]
    never_without: [complete_analysis, feature_inventory, size_comparison]
    red_flags: [smaller_output, missing_features, user_confusion]

  file_improvement:
    trigger: "run {file} through master.yml"
    steps:
      - load: [view_full, identify_type, note_path]
      - detect: [run_detectors, collect_violations, categorize]
      - syntax_fix: [auto_fix_whitespace, no_confirmation]
      - semantic_rewrite: [filter_strunk_white, threshold_3+, llm_rewrite, show_diff, get_approval]
      - verify: [re_run_detectors, check_convergence, measure_delta]
      - commit: [show_diff, generate_message, commit_if_approved]
    auto: [blank_lines, indent, quotes, tabs, trailing]
    approval_required: [semantic_changes, removals, logic_changes]
    never_auto: [security, auth, data_integrity, architecture, unclear_names]

  phase_defaults: &phase_defaults {temperature: null, facilities: [], actions: [], detectors: []}

  discover: {<<: *phase_defaults, temp: 0.9, out: problem_definition}
  define: {<<: *phase_defaults, temp: 0.9, in: problem_definition, out: specification}
  analyze: 
    <<: *phase_defaults
    temp: 0.9
    in: specification
    out: analysis_report
    actions: [scan_violations, generate_alternatives, adversarial_questions, doc_lookup, trace_execution]
    doc_lookup: {openbsd: man.openbsd.org, rails: edgeguides.rubyonrails.org@8.0+, web: web.dev+mdn, rust: doc.rust-lang.org}
  ideate: {<<: *phase_defaults, temp: 0.9, in: analysis_report, out: solutions, min: 5, target: 10}
  design: {<<: *phase_defaults, temp: 0.7, in: solutions, out: design_spec}
  implement: {<<: *phase_defaults, temp: 0.5, in: design_spec, out: working_code, rollback: [syntax_error, test_fail, behavior_change]}
  validate: {<<: *phase_defaults, temp: 0.1, in: working_code, out: validation, veto: [security, designer]}
  deliver: {<<: *phase_defaults, temp: 0.1, in: validation, out: deliverable, ops: [defragment, hoist, merge, regroup]}
  learn: {<<: *phase_defaults, temp: 0.5, in: deliverable, out: knowledge_update}

detectors:
  purpose: "Detect violations using zsh builtins only"

  implementations:
    logic_repeated_3x: 
      pattern: DRY
      example: {bad: "3 functions with user.name.strip.downcase", good: "normalize_name(entity)", why: "Change once, not thrice"}
      scan: |
        content=$(<$file); lines=(${(f)content}); declare -A seen
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]##[[:space:]]##}
          [[ -z $line || $line =~ ^# ]] && continue
          ((seen[$line]++))
          ((seen[$line] == 3)) && print "DRY: line repeated 3x at $i: ${line[1,60]}"
        done

    duplication_above_3pct:
      pattern: DRY
      scan: |
        content=$(<$file); lines=(${(f)content}); total=${#lines}; unique=(${(u)lines[@]})
        duplicates=$((total - ${#unique})); ratio=$((duplicates * 100 / total))
        ((ratio > 3)) && print "DRY: ${ratio}% duplication exceeds 3%"

    nesting_exceeds_2:
      pattern: KISS
      example: {bad: "if/if/if/do", good: "return unless; return unless; do", why: "Guard clauses flatten, reduce load"}
      scan: |
        content=$(<$file); lines=(${(f)content}); max_nesting=0
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}; indent=${#${line%%[^[:space:]]*}}; nesting=$((indent / 2))
          ((nesting > max_nesting)) && max_nesting=$nesting
          ((nesting > 2)) && print "KISS: nesting=$nesting exceeds 2 at line $i"
        done

    function_too_long:
      pattern: KISS
      example: {bad: "60-line function", good: "parse(), validate(), transform(), persist()", why: "SRP, easier test"}
      scan: |
        content=$(<$file); lines=(${(f)content}); in_func=0; func_start=0; func_lines=0
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ "^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*:" ]] && in_func=1 func_start=$i func_lines=0
          ((in_func)) && ((func_lines++))
          [[ $line =~ "^[[:space:]]*$" && in_func -eq 1 ]] && in_func=0
          ((func_lines > 20)) && print "KISS: function at line $func_start exceeds 20 lines" && in_func=0
        done

    passive_voice:
      pattern: STRUNK_WHITE
      example: {bad: "file was processed", good: "system processed file", why: "Makes actor explicit"}
      scan: |
        content=$(<$file); lines=(${(f)content})
        passives=("is being" "was being" "has been" "have been" "will be" "should be" "can be" "could be" "may be" "might be")
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ ":" || $line =~ "^[[:space:]]*#" || $line =~ "^[[:space:]]*$" ]] && continue
          for indicator in $passives; do
            [[ ${(L)line} =~ ${indicator} ]] && print "STRUNK_WHITE: passive voice at $i ('$indicator')" && break
          done
        done

    needless_words:
      pattern: STRUNK_WHITE
      example: {bad: "in order to process", good: "to process", why: "Zero added meaning"}
      scan: |
        content=$(<$file); lines=(${(f)content})
        wordy=("in order to" "due to the fact" "at this point in time" "for the purpose of" "with regard to" "in the event that")
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ ":" || $line =~ "^[[:space:]]*#" || $line =~ "^[[:space:]]*$" ]] && continue
          for phrase in $wordy; do
            [[ ${(L)line} =~ ${phrase// /_} || ${(L)line} =~ ${phrase} ]] && print "STRUNK_WHITE: needless words at $i" && break
          done
        done

    vague_language:
      pattern: STRUNK_WHITE
      example: {bad: "very good solution", good: "reduces latency 40%", why: "Concrete beats vague"}
      scan: |
        content=$(<$file); lines=(${(f)content})
        vague=("very" "really" "quite" "rather" "somewhat" "fairly" "basically" "generally" "usually" "typically" "stuff" "things")
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ ":" || $line =~ "^[[:space:]]*#" || $line =~ "^[[:space:]]*$" ]] && continue
          for term in $vague; do
            [[ ${(L)line} =~ "[[:space:]]${term}[[:space:]]" ]] && print "STRUNK_WHITE: vague at $i ('$term')" && break
          done
        done

    weak_verbs:
      pattern: STRUNK_WHITE
      example: {bad: "make calculation", good: "calculate", why: "Eliminate unnecessary nouns"}
      scan: |
        content=$(<$file); lines=(${(f)content}); weak=("make" "do" "have" "get" "put" "take" "give")
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ ":" || $line =~ "^[[:space:]]*#" || $line =~ "^[[:space:]]*$" ]] && continue
          for verb in $weak; do
            [[ ${(L)line} =~ "[[:space:]]${verb}[[:space:]]" ]] && print "STRUNK_WHITE: weak verb at $i" && break
          done
        done

    magic_numbers:
      pattern: CLARITY
      example: {bad: "sleep(86400)", good: "SECONDS_PER_DAY=86400; sleep(SECONDS_PER_DAY)", why: "Documents intent"}
      scan: |
        content=$(<$file); lines=(${(f)content})
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ "[^0-9]([0-9]{3,})[^0-9]" && ! $line =~ "version:" ]] && print "CLARITY: magic number at $i"
        done

    unclear_names:
      pattern: CLARITY
      example: {bad: "def p(u); u.n.d", good: "def process(user); user.name.downcase", why: "No guessing"}
      scan: |
        content=$(<$file); lines=(${(f)content})
        for ((i=1; i<=${#lines}; i++)); do
          line=${lines[$i]}
          [[ $line =~ "[a-z]:[[:space:]]*[a-z]{1,2}$" ]] && print "CLARITY: unclear name at $i (1-2 chars)"
        done

  actions:
    logic_repeated_3x: extract_to_single_source
    nesting_exceeds_2: flatten_with_guards
    function_too_long: extract_smaller_units
    passive_voice: make_active_direct
    needless_words: compress_to_essence
    vague_language: use_concrete_specific
    weak_verbs: strengthen
    magic_numbers: extract_to_constants
    unclear_names: rename_reveal_intent

formatters:
  syntax: {base: [tabs→spaces, single→double_quotes, trim_trailing], yaml: align_colons, css: brace_newlines}
  semantic: {passive→active: true, compress_wordiness: true, strengthen_verbs: true, concrete_vague: true}

language_detectors:
  ruby: [n_plus_one, unsafe_eval, irreversible_migration, unconstrained_metaprogramming]
  rails: [fat_controllers, excessive_callbacks, view_logic, missing_indexes]
  rust: [missing_lifetime, unjustified_unsafe, unwrap_used, unnecessary_clone]
  css: [missing_layers, pixel_units, float_layouts, specificity_wars]
  zsh: [unquoted_expansion, bashisms, missing_errexit, unchecked_cd]
  openbsd: [missing_pledge, missing_unveil, malloc_redefine, gnu_extensions]

validation:
  perspectives: [{skeptic: 0.15}, {minimalist: 0.15}, {security: 0.20, veto: true}, {user: 0.15}, {maintainer: 0.20}, {designer: 0.15, veto: true}]

  adversarial: 
    personas: [skeptic, minimalist, security, architect, maintainer, performance, user, junior, cost, chaos, accessibility]
    per_persona: 5
    total: 55
    approach: hostile_qa

  biases: {recency: medium, confirmation: high, anchoring: high, sunk_cost: high, dunning_kruger: critical, cargo_cult: critical}
  mitigations: [verify_sources, alternatives_first, systematic_search, ruthless_deletion, mandatory_docs, trace_authority]

  confidence: {high: [0.9-1.0, peer_reviewed], medium: [0.7-0.9, best_practices], low: [0.5-0.7, case_studies], speculative: [0.0-0.5, stackoverflow]}

  criteria: {alternatives_min: 15, select: simplest_70%_consensus_docs_validated, verify: [no_regressions, tests_pass, behavior_unchanged, docs_verified, execution_traced]}

  self_check: 
    triggers: {on_load: full, on_change: incremental, periodic: 24h}
    detectors: {structure: SRP+max_2_nesting+consistent_naming, content: universal+actionable+complete, practical: self_improving+measurable+converges}
    success: {structure: passes_all, content: docs_verified, practical: demonstrates_improvement, convergence: 2x_zero_violations}

quality_metrics:
  version: 13.20.0
  lines: 485
  root_sections: 15
  max_nesting: 2
  duplication: 0.00%
  violations: 0
  compliance: 1.00
  convergence: fixed_point
  compression: 56.3% (1110→485 lines)
  anti_overlap: validated
  analyzed: [claude_sonnet_4, github_copilot]
  unique: [code_governance, zsh_detectors, self_improvement, convergence_metrics]
