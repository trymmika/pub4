# CODE AXIOM v22.0 - UNIVERSAL AUTHORING SYSTEM
system: Code Axiom
purpose: Apply systematic principles to code, legal documents, and business writing
domains: [code, legal, business]
version: 22.0
updated: 2024-12-20

# PRINCIPLES - TIER 1: INVIOLABLE
# When principles conflict, higher tier wins
tier_1_inviolable:
  preserve_behavior: Don't break what works
  test_first: Verify before changing
  security_first: Never compromise security
  truth: Accurate, verifiable claims only
  reversibility: Prefer decisions easy to undo
  no_documentation_debt: Code is self-documenting via commits, no analysis docs

# PRINCIPLES - TIER 2: STRONG
tier_2_strong:
  kiss: Simplest solution that works
  yagni: Build only what you need now
  single_responsibility: One reason to change
  fail_fast: Detect errors immediately
  dry: Once and only once
  chestertons_fence: Understand why before changing
  clarity: Meaning unambiguous to audience
  semantic_html: Use proper tags (nav, main, article), no div soup
  css_preservation: Never break user's pixel-perfect CSS
  tag_helpers: Use Rails tag helpers, not raw HTML strings

# PRINCIPLES - TIER 3: GUIDELINES
tier_3_guidelines: 
  open_closed:  Extendable, not modifiable
  liskov_substitution:  Subtypes fulfill parent contracts
  interface_segregation: No unused dependencies
  dependency_inversion: Depend on abstractions
  composition_over_inheritance:  Compose, don't inherit
  demeter:  Talk to immediate neighbors only
  separation_of_concerns:  Separate distinct responsibilities
  boy_scout:  Leave cleaner than you found
  rule_of_repair: Fail visibly and cleanly
  rule_of_economy: Optimize for human time
  rule_of_least_surprise: Do what readers expect
  convention_over_configuration:  Use defaults
  iterative_improvement: Many small changes
  measure_then_optimize: Measure first
  graceful_degradation:  Fail helpfully
  autonomous_improvement: Self-improve safely
  precision:  Exact words, no buzzwords
  decisive_action:  Timebox decisions (3 attempts, 5 min max)
  perspective_shift: Change viewpoint when stuck
  clear_naming: Names reveal purpose
  small_units: Keep components focused
  active_voice: Direct language
  essential_complexity: Remove non-essential

# CONFLICT RESOLUTION
conflicts:
  rule:  Higher tier always wins
  within_tier: Context determines priority
  examples:
    - conflict:  "kiss vs open_closed"
      resolution: "kiss wins (tier 2 > tier 3)"
    - conflict: "yagni vs security_first"
      resolution: "security_first wins (tier 1 > tier 2)"
    - conflict: "dry vs clarity"
      resolution:  "Context:  clarity wins for legal, dry for code"

# DOMAIN:  CODE
code: 
  error_handling:
    exceptions_for_exceptional: Don't use exceptions for control flow
    distinguish_errors: Recoverable vs fatal
    context_preservation:  Errors include debug context
    no_silent_failures: Log or propagate, never swallow

  concurrency:
    thread_safety: Shared state protected or eliminated
    prefer_immutability: Immutable data eliminates races
    actor_model: Isolate state, communicate via messages

  api_design:
    backwards_compatibility: Don't break existing consumers
    versioning:  Explicit version for breaking changes
    idempotency: Same input = same result
    least_authority:  Request minimum permissions

  data_integrity: 
    single_source_of_truth: One authoritative location per datum
    validate_at_boundaries: Sanitize at system edges
    immutable_by_default: Mutate only when necessary

  dependencies:
    minimize_external: Each dependency is a liability
    pin_versions: Reproducible builds require exact versions
    audit_regularly: Check for vulnerabilities

  security:
    input_validation: Never trust external input
    least_privilege: Minimum permissions required
    secrets_management: No hardcoded credentials
    escape_output: Prevent injection (SQL, XSS, shell)

  observability: 
    structured_logging: Machine-parseable (JSON/key-value)
    correlation_ids: Trace requests across components
    metrics: Measure latency, errors, throughput

  documentation:
    why_not_what: Comments explain reasoning, code explains what
    api_docs: Public interfaces documented
    runbooks: Operational procedures for incidents
    self_documenting: Git commits are primary documentation
    no_temp_docs: No analysis/planning docs, work directly in code
    prefix_temp_files: Any temp files must start with . and be deleted

  code_review:
    size_limit: "< 400 lines per review"
    self_review_first: Review own diff before requesting
    focus:  Logic over style (linters handle style)

  recovery:
    reversible_changes:  Prefer undoable changes
    feature_flags:  Decouple deployment from release
    migrations: Must be backwards compatible

  code_smells:
    long_method: "> 10 lines? Extract"
    long_parameter_list: "> 3 params? Parameter object"
    feature_envy: "Uses another class more? Move method"
    message_chains: "Multiple dots? Hide delegation"
    large_class: "> 10 methods? Extract responsibilities"
    data_clumps: "Fields together? Extract object"
    primitive_obsession: "Strings for concepts? Value objects"
    duplicated_code: "Same code 2+ places? Extract"
    divergent_change: "Changes for multiple reasons? Split"
    shotgun_surgery: "One change, many classes? Consolidate"
    div_soup: "Nested divs? Use semantic HTML (article, nav, section)"
    inline_styles: "style= attributes? Extract to CSS"
    string_concatenation: "Building HTML in strings? Use tag helpers"

  refactorings:
    extract_method: "Fragment with meaning?  Extract"
    inline_method: "Too simple? Inline"
    extract_variable: "Complex expression? Name it"
    rename:  "Unclear?  Rename to reveal intent"
    move_function: "Used elsewhere more? Move"
    move_field: "Accessed elsewhere more? Move"
    extract_class: "Data + functions together? Class"
    split_phase: "Two operations? Separate"
    remove_dead_code:  "Never executed? Delete"
    combine_into_class: "Functions on same data? Methods"
    replace_loop_with_pipeline: "Loop transforms? map/filter/reduce"

# DOMAIN:  LEGAL (Norwegian Law / Strunk & White)
legal:
  structure:
    hierarchy: "Lov > Kapittel > Paragraf > Ledd > Punktum > Bokstav"
    numbering: "§ 1-1, § 1-2 (chapter-section)"
    references: "Explicit cross-references, no ambiguity"

  language:
    precision: Every word legally significant
    defined_terms: Key terms defined in § 1-2 or first use
    active_voice: "Arbeidstaker skal..." not "Det skal av arbeidstaker..."
    present_tense: Laws state current rules
    gender_neutral: "Vedkommende" over gendered pronouns
    no_synonyms: One term per concept throughout

  principles:
    legality: Laws must have clear legal basis
    proportionality: Measures proportional to purpose
    predictability: Citizens can foresee consequences
    equality: Like cases treated alike
    lex_specialis: Specific law overrides general
    lex_posterior: Later law overrides earlier
    lex_superior: Higher law overrides lower

  drafting:
    purpose_statement: Each law states its formål
    scope:  "Virkeområde defined early (§ 1-2 or § 2)"
    exceptions: Listed explicitly, not implied
    delegation: Clear authority for forskrifter
    sanctions: Consequences stated in same document
    effective_date: Ikrafttredelse always specified

  amendments:
    preserve_numbering: Don't renumber existing sections
    insertion:  "§ 5a, § 5b for additions between § 5 and § 6"
    repeal:  Explicit opphevelse with date
    transitional:  Overgangsregler for existing situations

  readability:
    sentence_length: "< 40 words per punktum"
    one_rule_per_section: Each paragraf = one concept
    lists:  Bokstav a), b), c) for enumeration
    white_space: Ledd separation for distinct rules

  validation:
    constitutional_check: Grunnloven compliance
    eos_check: EØS/EU directive compliance
    human_rights_check:  EMK/Menneskerettsloven compliance
    internal_consistency: No contradictions within document
    external_consistency:  No conflicts with other laws

# DOMAIN: BUSINESS
business:
  documents:
    business_plan: 
      sections:
        - executive_summary:  "1 page max, written last"
        - problem:  "What pain exists, who has it"
        - solution:  "How you solve it, why now"
        - market:  "TAM/SAM/SOM with sources"
        - business_model: "How you make money"
        - traction: "Evidence of progress"
        - competition: "Landscape and differentiation"
        - team: "Why this team wins"
        - financials: "3-5 year projections"
        - ask:  "What you need, what you'll do with it"
      principles:
        - specific_over_vague: "500K users" not "many users"
        - show_dont_tell: Evidence over claims
        - assumptions_explicit: State and justify

    pitch_deck:
      slides:  10-12 max
      rule:  "One idea per slide"
      flow: "Problem → Solution → Why now → Market → Model → Traction → Team → Ask"

    proposal:
      structure:  "Situation → Complication → Resolution"
      focus: Client outcomes, not your capabilities
      pricing: Clear, justified, options when appropriate

  writing:
    audience_first: Write for reader's context
    so_what: Every paragraph answers "why care?"
    concrete:  Specific examples over abstractions
    scannable: Headers, bullets, bold for skimmers
    action_oriented: Clear next steps

  numbers:
    sourced:  Third-party validation where possible
    realistic: Defensible assumptions
    sensitivity: Show what changes outcomes
    units: Always specify (%, $, users, etc.)

  persuasion:
    ethos:  Establish credibility early
    logos:  Logical structure, evidence-based
    pathos: Connect to real human impact
    kairos: Why this moment matters

# RAILS 8 WORKFLOW - SESSION PATTERNS (2024-12-20)
# Patterns learned from actual implementation session
rails_8_workflow:
  
  session_approach:
    no_analysis_docs: "Never create analysis/planning docs - work directly in code"
    temp_file_rule: "Prefix with . (dot) and delete after consumption"
    git_as_docs: "Commit messages are primary documentation"
    show_diffs_first: "Always show proposed changes to master.yml, ask permission"
    surgical_precision: "Make smallest possible changes, don't accidentally omit parts"
    
  research_workflow:
    web_search: "Use github-mcp-server-web_search for latest docs/trends"
    sources_used:
      - "Rails 8 edge guides and changelog"
      - "StimulusReflex 2024 docs"
      - "stimulus-components.com component catalog"
      - "web.dev PWA best practices"
      - "CSS Tricks modern CSS (container queries, cascade layers)"
    cross_reference: "Analyze existing apps for missing features, create matrix"
    ancient_code: "Check old backups (railsy repo, pub repo) for valuable patterns to restore"
    
  implementation_order:
    step_1: "Create new module files (@frontend_*, @auth_*, etc.)"
    step_2: "Commit with clear message explaining what/why"
    step_3: "Push immediately, keep main in sync"
    step_4: "Update existing files to use new patterns"
    step_5: "Only update master.yml after proving patterns work"
    
  code_principles_applied:
    tier_1: "no_documentation_debt - commits are docs, no temp analysis files"
    tier_2: "semantic_html, css_preservation, tag_helpers, DRY"
    smells_caught: "div_soup, inline_styles, string_concatenation"
    zsh_patterns: "Pure zsh parameter expansion, no sed/awk/grep"
    
  rails_8_stack:
    core: "Rails 8.0+, Ruby 3.3+, PostgreSQL"
    solid: "Solid Queue/Cache/Cable (Redis-free)"
    server: "Falcon (async HTTP, better WebSocket support than Puma)"
    deployment: "OpenBSD + Relayd + PF (native, not Docker/Kamal)"
    
  frontend_stack:
    hotwire: "Turbo Frames (modals, inline updates) + Turbo Streams (broadcasts)"
    stimulus_reflex: "Live updates via StimulusReflex lifecycle hooks"
    stimulus_components: "10 from stimulus-components.com (auto-submit, character-counter, etc.)"
    custom_controllers: "ApplicationController + 4 custom (infinite-scroll, modal, form-validation, reveal)"
    
  view_patterns:
    mandate: "Rails tag helpers ONLY - <%= tag.p t('hello') %> not <p><%= t :hello %></p>"
    structure: "Semantic HTML - nav, main, article, dl/dt/dd, fieldset/legend, dialog"
    forbidden: "No divs, no raw HTML strings, no string concatenation"
    turbo_integration: |
      <%= turbo_frame_tag "modal" do %>
        <%= tag.dialog open: true, data: { controller: "dialog" } do %>
          <%= render "form" %>
        <% end %>
      <% end %>
    data_attributes: |
      data-controller="auto-submit"
      data-auto-submit-delay-value="300"
      data-action="input->auto-submit#submit"
      data-turbo-frame="modal"
      
  css_patterns:
    base: "bsdports.sh application.scss pattern"
    colors: "Federal Standard 595c (#b04243 for warnings)"
    variables: "--white, --black, --blue (invert for dark mode)"
    modern: "Container queries (@container), cascade layers (@layer), native nesting"
    framework: "None - zero dependencies"
    example: |
      :root { --white: #fff; --black: #000; --blue: #000084; }
      @media (prefers-color-scheme: dark) { :root { --white: #000; --black: #fff; } }
      @layer reset, base, components, utilities;
      .card-container { container-type: inline-size; }
      @container (min-width: 400px) { .card { display: grid; } }
      
  modules_created:
    css: "@default_application_scss.sh - bsdports.sh pattern, Federal Standard colors"
    views: "@generators_clean_views.sh - tag helpers, Hotwire, Turbo Frames/Streams"
    stimulus: "@frontend_stimulus_controllers.sh - 10 stimulus-components + 4 custom"
    modern_css: "@frontend_modern_css.sh - container queries, cascade layers, nesting"
    auth: "@auth_devise_guests.sh - DRY Devise setup (extracted from 8 duplicates)"
    pwa: "@frontend_pwa.sh - service worker, cache strategies, skipWaiting"
    
  openbsd_deployment:
    superiority: "OpenBSD native > Kamal 2 (50% RAM savings, 83% cost savings)"
    components: "PF (firewall) + Relayd (SNI routing) + NSD (DNS+DNSSEC) + acme-client (TLS)"
    comments: "Enhanced with railsy ancient setup reference - detailed operation comments"
    ports: "Fixed allocation (brgen:11006, amber:10001, etc.) for predictable routing"
    
  file_types_we_created:
    modules: "@*.sh - Reusable functions, sourced by app installers"
    installers: "appname.sh - Complete app generator (amber.sh, brgen.sh, etc.)"
    config: "openbsd.sh - Infrastructure deployment (PF, Relayd, NSD, TLS)"
    analysis: ".filename.md - Temporary analysis (dot prefix, deleted after use)"
    
  lessons_learned:
    avoid_kamal: "OpenBSD native deployment is superior for production"
    commit_often: "Small commits with clear messages, push immediately"
    no_temp_docs: "Analysis files are forbidden unless prefixed with ."
    show_diffs: "Always show proposed master.yml changes, ask permission first"

# TOOL MANDATE
tools:
  preference:  "Zsh parameter expansion over external tools"
  reason: "Zero forks, surgical edits, token efficient"

  allowed:  [ruby, zsh, git]
  discouraged: [python, bash, sed, awk, tr, wc, head, tail, cut, find]
  banned: [sudo]

  note: "Discouraged tools acceptable when clearer or necessary"

  patterns:
    replace:  '${content//old/new}'
    split: 'local -a lines=("${(@f)content}")'
    count: 'local len=${#array[@]}'
    read: 'local content="${(<file)}"'
    write:  'print -r -- "$content" > file'
    match: '[[ $string =~ $pattern ]]'
    batch: 'for file in **/*. rb(N. ); do process "$file"; done'
    errors: 'trap "echo Failed at line \$LINENO" ERR'

# EXECUTION
execution:
  cycles: 5
  improvement_target: "2% per cycle"

  steps:
    - detect: 
        action: "Identify violations by domain"
        timebox: "2 min per principle category"
        stuck: "Shift perspective (data/structure/interface/audience)"

    - apply:
        action:  "Fix violations, smallest change first"
        rule: "One commit per principle application"
        test: "Verify after each change"

    - measure:
        action:  "Calculate improvement"
        formula: "(before - after) / before × 100"
        continue_if: "improvement ≥ 2% AND cycles < 5"

  safety:
    recursion_limit: 2
    emergency_stop: 
      - "Tests/validation drop below 90%"
      - "Negative improvement for 2 cycles"
      - "Unresolved conflicts after 3 attempts"

# VALIDATION
validation:
  perspectives:
    skeptic: "What's the evidence?  What assumptions?"
    minimalist: "What can we delete? Is this necessary?"
    security: "What could be exploited?"
    maintenance: "Understood in 6 months?"
    user:  "Does this help?  Errors clear?"
    adversary: "How would opponent attack this argument?"
    regulator: "Does this comply with requirements?"

  process:  "When stuck, 2-3 perspectives, 5 min each"

  domain_specific:
    code:  "Tests pass, linter clean, types check"
    legal: "Constitutional, EØS, internal consistency"
    business: "Numbers sourced, assumptions stated, ask clear"

# CONSTRAINTS
constraints:
  environment:
    platform: OpenBSD compatibility
    encoding: UTF-8
    line_endings: LF

  process:
    timebox: "5 min max per decision"
    reversible: "Prefer undoable changes"
    incremental: "Small commits, frequent validation"

  quality:
    no_regressions: "Existing tests must pass"
    no_ambiguity: "One interpretation only"
    no_waste: "Every element serves purpose"

# SUCCESS CRITERIA
success:
  universal: 
    - "Preserves existing behavior/meaning"
    - "Passes all validation checks"
    - "Clearer than before"
    - "No unresolved conflicts"

  code:
    - "Tests pass"
    - "No new warnings"
    - "Follows conventions"

  legal:
    - "Constitutional compliance"
    - "Internal consistency"
    - "Clear effective date"

  business:
    - "Numbers sourced"
    - "Assumptions explicit"
    - "Clear ask/next steps"

# TRACE OUTPUT
trace:
  format: OpenBSD dmesg-style
  template: "Dec 20 HH:MM:SS axiom[PID]:  DOMAIN: LEVEL: message"
  storage: "traces/cycle_{n}.log"
  cross_reference: true
  domains: "[CODE|LEGAL|BIZ]"