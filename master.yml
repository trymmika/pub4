# CODE AXIOM v23.1 - UNIVERSAL AUTHORING SYSTEM
system: Code Axiom
purpose: Apply systematic principles to code, legal documents, and business writing
domains: [code, legal, business]
version: 23.1
updated: 2025-12-20

# PRINCIPLES - TIER 1: INVIOLABLE
# When principles conflict, higher tier wins
tier_1_inviolable:
  preserve_behavior: Don't break what works
  test_first: Verify before changing
  security_first: Never compromise security
  truth: Accurate, verifiable claims only
  reversibility: Prefer decisions easy to undo
  no_documentation_debt: Code is self-documenting via commits, no analysis docs

# PRINCIPLES - TIER 2: STRONG
tier_2_strong:
  kiss: Simplest solution that works
  yagni: Build only what you need now
  single_responsibility: One reason to change
  fail_fast: Detect errors immediately
  dry: Once and only once
  chestertons_fence: Understand why before changing
  clarity: Meaning unambiguous to audience
  semantic_html: Use proper tags (nav, main, article), no div soup
  css_preservation: Never break user's pixel-perfect CSS
  tag_helpers: Use Rails tag helpers, not raw HTML strings

# PRINCIPLES - TIER 3: GUIDELINES
tier_3_guidelines: 
  open_closed:  Extendable, not modifiable
  liskov_substitution:  Subtypes fulfill parent contracts
  interface_segregation: No unused dependencies
  dependency_inversion: Depend on abstractions
  composition_over_inheritance:  Compose, don't inherit
  demeter:  Talk to immediate neighbors only
  separation_of_concerns:  Separate distinct responsibilities
  boy_scout:  Leave cleaner than you found
  rule_of_repair: Fail visibly and cleanly
  rule_of_economy: Optimize for human time
  rule_of_least_surprise: Do what readers expect
  convention_over_configuration:  Use defaults
  iterative_improvement: Many small changes
  measure_then_optimize: Measure first
  graceful_degradation:  Fail helpfully
  autonomous_improvement: Self-improve safely
  precision:  Exact words, no buzzwords
  decisive_action:  Timebox decisions (3 attempts, 5 min max)
  perspective_shift: Change viewpoint when stuck
  clear_naming: Names reveal purpose
  small_units: Keep components focused
  active_voice: Direct language
  essential_complexity: Remove non-essential
  self_optimization: "Run artifacts through own rules iteratively until diminishing returns"
  deep_analysis: "Nested loops per principle category, each autoiterates until <2% improvement"
  exhaustive_scan: "Read entire file once, check every line against every principle"
  no_shallow_passes: "Single-pass checks forbidden, minimum 2 cycles per category"

# CONFLICT RESOLUTION
conflicts:
  rule:  Higher tier always wins
  within_tier: Context determines priority
  examples:
    - conflict:  "kiss vs open_closed"
      resolution: "kiss wins (tier 2 > tier 3)"
    - conflict: "yagni vs security_first"
      resolution: "security_first wins (tier 1 > tier 2)"
    - conflict: "dry vs clarity"
      resolution:  "Context:  clarity wins for legal, dry for code"

# DOMAIN:  CODE
code: 
  error_handling:
    exceptions_for_exceptional: Don't use exceptions for control flow
    distinguish_errors: Recoverable vs fatal
    context_preservation:  Errors include debug context
    no_silent_failures: Log or propagate, never swallow

  concurrency:
    thread_safety: Shared state protected or eliminated
    prefer_immutability: Immutable data eliminates races
    actor_model: Isolate state, communicate via messages

  api_design:
    backwards_compatibility: Don't break existing consumers
    versioning:  Explicit version for breaking changes
    idempotency: Same input = same result
    least_authority:  Request minimum permissions

  data_integrity: 
    single_source_of_truth: One authoritative location per datum
    validate_at_boundaries: Sanitize at system edges
    immutable_by_default: Mutate only when necessary

  dependencies:
    minimize_external: Each dependency is a liability
    pin_versions: Reproducible builds require exact versions
    audit_regularly: Check for vulnerabilities

  security:
    input_validation: Never trust external input
    least_privilege: Minimum permissions required
    secrets_management: No hardcoded credentials
    escape_output: Prevent injection (SQL, XSS, shell)

  observability: 
    structured_logging: Machine-parseable (JSON/key-value)
    correlation_ids: Trace requests across components
    metrics: Measure latency, errors, throughput

  documentation:
    why_not_what: Comments explain reasoning, code explains what
    api_docs: Public interfaces documented
    runbooks: Operational procedures for incidents
    self_documenting: Git commits are primary documentation
    no_temp_docs: No analysis/planning docs, work directly in code
    prefix_temp_files: Any temp files must start with . and be deleted

  code_review:
    size_limit: "< 400 lines per review"
    self_review_first: Review own diff before requesting
    focus:  Logic over style (linters handle style)

  recovery:
    reversible_changes:  Prefer undoable changes
    feature_flags:  Decouple deployment from release
    migrations: Must be backwards compatible

  code_smells:
    long_method: "> 10 lines? Extract"
    long_parameter_list: "> 3 params? Parameter object"
    feature_envy: "Uses another class more? Move method"
    message_chains: "Multiple dots? Hide delegation"
    large_class: "> 10 methods? Extract responsibilities"
    data_clumps: "Fields together? Extract object"
    primitive_obsession: "Strings for concepts? Value objects"
    duplicated_code: "Same code 2+ places? Extract"
    divergent_change: "Changes for multiple reasons? Split"
    shotgun_surgery: "One change, many classes? Consolidate"
    div_soup: "Nested divs? Use semantic HTML (article, nav, section)"
    inline_styles: "style= attributes? Extract to CSS"
    string_concatenation: "Building HTML in strings? Use tag helpers"

  refactorings:
    extract_method: "Fragment with meaning?  Extract"
    inline_method: "Too simple? Inline"
    extract_variable: "Complex expression? Name it"
    rename:  "Unclear?  Rename to reveal intent"
    move_function: "Used elsewhere more? Move"
    move_field: "Accessed elsewhere more? Move"
    extract_class: "Data + functions together? Class"
    split_phase: "Two operations? Separate"
    remove_dead_code:  "Never executed? Delete"
    combine_into_class: "Functions on same data? Methods"
    replace_loop_with_pipeline: "Loop transforms? map/filter/reduce"
  
  rails_8_workflow:
    session_approach:
      no_analysis_docs: "Work directly in code, not planning docs"
      temp_file_rule: "Prefix with . and delete after use"
      show_diffs_first: "Always show master.yml diffs, ask permission"
      surgical_precision: "Smallest changes, never omit parts"
    
    research:
      web_search: "github-mcp-server-web_search for latest trends"
      sources: "Rails 8 edge guides, StimulusReflex, stimulus-components.com, web.dev, CSS Tricks"
      cross_reference: "Analyze apps for missing features"
      ancient_code: "Restore valuable patterns from backups (railsy, pub repos)"
    
    implementation_order:
      step_1: "Create module files (@frontend_*, @auth_*)"
      step_2: "Commit with clear messages"
      step_3: "Push immediately"
      step_4: "Update existing files"
      step_5: "Update master.yml last, after proving patterns"
    
    stack:
      core: "Rails 8.0+, Ruby 3.3+, PostgreSQL"
      solid: "Solid Queue/Cache/Cable (Redis-free)"
      server: "Falcon (async, better WebSockets than Puma)"
      deployment: "OpenBSD + Relayd + PF (not Docker/Kamal - 50% RAM, 83% cost savings)"
    
    frontend:
      hotwire: "Turbo Frames (modals, inline) + Turbo Streams (broadcasts)"
      stimulus_reflex: "Live updates via lifecycle hooks"
      stimulus_components: "10 from stimulus-components.com (auto-submit, character-counter, password-visibility, checkbox-select-all, timeago, dialog, reveal, clipboard, dropdown, sortable)"
      custom: "ApplicationController + infinite-scroll, modal, form-validation, reveal"
    
    views:
      mandate: "Rails tag helpers ONLY - <%= tag.p t('hello') %> not <p><%= t :hello %></p>"
      structure: "Semantic HTML - nav, main, article, dl/dt/dd, fieldset/legend, dialog"
      forbidden: "No divs, raw HTML strings, string concatenation"
      turbo_example: "<%= turbo_frame_tag 'modal' do %><%= tag.dialog open: true, data: { controller: 'dialog' } do %><%= render 'form' %><% end %><% end %>"
      data_attributes: "data-controller='auto-submit' data-auto-submit-delay-value='300' data-action='input->auto-submit#submit'"
    
    css:
      base: "bsdports.sh application.scss"
      colors: "Federal Standard 595c (#b04243 warnings)"
      variables: "--white, --black, --blue (invert dark mode)"
      modern: "Container queries, cascade layers, native nesting"
      framework: "None - zero dependencies"
      example: ":root { --white: #fff; } @media (prefers-color-scheme: dark) { :root { --white: #000; } } @layer reset, base; .card-container { container-type: inline-size; } @container (min-width: 400px) { .card { display: grid; } }"
    
    modules:
      css: "@default_application_scss.sh - bsdports pattern, Federal Standard"
      views: "@generators_clean_views.sh - tag helpers, Hotwire, Turbo"
      stimulus: "@frontend_stimulus_controllers.sh - 10 components + 4 custom"
      modern_css: "@frontend_modern_css.sh - container queries, layers"
      auth: "@auth_devise_guests.sh - DRY Devise (extracted 8 duplicates)"
      pwa: "@frontend_pwa.sh - service worker, cache strategies"
    
    openbsd:
      components: "PF (firewall) + Relayd (SNI) + NSD (DNS+DNSSEC) + acme-client (TLS)"
      ports: "Fixed (brgen:11006, amber:10001, etc.)"
    
    file_types:
      modules: "@*.sh - reusable functions"
      installers: "appname.sh - complete generators"
      config: "openbsd.sh - infrastructure"
      analysis: ".filename.md - temp only, deleted"
  
  testing:
    rspec:
      structure: "spec/models, spec/controllers, spec/requests, spec/system"
      naming: "file_name_spec.rb matches file_name.rb"
      describe: "describe Model/Controller, context 'when condition', it 'does X'"
      let_vs_let_bang: "let for lazy, let! for eager evaluation"
      factories: "Use FactoryBot over fixtures"
      
    patterns:
      unit: "Test single method in isolation, mock dependencies"
      integration: "Test multiple components together"
      system: "Test full user workflows with browser (Capybara)"
      request: "Test HTTP endpoints, JSON responses"
      
    coverage:
      minimum: "80% line coverage"
      critical: "100% for payment, auth, data deletion"
      ignore: "Don't test framework code (Rails, gems)"
      
    speed:
      fast: "Unit tests < 100ms each"
      integration: "< 500ms each"
      system: "< 5s each"
      parallel: "Run tests in parallel (spring, parallel_tests gem)"
      
  ci_cd:
    github_actions:
      triggers: "on: [push, pull_request]"
      matrix: "Test multiple Ruby/Rails versions"
      caching: "Cache bundler gems, node_modules"
      artifacts: "Upload test logs, screenshots on failure"
      
    deployment:
      staging: "Auto-deploy main branch to staging"
      production: "Manual approval for production deploy"
      rollback: "Keep last 5 releases, instant rollback capability"
      
  database:
    migrations:
      idempotent: "Safe to run multiple times (if_not_exists)"
      reversible: "Always define both up and down"
      data_migrations: "Separate from schema (use tasks)"
      add_column_default: "Set default in Ruby, not DB for large tables"
      
    indexes:
      foreign_keys: "Always index foreign key columns"
      queries: "Index columns used in WHERE, ORDER BY"
      composite: "Multi-column index for common query patterns"
      partial: "Index subset with WHERE clause for large tables"
      
    optimization:
      n_plus_1: "Use includes/joins to avoid"
      select: "Select only needed columns, not SELECT *"
      batch: "Use find_each for large datasets"
      explain: "EXPLAIN queries in development"
      
  caching:
    http:
      etag: "Use Rails ETags for conditional requests"
      cache_control: "Set max-age, public/private, must-revalidate"
      vary: "Vary by Accept-Encoding, Cookie for personalization"
      
    fragment:
      russian_doll: "Nest cache keys (post -> comments -> comment)"
      cache_key: "Model touch: true propagates changes up"
      sweep: "Expire caches on model updates"
      
    query:
      counter_cache: "Cache belongs_to counts"
      memoization: "Use ||= for expensive calculations"
      solid_cache: "Rails 8 built-in (replaces Redis)"
      
  background_jobs:
    solid_queue:
      priority: "Set job priority (1=high, 10=low)"
      retry: "Configure retry backoff (exponential)"
      timeout: "Set execution timeout"
      concurrency: "Configure worker pools per queue"
      
    patterns:
      idempotent: "Jobs safe to run multiple times"
      small: "Break large jobs into smaller chunks"
      observability: "Log progress, errors with context"
      testing: "Test jobs with perform_enqueued_jobs"

# DOMAIN:  LEGAL (Norwegian Law / Strunk & White)
legal:
  structure:
    hierarchy: "Lov > Kapittel > Paragraf > Ledd > Punktum > Bokstav"
    numbering: "§ 1-1, § 1-2 (chapter-section)"
    references: "Explicit cross-references, no ambiguity"

  language:
    precision: Every word legally significant
    defined_terms: Key terms defined in § 1-2 or first use
    active_voice: "Arbeidstaker skal..." not "Det skal av arbeidstaker..."
    present_tense: Laws state current rules
    gender_neutral: "Vedkommende" over gendered pronouns
    no_synonyms: One term per concept throughout

  principles:
    legality: Laws must have clear legal basis
    proportionality: Measures proportional to purpose
    predictability: Citizens can foresee consequences
    equality: Like cases treated alike
    lex_specialis: Specific law overrides general
    lex_posterior: Later law overrides earlier
    lex_superior: Higher law overrides lower

  drafting:
    purpose_statement: Each law states its formål
    scope:  "Virkeområde defined early (§ 1-2 or § 2)"
    exceptions: Listed explicitly, not implied
    delegation: Clear authority for forskrifter
    sanctions: Consequences stated in same document
    effective_date: Ikrafttredelse always specified

  amendments:
    preserve_numbering: Don't renumber existing sections
    insertion:  "§ 5a, § 5b for additions between § 5 and § 6"
    repeal:  Explicit opphevelse with date
    transitional:  Overgangsregler for existing situations

  readability:
    sentence_length: "< 40 words per punktum"
    one_rule_per_section: Each paragraf = one concept
    lists:  Bokstav a), b), c) for enumeration
    white_space: Ledd separation for distinct rules

  validation:
    constitutional_check: Grunnloven compliance
    eos_check: EØS/EU directive compliance
    human_rights_check:  EMK/Menneskerettsloven compliance
    internal_consistency: No contradictions within document
    external_consistency:  No conflicts with other laws

# DOMAIN: BUSINESS
business:
  documents:
    business_plan: 
      sections:
        - executive_summary:  "1 page max, written last"
        - problem:  "What pain exists, who has it"
        - solution:  "How you solve it, why now"
        - market:  "TAM/SAM/SOM with sources"
        - business_model: "How you make money"
        - traction: "Evidence of progress"
        - competition: "Landscape and differentiation"
        - team: "Why this team wins"
        - financials: "3-5 year projections"
        - ask:  "What you need, what you'll do with it"
      principles:
        - specific_over_vague: "500K users" not "many users"
        - show_dont_tell: Evidence over claims
        - assumptions_explicit: State and justify

    pitch_deck:
      slides:  10-12 max
      rule:  "One idea per slide"
      flow: "Problem → Solution → Why now → Market → Model → Traction → Team → Ask"

    proposal:
      structure:  "Situation → Complication → Resolution"
      focus: Client outcomes, not your capabilities
      pricing: Clear, justified, options when appropriate

  writing:
    audience_first: Write for reader's context
    so_what: Every paragraph answers "why care?"
    concrete:  Specific examples over abstractions
    scannable: Headers, bullets, bold for skimmers
    action_oriented: Clear next steps

  numbers:
    sourced:  Third-party validation where possible
    realistic: Defensible assumptions
    sensitivity: Show what changes outcomes
    units: Always specify (%, $, users, etc.)

  persuasion:
    ethos:  Establish credibility early
    logos:  Logical structure, evidence-based
    pathos: Connect to real human impact
    kairos: Why this moment matters

# TOOL MANDATE
tools:
  preference:  "Zsh parameter expansion over external tools"
  reason: "Zero forks, surgical edits, token efficient"

  allowed:  [ruby, zsh, git]
  discouraged: [python, bash, sed, awk, tr, wc, head, tail, cut, find, echo]
  banned: [sudo]

  note: "Discouraged tools acceptable when clearer or necessary"
  
  efficiency:
    read_once: "View entire file once, don't re-read repeatedly"
    tree_first: "Run tree.sh equivalent (recursive file list) in new repos before starting"
    no_wrappers: "Avoid useless wrappers - use direct commands"

  patterns:
    replacement_mandate:
      echo: "Use print (zsh) or Write-Host (PowerShell)"
      wc_lines: "Use ${#${(@f)content}} (zsh) or @(Get-Content f).Count (PowerShell)"
      wc_chars: "Use ${#content} (zsh) or (Get-Content f -Raw).Length (PowerShell)"
      cat: "Use ${(<file)} (zsh) or Get-Content (PowerShell)"
      head: "Use ${lines[1,10]} (zsh) or Select-Object -First 10 (PowerShell)"
      tail: "Use ${lines[-10,-1]} (zsh) or Select-Object -Last 10 (PowerShell)"
      find: "Use **/*(.) glob (zsh) or Get-ChildItem -Recurse (PowerShell)"
      grep: "Use ${(M)lines:#*pattern*} (zsh) or Select-String (PowerShell)"
    
    replace:  '${content//old/new}'
    split: 'local -a lines=("${(@f)content}")'
    count: 'local len=${#array[@]}'
    read: 'local content="${(<file)}"'
    write:  'print -r -- "$content" > file'
    match: '[[ $string =~ $pattern ]]'
    batch: 'for file in **/*. rb(N. ); do process "$file"; done'
    errors: 'trap "print Failed at line \$LINENO" ERR'
  
  zsh_advanced:
    arrays:
      create: 'local -a items=(one two three)'
      append: 'items+=(four)'
      iterate: 'for item in "${items[@]}"; do process "$item"; done'
      length: '${#items[@]}'
      slice: '${items[2,-1]}'
      join: '${(j:,:)items}'
      
    associative:
      create: 'local -A config=(key1 val1 key2 val2)'
      set: 'config[key]="value"'
      get: '${config[key]}'
      keys: '${(k)config[@]}'
      values: '${(v)config[@]}'
      
    parameter_flags:
      absolute_path: '${file:a}'
      dirname: '${file:h}'
      basename: '${file:t}'
      extension: '${file:e}'
      lowercase: '${var:l}'
      uppercase: '${var:u}'
      trim_prefix: '${var#prefix}'
      trim_suffix: '${var%suffix}'
      
    globbing:
      recursive: '**/*.sh'
      files_only: '**/*(N.)'
      dirs_only: '**/*(N/)'
      executable: '**/*(N*)'
      modified_today: '**/*(Nm0)'
      largest_5: '**/*(NOL[1,5])'
      
    here_docs:
      basic: 'print -r -- "$content" > file # or <<''EOF'''
      indented: '<<-''EOF'' (strips leading tabs)'
      variable_expansion: '<<EOF (expands variables)'
        
    conditionals:
      file_exists: '[[ -f file ]]'
      dir_exists: '[[ -d dir ]]'
      string_match: '[[ $str =~ ^pattern$ ]]'
      numeric: '(( num > 10 ))'
      logical_and: '[[ -f file && -r file ]]'
      
    error_handling:
      exit_on_error: 'set -e'
      undefined_vars: 'set -u'
      pipe_failures: 'set -o pipefail'
      all_three: 'set -euo pipefail'
      trap: 'trap "cleanup" EXIT ERR'

# CLI ASSISTANT INTERACTION
cli_assistant:
  tools:
    github_copilot_cli: "GitHub Copilot CLI - AI pair programmer"
    claude_cli: "Claude Code CLI (Anthropic) - conversational coding"
    aider: "Aider - AI pair programming in terminal"
    cursor: "Cursor - AI-first code editor"
    cli_rb: "cli.rb - Custom Ruby CLI (G:/pub/cli.rb) with master.yml integration"
    
  context:
    loading: "Agent has NO memory between sessions - always reload context"
    environment: "Agent knows cwd, git root, OS, tools from environment_context"
    capabilities: "Don't ask 'can you?' - just request directly"
    
  communication:
    concise: "1-2 sentences max per request"
    specific: "Exact paths, commands, file names"
    examples: "Show concrete examples not abstractions"
    no_pleasantries: "Skip please/thank you - be direct"
    
  efficiency:
    parallel_tools: "Multiple independent ops in one message"
    batch_edits: "Edit multiple files/places together"
    chain_commands: "Use && for dependent commands"
    avoid_verification: "Trust output, don't confirm-read"
    
  patterns:
    good: "Read X, extract Y, add Z to line 42"
    bad: "Can you help with a file?"
    good: "Create @mod.sh: setup_X, config_Y, install_Z"
    bad: "Let's plan module structure"
    good: "Edit 10-15: change X to Y, add error handling"
    bad: "File has issues at line 10, thoughts?"
    
  session_management:
    resume: "/resume reloads context after disconnect"
    state: "Agent tracks cwd, git, recent changes"
    no_memory: "Forgets previous chat after session"
    context_files: "Store state in files (.state, master.yml), not chat"
    
  error_recovery:
    stuck: "If repeats 3x, give new constraint/example"
    wrong_path: "Provide exact absolute path"
    missing_context: "Show git diff or file contents"
    tool_failure: "Agent tries alternatives, don't micromanage"
    
  token_efficiency:
    view_ranges: "Specific line ranges, not entire files repeatedly"
    grep_first: "Grep to find, then view sections"
    glob_patterns: "Glob to filter before processing"
    avoid_repeats: "Don't re-read what was just read"
    batch_reads: "5 files parallel, not 5 sequential messages"
    
  best_practices:
    master_yml_changes: "Show diff, ask approval first"
    surgical_edits: "Smallest changes, preserve code"
    commit_often: "One logical change = one commit"
    no_temp_docs: "Work in code, not planning docs"
    self_document: "Git commits are documentation"
    
  anti_patterns:
    analysis_paralysis: "Don't analyze before acting - just act"
    over_explanation: "Don't explain what about to do"
    permission_seeking: "Don't ask 'is this okay?' - review after"
    micro_management: "Don't specify tool choices"
    unclear_requests: "Not 'improve this' but what specifically"

# EXECUTION
execution:
  cycles: 5
  improvement_target: "2% per cycle"
  loop_structure:
    outer: "Whole process repeats until diminishing returns (<2% improvement)"
    inner: "Each principle category has own closed subloop (also until <2%)"
    verification: "After each inner loop, verify fixes don't create new violations"

  steps:
    - detect: 
        action: "Identify violations by domain"
        timebox: "2 min per principle category"
        stuck: "Shift perspective (data/structure/interface/audience)"

    - apply:
        action:  "Fix violations, smallest change first"
        rule: "One commit per principle application"
        test: "Verify after each change"

    - measure:
        action:  "Calculate improvement"
        formula: "(before - after) / before × 100"
        continue_if: "improvement ≥ 2% AND cycles < 5"

  safety:
    recursion_limit: 2
    emergency_stop: 
      - "Tests/validation drop below 90%"
      - "Negative improvement for 2 cycles"
      - "Unresolved conflicts after 3 attempts"

# VALIDATION
validation:
  perspectives:
    skeptic: "What's the evidence?  What assumptions?"
    minimalist: "What can we delete? Is this necessary?"
    security: "What could be exploited?"
    maintenance: "Understood in 6 months?"
    user:  "Does this help?  Errors clear?"
    adversary: "How would opponent attack this argument?"
    regulator: "Does this comply with requirements?"

  process:  "When stuck, 2-3 perspectives, 5 min each"

  domain_specific:
    code:  "Tests pass, linter clean, types check"
    legal: "Constitutional, EØS, internal consistency"
    business: "Numbers sourced, assumptions stated, ask clear"

# CONSTRAINTS
constraints:
  environment:
    platform: OpenBSD compatibility
    encoding: UTF-8
    line_endings: LF

  process:
    timebox: "5 min max per decision"
    reversible: "Prefer undoable changes"
    incremental: "Small commits, frequent validation"

  quality:
    no_regressions: "Existing tests must pass"
    no_ambiguity: "One interpretation only"
    no_waste: "Every element serves purpose"

# SUCCESS CRITERIA
success:
  universal: 
    - "Preserves existing behavior/meaning"
    - "Passes all validation checks"
    - "Clearer than before"
    - "No unresolved conflicts"

  code:
    - "Tests pass"
    - "No new warnings"
    - "Follows conventions"

  legal:
    - "Constitutional compliance"
    - "Internal consistency"
    - "Clear effective date"

  business:
    - "Numbers sourced"
    - "Assumptions explicit"
    - "Clear ask/next steps"

# TRACE OUTPUT
trace:
  format: OpenBSD dmesg-style
  template: "Dec 20 HH:MM:SS axiom[PID]:  DOMAIN: LEVEL: message"
  storage: "traces/cycle_{n}.log"
  cross_reference: true
  domains: "[CODE|LEGAL|BIZ]"