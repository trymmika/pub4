<!DOCTYPE html>
<html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Loader Orb</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;overflow:hidden}
body{background:#000}
canvas{position:fixed;inset:0;width:100%;height:100%;image-rendering:pixelated;image-rendering:crisp-edges}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// 8-bit palette
const PAL=[];
for(let r=0;r<6;r++)for(let g=0;g<7;g++)for(let b=0;b<6;b++)PAL.push([r*51,g*42,b*51]);
for(let i=0;i<4;i++)PAL.push([i*85,i*85,i*85]);

function quantize(r,g,b){
  let best=PAL[0],minD=Infinity;
  for(const c of PAL){const d=(r-c[0])**2+(g-c[1])**2+(b-c[2])**2;if(d<minD){minD=d;best=c}}
  return best;
}

const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
let w,h,scale=2,audio=0,time=0,mood='neutral';

const MOODS={
  neutral:{c1:[0,80,85],c2:[0,206,209],c3:[64,224,208]},
  positive:{c1:[0,100,100],c2:[72,209,204],c3:[127,255,212]},
  negative:{c1:[0,60,65],c2:[0,139,139],c3:[32,178,170]},
  calm:{c1:[0,80,85],c2:[0,206,209],c3:[64,224,208]},
  excited:{c1:[0,120,120],c2:[0,255,255],c3:[127,255,212]}
};

let particles=[];

function resize(){
  w=Math.floor(window.innerWidth/scale);
  h=Math.floor(window.innerHeight/scale);
  canvas.width=w;canvas.height=h;
}

function spawnParticle(cx,cy,radius){
  const angle=Math.random()*Math.PI-Math.PI/2;
  const dist=Math.random()*radius*0.6;
  particles.push({
    x:cx+Math.cos(angle+Math.PI/2)*dist,
    y:cy+radius-3,
    vy:-1.5-Math.random()*3-audio*4,
    vx:(Math.random()-0.5)*1.2,
    life:0.6+Math.random()*0.4,
    size:1+Math.random()*1.5
  });
}

function draw(){
  time+=0.016;
  const m=MOODS[mood]||MOODS.neutral;
  const cx=w/2,baseY=h*0.55;
  const bounce=Math.sin(time*2)*8;
  const cy=baseY+bounce;
  const radius=Math.min(w,h)*0.15+audio*10;
  
  // Pure black background
  ctx.fillStyle='#000';
  ctx.fillRect(0,0,w,h);
  
  const img=ctx.getImageData(0,0,w,h);
  
  // Shadow under orb
  const shadowY=Math.floor(h*0.7);
  const shadowW=radius*1.5;
  const shadowH=radius*0.15;
  for(let y=shadowY-shadowH;y<shadowY+shadowH;y++){
    for(let x=cx-shadowW;x<cx+shadowW;x++){
      const dx=(x-cx)/shadowW,dy=(y-shadowY)/shadowH;
      if(dx*dx+dy*dy<1){
        const alpha=0.3*(1-Math.sqrt(dx*dx+dy*dy));
        const i=(Math.floor(y)*w+Math.floor(x))*4;
        if(i>=0&&i<img.data.length-3){
          img.data[i]=Math.floor(img.data[i]*(1-alpha));
          img.data[i+1]=Math.floor(img.data[i+1]*(1-alpha));
          img.data[i+2]=Math.floor(img.data[i+2]*(1-alpha));
          img.data[i+3]=255;
        }
      }
    }
  }
  
  // Spawn particles - more frequent, smaller bursts!
  const spawnCount=3+Math.floor(audio*8);
  for(let s=0;s<spawnCount;s++){
    if(Math.random()<0.7)spawnParticle(cx,cy,radius);
  }
  
  // Update and draw particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx;p.y+=p.vy;
    p.life-=0.015;
    if(p.life<=0){particles.splice(i,1);continue}
    
    const alpha=p.life*0.8;
    const t=1-p.life;
    const r=m.c2[0]+t*(m.c3[0]-m.c2[0]);
    const g=m.c2[1]+t*(m.c3[1]-m.c2[1]);
    const b=m.c2[2]+t*(m.c3[2]-m.c2[2]);
    const size=Math.floor(p.size*p.life);
    
    for(let dy=-size;dy<=size;dy++){
      for(let dx=-size;dx<=size;dx++){
        if(dx*dx+dy*dy<=size*size){
          const px=Math.floor(p.x+dx),py=Math.floor(p.y+dy);
          if(px>=0&&px<w&&py>=0&&py<h){
            const q=quantize(r*alpha,g*alpha,b*alpha);
            const idx=(py*w+px)*4;
            img.data[idx]=Math.min(255,img.data[idx]+q[0]);
            img.data[idx+1]=Math.min(255,img.data[idx+1]+q[1]);
            img.data[idx+2]=Math.min(255,img.data[idx+2]+q[2]);
          }
        }
      }
    }
  }
  
  // Draw main orb with gradient
  for(let y=cy-radius;y<cy+radius;y++){
    for(let x=cx-radius;x<cx+radius;x++){
      const dx=x-cx,dy=y-cy;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<radius){
        const t=dist/radius;
        const angle=Math.atan2(dy,dx);
        
        // Gradient blend between colors
        const blend=(Math.sin(angle)+1)/2;
        const r=m.c1[0]+(m.c2[0]-m.c1[0])*t+(m.c3[0]-m.c2[0])*blend*0.5;
        const g=m.c1[1]+(m.c2[1]-m.c1[1])*t+(m.c3[1]-m.c2[1])*blend*0.5;
        const b=m.c1[2]+(m.c2[2]-m.c1[2])*t+(m.c3[2]-m.c2[2])*blend*0.5;
        
        // Highlight
        const hlX=-0.3,hlY=-0.4;
        const hlDist=Math.sqrt((dx/radius-hlX)**2+(dy/radius-hlY)**2);
        const hl=Math.max(0,1-hlDist*2)*0.4;
        
        const dith=((Math.floor(x)+Math.floor(y))%2)*10-5;
        const q=quantize(r+hl*150+dith,g+hl*150+dith,b+hl*150+dith);
        const i=(Math.floor(y)*w+Math.floor(x))*4;
        if(i>=0&&i<img.data.length-3){
          img.data[i]=q[0];img.data[i+1]=q[1];img.data[i+2]=q[2];img.data[i+3]=255;
        }
      }
    }
  }
  
  ctx.putImageData(img,0,0);
  if(particles.length>100)particles.splice(0,20);
  requestAnimationFrame(draw);
}

navigator.mediaDevices?.getUserMedia({audio:true}).then(s=>{
  const ac=new AudioContext(),src=ac.createMediaStreamSource(s),an=ac.createAnalyser();
  an.fftSize=256;src.connect(an);
  const data=new Uint8Array(an.frequencyBinCount);
  (function loop(){
    an.getByteFrequencyData(data);
    let sum=0;for(let i=0;i<50;i++)sum+=data[i];
    audio=sum/50/255;
    requestAnimationFrame(loop);
  })();
}).catch(()=>{});

mood=new URLSearchParams(location.search).get('mood')||'neutral';
window.addEventListener('message',e=>{if(e.data?.mood)mood=e.data.mood});
resize();
window.addEventListener('resize',resize);
draw();
</script>
</body>
</html>
