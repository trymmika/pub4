# Generation templates - code style and boilerplate
---
style:
  - No comments unless necessary
  - Minimal whitespace
  - Semantic naming
  - No dependencies unless essential

html:
  rules:
    - Semantic HTML5
    - No div soup
    - Minimal attributes
  template: |
    <!doctype html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width">
      <title>%{title}</title>
      <link rel="stylesheet" href="style.css">
    </head>
    <body>
      <header><h1>%{title}</h1></header>
      <main>%{content}</main>
    </body>
    </html>

css:
  rules:
    - CSS custom properties
    - System font stack
    - Mobile-first
    - Dark mode via prefers-color-scheme
  template: |
    :root { --bg: #fff; --fg: #111; --accent: #06f; --mono: ui-monospace, monospace; --sans: system-ui, sans-serif; }
    @media (prefers-color-scheme: dark) { :root { --bg: #111; --fg: #eee; } }
    * { box-sizing: border-box; margin: 0; }
    body { font: 1rem/1.5 var(--sans); background: var(--bg); color: var(--fg); max-width: 60ch; margin: auto; padding: 2rem; }

ruby:
  rules:
    - Frozen string literals
    - Guard clauses over nested ifs
    - Modules over classes when no state
  template: |
    # frozen_string_literal: true
    module %{name}
      def self.call(input)
        return if input.nil?
        process(input)
      end
      def self.process(data) = data
    end

shell:
  rules:
    - "#!/bin/sh for portability"
    - set -eu
    - Quote all variables
    - Meaningful exit codes
  template: |
    #!/bin/sh
    set -eu
    main() { %{body} }
    main "$@"

yaml:
  rules:
    - Top-level keys are sections
    - Max 3 levels deep
    - Defaults inline
