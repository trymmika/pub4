MASTER2 v2.0 Pipeline Architecture
================================================================================

                          INTERACTIVE REPL
                         ┌─────────────────┐
                         │   bin/master    │
                         │  Ruby + TTY     │
                         │  OpenRouter API │
                         └─────────────────┘


                         PIPELINE STAGES
================================================================================

Input → 7-Stage Pipeline → Output

┌──────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│  ┌──────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐              │
│  │  Intake  │──▶│  Guard  │──▶│  Route  │──▶│ Debate  │              │
│  │ Compress │   │ Safety  │   │  Task   │   │Chamber  │              │
│  │ Context  │   │Firewall │   │Classify │   │Council  │              │
│  └──────────┘   └─────────┘   └─────────┘   └─────────┘              │
│       │              │              │              │                    │
│       │              │              │              ▼                    │
│       │              │              │         ┌──────────┐             │
│       │              │              └────────▶│   Ask    │             │
│       │              │                        │  LLM.ask │             │
│       │              │                        │OpenRouter│             │
│       │              │                        └──────────┘             │
│       │              │                             │                    │
│       ▼              ▼                             ▼                    │
│  ┌──────────────────────────────────────────────────────┐             │
│  │                  POST-PROCESSING                      │             │
│  ├──────────┬──────────┬──────────┬──────────┬──────────┤             │
│  │   Lint   │ Render   │ Axioms   │ Learning │  Hooks   │             │
│  │ Validate │ Format   │ Enforce  │ Capture  │ Trigger  │             │
│  │  Output  │Markdown  │ Quality  │ Feedback │ Events   │             │
│  └──────────┴──────────┴──────────┴──────────┴──────────┘             │
│       │          │          │          │          │                    │
│       └──────────┴──────────┴──────────┴──────────┘                    │
│                            │                                            │
│                            ▼                                            │
│                      Final Output                                      │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘


                        DATA FLOW EXAMPLE
================================================================================

User Input:
  "Refactor this Ruby class for clarity"

      ↓ Intake (Stage 1)
  
  {
    text: "Refactor Ruby class clarity",        ← compressed
    original_length: 42,
    compressed_length: 30
  }

      ↓ Guard (Stage 2)
  
  {
    text: "Refactor Ruby class clarity",
    safe: true,                                  ← safety check
    violations: []
  }

      ↓ Route (Stage 3)
  
  {
    text: "Refactor Ruby class clarity",
    task_type: :code_refactor,                  ← classified
    tier: :strong,                               ← complexity assessed
    executor_pattern: :pre_act                   ← reasoning pattern
  }

      ↓ Debate (Stage 4) [Optional]
  
  {
    text: "Refactor Ruby class clarity",
    council_votes: [sonnet, deepseek, gemini],
    consensus: 0.85,                             ← agreement level
    synthesized: "Extract method, simplify..."
  }

      ↓ Ask (Stage 5)
  
  {
    response: "Here's the refactored class...", ← LLM response
    model: "anthropic/claude-sonnet-4",
    cost: 0.024,
    tokens_in: 512,
    tokens_out: 1024
  }

      ↓ Lint (Stage 6)
  
  {
    response: "Here's the refactored class...",
    axioms_checked: 12,                          ← quality validation
    violations: [],
    quality_score: 0.94
  }

      ↓ Render (Stage 7)
  
  Here's the refactored class...                 ← formatted output


                          STATE MANAGEMENT
================================================================================

                         ┌─────────────────┐
                         │  JSONL Files    │
                         │  (Append-only)  │
                         └─────────────────┘
                                │
           ┌────────────────────┼────────────────────┐
           │                    │                    │
      ┌─────────┐          ┌─────────┐         ┌─────────┐
      │ axioms  │          │ costs   │         │circuits │
      │personas │          │sessions │         │ learnings│
      │ config  │          │ memory  │         │  hooks  │
      └─────────┘          └─────────┘         └─────────┘


                       DELIBERATION ENGINES
================================================================================

MASTER2 provides four distinct deliberation engines:

1. Chamber - Code refinement via multi-model debate
   • Models debate proposed changes
   • Arbiter synthesizes consensus
   • Cost: ~$0.10-0.50 per deliberation

2. CreativeChamber - Creative ideation for concepts/multimedia
   • Brainstorming with multiple perspectives
   • Image/video generation via Replicate
   • Cost: ~$0.50-2.00 per session

3. Council - Opinion/judgment with fixed member roles
   • Fixed personas (philosopher, rebel, analyst)
   • Role-based strengths
   • Cost: ~$0.05-0.25 per consultation

4. Swarm - Generate many variations, curate best
   • Parallel generation
   • Scoring and ranking
   • Cost: variable based on count


                      CIRCUIT BREAKER PATTERN
================================================================================

Model Request → Success? → Record Cost
                  │
                  No (Failure)
                  │
                  ▼
            Record Failure
                  │
                  ▼
            Failures >= 3?
                  │
                  Yes
                  │
                  ▼
            Mark Circuit OPEN
                  │
                  ▼
        Auto-Downgrade to Next Tier


                         EXECUTOR PATTERNS
================================================================================

MASTER2 Executor supports 4 reasoning patterns:

1. ReAct - Reason + Act cycles
   • Best for: Sequential tasks
   • Steps: Observe → Reason → Act → Repeat

2. Pre-Act - Plan first, then execute
   • Best for: Complex multi-step tasks
   • Steps: Analyze → Plan → Execute

3. ReWOO - Reasoning WithOut Observation
   • Best for: Parallel operations
   • Steps: Plan all → Execute all

4. Reflexion - Self-reflection and correction
   • Best for: Quality-critical tasks
   • Steps: Try → Evaluate → Reflect → Retry


                           SHELL USAGE
================================================================================

Start interactive REPL:
  $ cd MASTER2
  $ bin/master

Direct commands:
  $ bin/master ask "What is SOLID?"
  $ bin/master refactor code.rb
  $ bin/master council "Should we add this feature?"


                         TESTING STRATEGY
================================================================================

Each module is independently testable:

  test/test_llm.rb           → API integration
  test/test_pipeline.rb      → Stage composition
  test/test_chamber.rb       → Multi-model debate
  test/test_executor.rb      → Reasoning patterns
  test/test_axioms.rb        → Quality enforcement

Run tests:
  $ rake test
  $ ruby test/test_llm.rb


                            METRICS
================================================================================

Code Organization:
  Modules:       60+ files
  Avg size:      ~200 lines per file
  Max file:      ~875 lines (executor.rb)
  
Key Features:
  • Multi-tier model fallbacks (premium/strong/fast/cheap)
  • Cost tracking with $10 spending cap
  • Circuit breaker for failing models
  • Result monad for error handling
  • 32 axioms for code quality
  • 4 reasoning patterns
  • 4 deliberation engines
  • Session persistence
  • Constitutional governance


                      UNIX PHILOSOPHY ✓
================================================================================

✓ Do one thing well       Each module has single responsibility
✓ Modularity             Clean interfaces, loose coupling
✓ Composition            Modules compose via Result monad
✓ Text streams           JSONL for data persistence
✓ Small, focused         Most files under 300 lines
✓ Clear is better        Explicit over implicit
✓ Fail gracefully        Result monad handles errors
✓ Test everything        Comprehensive test coverage
