#!/usr/bin/env ruby
# frozen_string_literal: true

# Force UTF-8 encoding
Encoding.default_external = Encoding::UTF_8
Encoding.default_internal = Encoding::UTF_8
$stdout.set_encoding(Encoding::UTF_8)
$stderr.set_encoding(Encoding::UTF_8)

# CLI flags
if ARGV.delete("--verbose")
  ENV["MASTER_TRACE"] = "3"
elsif ARGV.delete("--quiet") || ARGV.delete("-q")
  ENV["MASTER_TRACE"] = "0"
end

require_relative "../lib/single_instance"
require "digest"
require "tmpdir"

def enforce_single_master!(command)
  return if %w[help -h --help version -v --version].include?(command)

  root_hash = Digest::SHA256.hexdigest(File.expand_path("..", __dir__))[0, 12]
  lock_path = ENV["MASTER_LOCK_PATH"] || File.join(Dir.tmpdir, "master2-#{root_hash}.lock")
  MASTER::SingleInstance.acquire(lock_path: lock_path)
rescue MASTER::SingleInstance::AlreadyRunningError => e
  $stderr.puts e.message
  $stderr.puts "Set MASTER_ALLOW_MULTI=1 to bypass this guard intentionally."
  exit 1
end

command = ARGV[0]
args = ARGV[1..-1] || []
enforce_single_master!(command)

# Auto-bundle install if gems missing
ENV["BUNDLE_GEMFILE"] = File.expand_path("../Gemfile", __dir__)
ENV["GEM_HOME"] ||= File.expand_path("~/.local/share/gem/ruby/#{RUBY_VERSION[0..2]}")
ENV["PATH"] = "#{ENV["GEM_HOME"]}/bin:#{ENV["PATH"]}" unless ENV["PATH"].include?("#{ENV["GEM_HOME"]}/bin")
begin; require "bundler/setup"; rescue Bundler::GemNotFound, Bundler::GitError => e; $stderr.puts "MASTER2 boot: missing gems, running bundle install..."; system("bundle", "install", "--quiet", exception: false) || ($stderr.puts("MASTER2 boot: bundle install failed: #{e.message}"); exit 1); retry; end
require "json"
require_relative "../lib/master"

begin
  MASTER::DB.setup
rescue StandardError => e
  $stderr.puts "DB setup failed: #{e.message} — running without persistence"
end
MASTER::Session.install_crash_handlers

case command
when "refactor"
  # Direct refactoring: master refactor file.rb
  if args.empty?
    puts "Usage: master refactor <file> [--preview|--raw|--apply]"
    exit 1
  end
  result = MASTER::Commands.refactor(args.join(" "))
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)

when "fix"
  # Batch fixing: master fix --all, master fix file.rb
  arg_str = args.join(" ")
  MASTER::Commands.fix_code(arg_str)
when "scan"
  # Directory scanning: master scan deploy/rails/
  path = args.first || "."
  result = MASTER::Commands.opportunities(path)
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)
when "chamber"
  # Open specific chamber: master chamber ruby
  if args.empty?
    puts "Usage: master chamber <file>"
    exit 1
  end
  result = MASTER::Commands.chamber(args.join(" "))
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)
when "ideate", "brainstorm"
  # Generate alternatives: master ideate "authentication system"
  if args.empty?
    puts "Usage: master ideate <topic>"
    exit 1
  end
  result = MASTER::Commands.ideate(args.join(" "))
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)
when "evolve"
  # Evolve codebase: master evolve
  result = MASTER::Commands.evolve(args.join(" "))
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)

when "browse"
  # Web browser: master browse <url>
  if args.empty?
    puts "Usage: master browse <url>"
    exit 1
  end
  MASTER::Commands.browse_url(args.join(" "))

when "speak", "say"
  # Voice interaction: master speak <text>
  MASTER::Commands.speak(args.join(" "))

when "session"
  # Session management: master session show, master session save
  MASTER::Commands.manage_session(args.join(" "))

when "health"
  # System health: master health
  MASTER::Commands.print_health

when "opportunities", "opps"
  # Code improvements: master opportunities file.rb
  path = args.first
  result = MASTER::Commands.opportunities(path)
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)
when "style-guides", "styleguides"
  result = MASTER::Commands.style_guides(args.join(" "))
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)

when "multi-refactor", "mrefactor"
  # Multi-file refactoring: master multi-refactor deploy/rails/
  path = args.first || "."
  dry_run = !args.include?("--apply")
  strict = args.include?("--strict")
  align_axioms = strict || args.include?("--axioms")
  include_all = args.include?("--all-files")
  mr = MASTER::MultiRefactor.new(
    dry_run: dry_run,
    force_rewrite: strict,
    align_axioms: align_axioms,
    include_all_files: include_all
  )
  result = mr.run(path: path)
  exit result.ok? ? 0 : 1 if result.respond_to?(:ok?)

when "axioms-stats", "stats"
  # Statistics: master axioms-stats
  MASTER::Commands.print_axiom_stats

when "selfrun", "self-run"
  # Full self-run: analyze and refactor the entire pub4 repo
  puts "MASTER2 Self-Run: Analyzing entire pub4 repository..."
  pub4_root = File.expand_path("../..", __dir__)  # Go up from MASTER2/bin/ to pub4/
  strict = args.include?("--strict")
  align_axioms = strict || args.include?("--axioms")
  include_all = args.include?("--all-files")
  apply = args.include?("--apply")

  # Phase 1: Self-refactor MASTER2 itself
  puts "\n=== Phase 1: Self-Refactoring MASTER2 ==="
  mr = MASTER::MultiRefactor.new(
    dry_run: !apply,
    budget_cap: 1.0,
    force_rewrite: strict,
    align_axioms: align_axioms,
    include_all_files: include_all
  )
  phase1_path = include_all ? File.join(pub4_root, "MASTER2") : File.join(pub4_root, "MASTER2", "lib")
  mr.run(path: phase1_path)

  # Phase 2: Deploy scripts
  puts "\n=== Phase 2: Deploy Scripts ==="
  mr2 = MASTER::MultiRefactor.new(
    dry_run: !apply,
    budget_cap: 1.0,
    force_rewrite: strict,
    align_axioms: align_axioms,
    include_all_files: include_all
  )
  mr2.run(path: File.join(pub4_root, "deploy"))

  # Phase 3: Business plans (HTML)
  puts "\n=== Phase 3: Business Plans ==="
  mr3 = MASTER::MultiRefactor.new(
    dry_run: !apply,
    budget_cap: 0.5,
    force_rewrite: strict,
    align_axioms: align_axioms,
    include_all_files: include_all
  )
  mr3.run(path: File.join(pub4_root, "bp"))

  # Phase 4: Self-test
  puts "\n=== Phase 4: Self-Test ==="
  MASTER::Introspection.run if defined?(MASTER::Introspection)

  exit 0

when "version", "-v", "--version"
  puts "MASTER2 v#{MASTER::VERSION}"
  exit 0

when "help", "-h", "--help"
  puts <<~HELP
    MASTER2 - Constitutional AI Code Quality System

    Usage:
      master [command] [arguments]

    Commands:
      refactor <file>             Refactor file with LLM guidance
      multi-refactor [path]       Refactor directory (add: --apply --strict --axioms --all-files)
      selfrun [--apply]           Full self-run across pub4 (add: --strict --axioms --all-files)
      fix [--all|<path>]          Fix violations in files or directory
      scan [directory]            Scan for code smells (default: .)
      chamber <file>              Chamber review with multi-model deliberation
      ideate <topic>              Generate 15+ alternatives for a topic
      evolve [args]               Evolve entire codebase
      browse <url>                Browse and extract web content
      speak <text>                Text-to-speech output
      session <cmd>               Session management (replay|ls|diff|export)
      cache [stats|clear]         Semantic cache management
      health                      System health check
      opportunities [path]        Find improvement opportunities
      style-guides [sync]         List or sync style guide repos
      axioms-stats                Display axiom violation statistics
      version                     Show version
      help                        Show this help

    Legacy Options:
      -w, --web                   Start web-only mode (no REPL)
      -p, --pipe                  Pipe mode for automation
      -t, --tts [TOPIC]           TTS test mode
      -d, --daemon                Daemon mode for agentd

    Examples:
      master refactor deploy/openbsd/openbsd.sh
      master fix --all
      master scan deploy/rails/
      master chamber lib/master.rb
      master ideate "authentication system"
      master session save milestone-1

    Environment Variables:
      OPENROUTER_API_KEY          Required for LLM operations
      MASTER_VOICE                Enable voice mode (true/false)
      MASTER_DEBUG                Debug logging (true/false)

    Documentation:
      https://github.com/anon987654321/pub4/tree/main/MASTER2

    No command specified starts REPL mode with integrated web server.
  HELP
  exit 0

when "--web", "-w"
  # Web-only mode (no REPL)
  web_port = args.first&.to_i
  web_port = nil if web_port == 0
  server = MASTER::Server.new(port: web_port)
  MASTER::Boot.banner_with_web(server.port)
  server.start
  puts "Press Ctrl+C to stop"
  sleep

when "--pipe", "-p"
  # Pipe mode for automation
  input = JSON.parse($stdin.read) rescue { "text" => $stdin.read }
  result = MASTER::Pipeline.new.call(input)
  puts JSON.generate(result.ok? ? result.value : { error: result.error })

when "--tts", "-t"
  # TTS test mode - continuous talking (Windows/Cygwin)
  topic = ARGV[1]&.to_sym || :master
  puts "Starting continuous TTS (#{topic})... Ctrl+C to stop"
  MASTER::Speech.chatter(topic: topic)

when "--daemon", "-d"
  # Daemon mode for agentd
  require_relative "../sbin/agentd" if File.exist?(File.join(__dir__, "../sbin/agentd"))

when "schedule"
  # Job scheduler: master schedule list|add|remove|enable|disable
  subcmd = args.shift
  MASTER::Scheduler.load
  case subcmd
  when "list"
    jobs = MASTER::Scheduler.list
    if jobs.empty?
      puts "No scheduled jobs"
    else
      jobs.each { |j| puts "#{j[:id]}  #{j[:enabled] ? '✓' : '✗'}  every #{j[:interval]}s  #{j[:command]}" }
    end
  when "add"
    cmd = args[0]
    interval = (args[1] || "3600").to_i
    result = MASTER::Scheduler.add(cmd, interval: interval)
    puts result.ok? ? "Scheduled: #{result.value[:job_id]}" : result.error
  when "remove"
    result = MASTER::Scheduler.remove(args[0])
    puts result.ok? ? "Removed" : result.error
  when "enable"
    result = MASTER::Scheduler.enable(args[0])
    puts result.ok? ? "Enabled" : result.error
  when "disable"
    result = MASTER::Scheduler.disable(args[0])
    puts result.ok? ? "Disabled" : result.error
  else
    puts "Usage: master schedule list|add <cmd> [interval_sec]|remove <id>|enable <id>|disable <id>"
  end
  exit 0

when "heartbeat"
  # Heartbeat control: master heartbeat start|stop|status
  subcmd = args.shift
  case subcmd
  when "start"
    interval = (args[0] || "60").to_i
    MASTER::Triggers.install_defaults
    MASTER::Scheduler.load
    MASTER::Heartbeat.register("scheduler") { MASTER::Scheduler.tick }
    MASTER::Heartbeat.start(interval: interval)
    puts "Heartbeat started (#{interval}s interval). Press Ctrl+C to stop."
    sleep
  when "stop"
    MASTER::Heartbeat.stop
    puts "Heartbeat stopped"
  when "status"
    s = MASTER::Heartbeat.status
    puts "running=#{s[:running]} interval=#{s[:interval]}s checks=#{s[:checks].size}"
    s[:checks].each { |c| puts "  #{c[:name]} last=#{c[:last_run]} failures=#{c[:failures]}" }
  else
    puts "Usage: master heartbeat start [interval_sec]|stop|status"
  end
  exit 0

when "cache"
  # Cache management: master cache stats|clear
  subcmd = args.first
  if defined?(MASTER::SemanticCache)
    case subcmd
    when "stats"
      stats = MASTER::SemanticCache.stats
      puts "Entries: #{stats[:entries]}, Hits: #{stats[:hits]}, Size: #{stats[:size]}"
    when "clear"
      MASTER::SemanticCache.clear
      puts "Cache cleared"
    else
      puts "Usage: master cache [stats|clear]"
    end
  else
    puts "SemanticCache module not available"
  end
  exit 0

when "policy"
  # Policy profile: master policy [set <profile>]
  subcmd = args.shift
  case subcmd
  when "set"
    result = MASTER::AgentFirewall::Policy.set(args[0]&.to_sym)
    puts result.ok? ? "Policy: #{result.value[:profile]}" : result.error
  else
    puts "Current policy: #{MASTER::AgentFirewall::Policy.current}"
    puts "Available: #{MASTER::AgentFirewall::Policy::PROFILES.keys.join(', ')}"
  end
  exit 0

else
  if command.nil?
    # No command = interactive REPL mode (default)
    server = MASTER::Server.new
    Thread.new { server.start }
    MASTER::Pipeline.repl
  else
    puts "Unknown command: #{command}"
    puts "Run 'master help' for usage information"
    exit 1
  end
end
