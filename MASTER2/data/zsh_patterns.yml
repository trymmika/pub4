# Zsh-native patterns — replace external forks with pure zsh
# Source: pub2/ZSH_NATIVE_PATTERNS.md

forbidden_commands:
  - command: "awk"
    replacement: "zsh array/string field splitting: ${${(s:,:)line}[4]}"
  - command: "sed"
    replacement: "zsh parameter expansion: ${var//search/replace}"
  - command: "tr"
    replacement: "zsh case conversion: ${(L)var} ${(U)var}"
  - command: "grep"
    replacement: "zsh pattern matching: ${(M)arr:#*pattern*}"
  - command: "cut"
    replacement: "zsh field splitting: ${${(s:delim:)var}[N]}"
  - command: "head"
    replacement: "zsh array slicing: ${arr[1,10]}"
  - command: "tail"
    replacement: "zsh array slicing: ${arr[-5,-1]}"
  - command: "uniq"
    replacement: "zsh unique flag: ${(u)arr}"
  - command: "sort"
    replacement: "zsh sort flags: ${(o)arr} ascending, ${(O)arr} descending"
  - command: "bash"
    replacement: "zsh — never use bash"
  - command: "find"
    replacement: "zsh glob qualifiers: **/*.rb(.)"
  - command: "wc"
    replacement: "zsh: ${#var} for length, ${#arr} for count"
  - command: "sudo"
    replacement: "doas on OpenBSD"

native_patterns:
  string_replace: "${var//find/replace}"
  case_lower: "${(L)var}"
  case_upper: "${(U)var}"
  trim_whitespace: "${${var##[[:space:]]#}%%[[:space:]]#}"
  split_to_array: "${(s:delim:)var}"
  array_unique: "${(u)arr}"
  array_sort_asc: "${(o)arr}"
  array_sort_desc: "${(O)arr}"
  array_join: "${(j:,:)arr}"
  array_reverse: "${(Oa)arr}"
  array_filter_match: "${(M)arr:#*pattern*}"
  array_filter_exclude: "${arr:#*pattern*}"
  remove_crlf: "${var//$'\\r'/}"

glob_qualifiers:
  files_only: "**/*.rb(.)"
  dirs_only: "*(/)"
  empty_files: "*(.L0)"
  modified_today: "*(m0)"
  modified_last_hour: "*(mh-1)"
  larger_than_1m: "*(LM+1)"
  executable: "*(*)"
  symlinks: "*(@)"
  owned_by_root: "*(U0)"
  sort_by_size: "*(OL)"
  sort_by_mtime: "*(Om)"
  first_10: "*(.[1,10])"

extended_globbing:
  enable: "setopt extendedglob"
  case_insensitive: "(#i)*.rb"
  negation: "*~*.log"
  numeric_range: "file<1-12>.txt"
  repeat_min: "(#c2,)_"
  approximate: "(#a1)color"
  recursive_no_symlinks: "**/*.rb(.)"

zmv:
  enable: "autoload -Uz zmv"
  rename: "zmv '(*).txt' '$1.md'"
  lowercase: "zmv '(*)' '${(L)1}'"
  add_prefix: "zmv '(*)' 'prefix_$1'"
  dry_run: "zmv -n '(*).old' '$1.new'"

advanced_expansion:
  anchored_start: "${var/#pattern/replacement}"
  anchored_end: "${var/%pattern/replacement}"
  strip_prefix_greedy: "${var##*/}"
  strip_suffix_greedy: "${var%%.*}"
  nested_expansion: "${${var##*/}%.*}"
  length_of_match: "${#var}"
  default_value: "${var:-fallback}"
  assign_default: "${var::=value}"
  substring: "${var[2,5]}"
  reverse: "${(Oa)arr}"
  pad_left: "${(l:8::0:)var}"
  pad_right: "${(r:20:: :)var}"
  word_splitting: "${=var}"
  quote_each: "${(q)var}"
  expand_escapes: "${(e)var}"

exceptions:
  - "Complex regex requiring PCRE"
  - "Binary data processing"

# Banned commands — restored from master.yml v71.3.0
banned_commands: [python, bash, sed, awk, tr, wc, head, tail, cut, find, sudo]

# Auto-remediation — zsh-native replacements for banned commands
auto_remediation:
  sed: "${var//old/new}"
  awk: "${${(s: :)line}[n]}"
  tr: "${(U)var} or ${(L)var}"
  wc: "${#lines}"
  head: "${lines[1,n]}"
  tail: "${lines[-n,-1]}"
  grep: "${(M)lines:#*pattern*}"
  cut: "${${(s:delim:)var}[N]}"
  sort: "${(o)arr} or ${(O)arr}"
  find: "**/*.ext(.)"
  sudo: "doas"

# Token economics — why pure zsh saves LLM tokens
token_economics:
  philosophy: >
    Replacing multi-tool shell pipelines with pure zsh parameter expansion
    eliminates process boundaries, collapses multiple grammars into one,
    reduces reasoning entropy for LLMs, and converts runtime overhead
    into in-memory transforms — saving both tokens and wall-clock time.
  example_bad:
    code: "awk -F, '{print $4}' | sed 's/\\r//g' | tr '[:upper:]' '[:lower:]'"
    cost: "3 grammars, pipes + subshells, I/O transformations"
  example_good:
    code: "cleaned=${var//$'\\r'/}; lower=${(L)cleaned}; fourth=${${(s:,:)lower}[4]}"
    cost: "One grammar, one evaluation model, no process boundaries"
  benefit: "Model reasons locally instead of globally across pipeline"
