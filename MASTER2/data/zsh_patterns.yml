# Zsh-native patterns — replace external forks with pure zsh
# Source: pub2/ZSH_NATIVE_PATTERNS.md

forbidden_commands:
  - command: "awk"
    replacement: "zsh array/string field splitting: ${${(s:,:)line}[4]}"
  - command: "sed"
    replacement: "zsh parameter expansion: ${var//search/replace}"
  - command: "tr"
    replacement: "zsh case conversion: ${(L)var} ${(U)var}"
  - command: "grep"
    replacement: "zsh pattern matching: ${(M)arr:#*pattern*}"
  - command: "cut"
    replacement: "zsh field splitting: ${${(s:delim:)var}[N]}"
  - command: "head"
    replacement: "zsh array slicing: ${arr[1,10]}"
  - command: "tail"
    replacement: "zsh array slicing: ${arr[-5,-1]}"
  - command: "uniq"
    replacement: "zsh unique flag: ${(u)arr}"
  - command: "sort"
    replacement: "zsh sort flags: ${(o)arr} ascending, ${(O)arr} descending"
  - command: "bash"
    replacement: "zsh — never use bash"
  - command: "find"
    replacement: "zsh glob qualifiers: **/*.rb(.)"
  - command: "wc"
    replacement: "zsh: ${#var} for length, ${#arr} for count"
  - command: "sudo"
    replacement: "doas on OpenBSD"

native_patterns:
  string_replace: "${var//find/replace}"
  case_lower: "${(L)var}"
  case_upper: "${(U)var}"
  trim_whitespace: "${${var##[[:space:]]#}%%[[:space:]]#}"
  split_to_array: "${(s:delim:)var}"
  array_unique: "${(u)arr}"
  array_sort_asc: "${(o)arr}"
  array_sort_desc: "${(O)arr}"
  array_join: "${(j:,:)arr}"
  array_reverse: "${(Oa)arr}"
  array_filter_match: "${(M)arr:#*pattern*}"
  array_filter_exclude: "${arr:#*pattern*}"
  remove_crlf: "${var//$'\\r'/}"

exceptions:
  - "Complex regex requiring PCRE"
  - "Multi-file operations beyond globbing"
  - "Binary data processing"

# Banned commands — restored from master.yml v71.3.0
banned_commands: [python, bash, sed, awk, tr, wc, head, tail, cut, find, sudo]

# Auto-remediation — zsh-native replacements for banned commands
auto_remediation:
  sed: "${var//old/new}"
  awk: "${${(s: :)line}[n]}"
  tr: "${(U)var} or ${(L)var}"
  wc: "${#lines}"
  head: "${lines[1,n]}"
  tail: "${lines[-n,-1]}"
  grep: "${(M)lines:#*pattern*}"
  cut: "${${(s:delim:)var}[N]}"
  sort: "${(o)arr} or ${(O)arr}"
  find: "**/*.ext(.)"
  sudo: "doas"

# Token economics — why pure zsh saves LLM tokens
token_economics:
  philosophy: >
    Replacing multi-tool shell pipelines with pure zsh parameter expansion
    eliminates process boundaries, collapses multiple grammars into one,
    reduces reasoning entropy for LLMs, and converts runtime overhead
    into in-memory transforms — saving both tokens and wall-clock time.
  example_bad:
    code: "awk -F, '{print $4}' | sed 's/\\r//g' | tr '[:upper:]' '[:lower:]'"
    cost: "3 grammars, pipes + subshells, I/O transformations"
  example_good:
    code: "cleaned=${var//$'\\r'/}; lower=${(L)cleaned}; fourth=${${(s:,:)lower}[4]}"
    cost: "One grammar, one evaluation model, no process boundaries"
  benefit: "Model reasons locally instead of globally across pipeline"
