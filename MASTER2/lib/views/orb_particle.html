<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Orb Particle</title>
<style>
:root {
  --mint: #5af0b6;
  --mint-dim: #2a7a5a;
  --mint-ghost: #153a2d;
  --bg: #050505;
  --text: #c8d0cc;
  --text-2: #5a6a62;
  --error: #f06050;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: var(--bg);
  overflow: hidden;
  width: 100vw;
  height: 100vh;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

@media (prefers-reduced-motion: reduce) {
  canvas {
    display: none;
  }
  body::after {
    content: 'Animation disabled due to motion preferences';
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100vw;
    height: 100vh;
    color: var(--text-2);
    font-family: monospace;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="orb_shared.js"></script>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let w, h;
function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Additional audio analysis for particle system
let bass = 0;
let mids = 0;
let highs = 0;

// Custom message handler with frequency band support
window.addEventListener('message', function(e) {
  if (e.data && e.data.type === 'state') state = e.data.mode;
  if (e.data && e.data.type === 'audio') {
    audioLevel = e.data.level;
    // Parse audio into frequency bands
    if (e.data.bands) {
      bass = e.data.bands.bass || 0;
      mids = e.data.bands.mids || 0;
      highs = e.data.bands.highs || 0;
    } else {
      // Simulate frequency bands from level if not provided
      bass = audioLevel * (0.3 + Math.random() * 0.2);
      mids = audioLevel * (0.4 + Math.random() * 0.2);
      highs = audioLevel * (0.2 + Math.random() * 0.3);
    }
  }
});

// Boid flocking constants
const SEPARATION_RADIUS = 12;
const ALIGNMENT_RADIUS = 40;
const COHESION_RADIUS = 60;
const MAX_SPEED = 2.0;
const MAX_FORCE = 0.1;
const TRAIL_LENGTH = 8;

class Boid {
  constructor(x, y) {
    this.pos = { x, y };
    this.vel = {
      x: (Math.random() - 0.5) * 2,
      y: (Math.random() - 0.5) * 2
    };
    this.acc = { x: 0, y: 0 };
    this.trail = [];
  }

  edges() {
    if (this.pos.x > w) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = w;
    if (this.pos.y > h) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = h;
  }

  align(boids) {
    let steering = { x: 0, y: 0 };
    let total = 0;
    for (let other of boids) {
      let d = this.distance(other);
      if (other !== this && d < ALIGNMENT_RADIUS) {
        steering.x += other.vel.x;
        steering.y += other.vel.y;
        total++;
      }
    }
    if (total > 0) {
      steering.x /= total;
      steering.y /= total;
      let mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
      if (mag > 0) {
        steering.x = (steering.x / mag) * MAX_SPEED;
        steering.y = (steering.y / mag) * MAX_SPEED;
        steering.x -= this.vel.x;
        steering.y -= this.vel.y;
        mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
        if (mag > MAX_FORCE) {
          steering.x = (steering.x / mag) * MAX_FORCE;
          steering.y = (steering.y / mag) * MAX_FORCE;
        }
      }
    }
    return steering;
  }

  cohesion(boids) {
    let steering = { x: 0, y: 0 };
    let total = 0;
    for (let other of boids) {
      let d = this.distance(other);
      if (other !== this && d < COHESION_RADIUS) {
        steering.x += other.pos.x;
        steering.y += other.pos.y;
        total++;
      }
    }
    if (total > 0) {
      steering.x /= total;
      steering.y /= total;
      steering.x -= this.pos.x;
      steering.y -= this.pos.y;
      let mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
      if (mag > 0) {
        steering.x = (steering.x / mag) * MAX_SPEED;
        steering.y = (steering.y / mag) * MAX_SPEED;
        steering.x -= this.vel.x;
        steering.y -= this.vel.y;
        mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
        if (mag > MAX_FORCE) {
          steering.x = (steering.x / mag) * MAX_FORCE;
          steering.y = (steering.y / mag) * MAX_FORCE;
        }
      }
    }
    return steering;
  }

  separation(boids) {
    let steering = { x: 0, y: 0 };
    let total = 0;
    for (let other of boids) {
      let d = this.distance(other);
      if (other !== this && d < SEPARATION_RADIUS) {
        let diff = {
          x: this.pos.x - other.pos.x,
          y: this.pos.y - other.pos.y
        };
        if (d > 0) {
          diff.x /= d;
          diff.y /= d;
        }
        steering.x += diff.x;
        steering.y += diff.y;
        total++;
      }
    }
    if (total > 0) {
      steering.x /= total;
      steering.y /= total;
      let mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
      if (mag > 0) {
        steering.x = (steering.x / mag) * MAX_SPEED;
        steering.y = (steering.y / mag) * MAX_SPEED;
        steering.x -= this.vel.x;
        steering.y -= this.vel.y;
        mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
        if (mag > MAX_FORCE) {
          steering.x = (steering.x / mag) * MAX_FORCE;
          steering.y = (steering.y / mag) * MAX_FORCE;
        }
      }
    }
    return steering;
  }

  distance(other) {
    let dx = this.pos.x - other.pos.x;
    let dy = this.pos.y - other.pos.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  flock(boids) {
    let separation = this.separation(boids);
    let alignment = this.align(boids);
    let cohesion = this.cohesion(boids);

    // Audio mapping
    let separationWeight = 1.5 + bass * 2.0;
    let alignmentWeight = 1.0 + mids * 1.5;
    let cohesionWeight = 0.8 + highs * 2.5;

    this.acc.x += separation.x * separationWeight;
    this.acc.y += separation.y * separationWeight;
    this.acc.x += alignment.x * alignmentWeight;
    this.acc.y += alignment.y * alignmentWeight;
    this.acc.x += cohesion.x * cohesionWeight;
    this.acc.y += cohesion.y * cohesionWeight;
  }

  update() {
    const params = STATE_PARAMS[state] || STATE_PARAMS.idle;
    
    // Update trail
    this.trail.unshift({ x: this.pos.x, y: this.pos.y });
    if (this.trail.length > TRAIL_LENGTH) {
      this.trail.pop();
    }

    // Update position
    this.vel.x += this.acc.x;
    this.vel.y += this.acc.y;

    // Limit speed
    let speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
    let maxSpeed = MAX_SPEED * params.speed;
    if (speed > maxSpeed) {
      this.vel.x = (this.vel.x / speed) * maxSpeed;
      this.vel.y = (this.vel.y / speed) * maxSpeed;
    }

    this.pos.x += this.vel.x;
    this.pos.y += this.vel.y;
    
    this.acc.x = 0;
    this.acc.y = 0;
  }

  show() {
    const params = STATE_PARAMS[state] || STATE_PARAMS.idle;
    const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
    const intensity = Math.min(1, speed / (MAX_SPEED * params.speed));
    
    // Draw trail with exponential decay
    for (let i = 0; i < this.trail.length; i++) {
      const age = i;
      const opacity = 1.0 * Math.pow(0.7, age);
      const point = this.trail[i];
      const t = intensity * 0.8 * opacity;
      ctx.fillStyle = shade(t);
      ctx.globalAlpha = opacity * 0.6;
      ctx.beginPath();
      ctx.arc(point.x, point.y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw main particle
    ctx.globalAlpha = 1.0;
    const t = 0.3 + intensity * 0.7 + audioLevel * params.reactivity * 0.3;
    ctx.fillStyle = shade(t);
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Initialize boids
const boids = [];
const NUM_BOIDS = 150;
for (let i = 0; i < NUM_BOIDS; i++) {
  boids.push(new Boid(Math.random() * w, Math.random() * h));
}

// Check for reduced motion preference
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

function animate() {
  if (prefersReducedMotion) return;

  // Multiplicative frame decay
  ctx.fillStyle = 'rgba(5,5,5,0.12)';
  ctx.fillRect(0, 0, w, h);

  // Update and render boids
  for (let boid of boids) {
    boid.edges();
    boid.flock(boids);
    boid.update();
    boid.show();
  }

  requestAnimationFrame(animate);
}

if (!prefersReducedMotion) {
  animate();
}
</script>
</body>
</html>
