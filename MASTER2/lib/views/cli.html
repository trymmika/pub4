<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>MASTER</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050505;
      color: #e8e8e8;
      font-family: "Courier New", Courier, monospace;
    }
    body {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      padding: 10px;
    }
    #top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #8a8a8a;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      min-height: 18px;
    }
    #state.on { color: #e8e8e8; }
    #log {
      border: 1px solid #1a1a1a;
      padding: 8px;
      overflow-y: auto;
      scrollbar-width: none;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #log::-webkit-scrollbar { display: none; }
    .u { color: #9b9b9b; }
    .a { color: #e8e8e8; }
    .e { color: #c86b6b; }
    #bar {
      display: grid;
      grid-template-columns: 1fr auto auto;
      border: 1px solid #1a1a1a;
    }
    #in {
      background: transparent;
      border: 0;
      color: #e8e8e8;
      font: inherit;
      font-size: 14px;
      padding: 10px;
      outline: 0;
    }
    #in::placeholder { color: #666; }
    button {
      background: transparent;
      border: 0;
      border-left: 1px solid #1a1a1a;
      color: #8a8a8a;
      width: 42px;
      cursor: pointer;
      font: inherit;
      font-size: 14px;
    }
    button:hover { color: #e8e8e8; }
    button.on { color: #e8e8e8; }
  </style>
</head>
<body>
  <div id="top"><span>master or+rep</span><span id="state">idle</span></div>
  <div id="log"></div>
  <div id="bar">
    <input id="in" type="text" placeholder="say or type" autocomplete="off">
    <button id="mic" title="voice">mic</button>
    <button id="snd" title="speech output">tts:l</button>
  </div>

  <script>
    const AUTH = "Bearer " + (window.MASTER_TOKEN||'');
    const logEl = document.getElementById("log");
    const stateEl = document.getElementById("state");
    const inputEl = document.getElementById("in");
    const micBtn = document.getElementById("mic");
    const sndBtn = document.getElementById("snd");

    let pending = false;
    let ttsOn = true;
    let offlineN = 0;
    let voicesReady = false;
    const TTS_BACKEND_KEY = "master_tts_backend";
    let ttsBackend = localStorage.getItem(TTS_BACKEND_KEY) || "local";
    const remoteAudio = new Audio();

    function parseJsonOrThrow(resp) {
      if (!resp.ok) throw new Error("http " + resp.status);
      return resp.json();
    }

    function setState(v) {
      stateEl.textContent = v;
      stateEl.className = v === "idle" ? "" : "on";
    }

    function addLine(text, klass) {
      const row = document.createElement("div");
      row.className = klass;
      row.textContent = text;
      logEl.appendChild(row);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateTtsLabel() {
      sndBtn.textContent = ttsOn ? (ttsBackend === "local" ? "tts:l" : "tts:r") : "tts:off";
      sndBtn.classList.toggle("on", ttsOn);
    }

    function localTtsAvailable() {
      if (!window.speechSynthesis) return false;
      const voices = window.speechSynthesis.getVoices();
      return voicesReady || voices.length > 0;
    }

    function speakLocal(text) {
      if (!localTtsAvailable()) return false;
      const utterance = new SpeechSynthesisUtterance((text || "").slice(0, 420));
      const voices = window.speechSynthesis.getVoices();
      const preferred = voices.find((v) => v.localService) || voices[0];
      if (preferred) utterance.voice = preferred;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utterance);
      return true;
    }

    function speakRemote(text) {
      return fetch("/tts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": AUTH
        },
        body: JSON.stringify({ text: (text || "").slice(0, 900) })
      }).then((resp) => {
        if (!resp.ok) throw new Error("tts http " + resp.status);
        return resp.blob();
      }).then((blob) => {
        const url = URL.createObjectURL(blob);
        remoteAudio.src = url;
        remoteAudio.play().catch(() => {});
        remoteAudio.onended = () => URL.revokeObjectURL(url);
      });
    }

    function speak(text) {
      if (!ttsOn) return;
      if (ttsBackend === "local") {
        if (!speakLocal(text)) {
          speakRemote(text).catch(() => {});
        }
        return;
      }
      speakRemote(text).catch(() => {
        speakLocal(text);
      });
    }

    function setPending(v) {
      pending = v;
      inputEl.disabled = v;
      setState(v ? "thinking" : "idle");
    }

    function send(text) {
      const msg = (text || "").trim();
      if (!msg || pending) return;
      addLine("> " + msg, "u");
      inputEl.value = "";
      setPending(true);
      fetch("/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": AUTH
        },
        body: JSON.stringify({ message: msg })
      }).then(parseJsonOrThrow).catch(() => {
        addLine("[send failed]", "e");
        setPending(false);
        offlineN += 1;
      });
    }

    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") send(inputEl.value);
    });

    (function poll() {
      const delay = offlineN === 0 ? 700 : Math.min(1200 * (offlineN + 1), 8000);
      fetch("/poll", {
        signal: AbortSignal.timeout(9000),
        headers: { "Authorization": AUTH }
      }).then(parseJsonOrThrow).then((d) => {
        offlineN = 0;
        if (d.text) {
          addLine(d.text, "a");
          speak(d.text);
          setPending(false);
        }
        setTimeout(poll, delay);
      }).catch(() => {
        offlineN += 1;
        setTimeout(poll, delay);
      });
    })();

    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) {
      micBtn.disabled = true;
      micBtn.textContent = "--";
    } else {
      const rec = new SR();
      rec.continuous = false;
      rec.interimResults = true;
      rec.lang = "en-US";
      let listening = false;

      function stopMic() {
        listening = false;
        micBtn.classList.remove("on");
        setState(pending ? "thinking" : "idle");
      }

      micBtn.addEventListener("click", () => {
        if (pending) return;
        if (listening) {
          rec.stop();
          return;
        }
        listening = true;
        micBtn.classList.add("on");
        setState("listening");
        rec.start();
      });

      rec.addEventListener("result", (e) => {
        const t = Array.from(e.results).map((r) => r[0].transcript).join("");
        inputEl.value = t;
        if (e.results[e.results.length - 1].isFinal) {
          rec.stop();
          send(t);
        }
      });

      rec.addEventListener("end", stopMic);
      rec.addEventListener("error", stopMic);
    }

    sndBtn.addEventListener("click", () => {
      if (!ttsOn) {
        ttsOn = true;
      } else if (ttsBackend === "local") {
        ttsBackend = "remote";
      } else {
        ttsOn = false;
      }
      localStorage.setItem(TTS_BACKEND_KEY, ttsBackend);
      if (!ttsOn && window.speechSynthesis) window.speechSynthesis.cancel();
      updateTtsLabel();
    });

    if (window.speechSynthesis) {
      const syncVoices = () => {
        voicesReady = window.speechSynthesis.getVoices().length > 0;
      };
      syncVoices();
      window.speechSynthesis.onvoiceschanged = syncVoices;
    }
    updateTtsLabel();
  </script>
</body>
</html>
