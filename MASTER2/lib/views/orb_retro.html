<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Orb Retro - CRT Oscilloscope</title>
<style>
:root {
  --mint: #5af0b6;
  --mint-dim: #2a7a5a;
  --mint-ghost: #153a2d;
  --bg: #050505;
  --text: #c8d0cc;
  --text-2: #5a6a62;
  --error: #f06050;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Courier New', monospace;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
}

#canvas {
  display: block;
  width: 100%;
  height: 100%;
  image-rendering: crisp-edges;
  filter: contrast(1.1) brightness(1.05);
}

.container {
  position: relative;
  width: 100vw;
  height: 100vh;
}

@media (prefers-reduced-motion: reduce) {
  #canvas {
    animation: none;
    filter: none;
  }
}
</style>
</head>
<body>
<div class="container">
  <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

let w = canvas.width = window.innerWidth;
let h = canvas.height = window.innerHeight;
let cx = w / 2;
let cy = h / 2;
let scale = Math.min(w, h) * 0.35;

const DELAY_BUFFER_SIZE = 256;
const delayBuffer = new Float32Array(DELAY_BUFFER_SIZE);
let delayIndex = 0;

let audioCtx = null;
let analyser = null;
let dataArray = null;
let audioLevel = 0;
let state = 'idle';

const STATE_PARAMS = {
  idle: { decay: 0.05, reactivity: 0.3, speed: 0.5 },
  thinking: { decay: 0.12, reactivity: 0.6, speed: 0.8 },
  speaking: { decay: 0.20, reactivity: 1.0, speed: 1.0 }
};

const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

function shade(t) {
  t = Math.max(0, Math.min(1, t));
  const r = Math.round(5 + t * 85);
  const g = Math.round(5 + t * 235);
  const b = Math.round(5 + t * 177);
  return "rgb(" + r + "," + g + "," + b + ")";
}

function estimatePeriod(buffer) {
  let crossings = 0;
  let lastSign = buffer[0] >= 0;
  
  for (let i = 1; i < buffer.length; i++) {
    const sign = buffer[i] >= 0;
    if (sign !== lastSign) {
      crossings++;
      lastSign = sign;
    }
  }
  
  if (crossings < 2) return 64;
  const period = Math.floor((buffer.length / crossings) * 2);
  return Math.max(16, Math.min(128, period));
}

function initAudio() {
  if (audioCtx) return;
  
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  analyser.smoothingTimeConstant = 0.7;
  
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  
  navigator.mediaDevices.getUserMedia({ audio: true, video: false })
    .then(stream => {
      const source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyser);
    })
    .catch(err => {
      console.warn('Audio not available:', err);
      generateTestSignal();
    });
}

function generateTestSignal() {
  if (!dataArray) return;
  const params = STATE_PARAMS[state] || STATE_PARAMS.idle;
  const amp = audioLevel > 0 ? audioLevel : (0.3 + Math.random() * 0.2) * params.reactivity;
  
  for (let i = 0; i < dataArray.length; i++) {
    const t = i / dataArray.length;
    const freq = 2 + (state === 'speaking' ? 8 : 4);
    const val = Math.sin(t * Math.PI * freq + Date.now() * 0.001 * params.speed) * amp;
    dataArray[i] = Math.floor((val + 1) * 127.5);
  }
}

function drawVignette() {
  const gradient = ctx.createRadialGradient(cx, cy, scale * 0.5, cx, cy, scale * 1.8);
  gradient.addColorStop(0, 'rgba(5,5,5,0)');
  gradient.addColorStop(0.7, 'rgba(5,5,5,0.3)');
  gradient.addColorStop(1, 'rgba(5,5,5,0.8)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, w, h);
}

function drawScanlines() {
  if (prefersReducedMotion) return;
  
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = '#050505';
  for (let y = 0; y < h; y += 4) {
    ctx.fillRect(0, y, w, 2);
  }
  ctx.globalAlpha = 1.0;
}

function render() {
  const params = STATE_PARAMS[state] || STATE_PARAMS.idle;
  
  ctx.fillStyle = 'rgba(5,5,5,0.12)';
  ctx.fillRect(0, 0, w, h);
  
  if (!analyser) {
    generateTestSignal();
  } else {
    analyser.getByteTimeDomainData(dataArray);
  }
  
  if (!dataArray) {
    requestAnimationFrame(render);
    return;
  }
  
  const buffer = new Float32Array(dataArray.length);
  for (let i = 0; i < dataArray.length; i++) {
    buffer[i] = (dataArray[i] - 128) / 128.0 * params.reactivity;
  }
  
  const period = estimatePeriod(buffer);
  const delay = Math.floor(period / 4);
  
  for (let i = 0; i < buffer.length; i++) {
    delayBuffer[delayIndex] = buffer[i];
    delayIndex = (delayIndex + 1) % DELAY_BUFFER_SIZE;
  }
  
  ctx.lineWidth = 1.5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  let prevX = 0, prevY = 0;
  
  for (let i = 0; i < buffer.length - 1; i++) {
    const x = buffer[i];
    const yIdx = (delayIndex + DELAY_BUFFER_SIZE - delay - (buffer.length - i)) % DELAY_BUFFER_SIZE;
    const y = delayBuffer[yIdx];
    
    const sx = cx + x * scale;
    const sy = cy - y * scale;
    
    if (i > 0) {
      const dx = sx - prevX;
      const dy = sy - prevY;
      const speed = Math.sqrt(dx * dx + dy * dy) / scale;
      const brightness = Math.min(1.0, 0.3 / (speed + 0.01));
      
      const gradient = ctx.createLinearGradient(prevX, prevY, sx, sy);
      gradient.addColorStop(0, shade(brightness * 0.8));
      gradient.addColorStop(1, shade(brightness));
      
      ctx.strokeStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(prevX, prevY);
      ctx.lineTo(sx, sy);
      ctx.stroke();
      
      if (brightness > 0.6) {
        ctx.fillStyle = shade(brightness * 0.4);
        ctx.beginPath();
        ctx.arc(sx, sy, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    prevX = sx;
    prevY = sy;
  }
  
  drawVignette();
  drawScanlines();
  
  requestAnimationFrame(render);
}

window.addEventListener('message', function(e) {
  if (e.data && e.data.type === 'state') state = e.data.mode;
  if (e.data && e.data.type === 'audio') audioLevel = e.data.level;
});

window.addEventListener('resize', () => {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  cx = w / 2;
  cy = h / 2;
  scale = Math.min(w, h) * 0.35;
});

canvas.addEventListener('click', () => {
  initAudio();
});

document.addEventListener('DOMContentLoaded', () => {
  ctx.fillStyle = '#050505';
  ctx.fillRect(0, 0, w, h);
  render();
});
</script>
</body>
</html>
