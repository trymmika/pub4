<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Orb 3D</title>
<style>
:root {
  --mint: #5af0b6;
  --mint-dim: #2a7a5a;
  --mint-ghost: #153a2d;
  --bg: #050505;
  --text: #c8d0cc;
  --text-2: #5a6a62;
  --error: #f06050;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: var(--bg);
  overflow: hidden;
  width: 100vw;
  height: 100vh;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

@media (prefers-reduced-motion: reduce) {
  canvas {
    opacity: 0.5;
  }
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script src="orb_shared.js"></script>
<script>
setupDefaultMessageHandler();

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let w, h, cx, cy;

function resize() {
  w = canvas.width = window.innerWidth * devicePixelRatio;
  h = canvas.height = window.innerHeight * devicePixelRatio;
  cx = w / 2;
  cy = h / 2;
}
resize();
window.addEventListener('resize', resize);

// Fibonacci sphere points
function fibonacciSphere(n) {
  const points = [];
  const phi = (1 + Math.sqrt(5)) / 2;
  const goldenAngle = 2 * Math.PI / (phi * phi);
  
  for (let i = 0; i < n; i++) {
    const y = 1 - (i / (n - 1)) * 2;
    const radius = Math.sqrt(1 - y * y);
    const theta = goldenAngle * i;
    const x = Math.cos(theta) * radius;
    const z = Math.sin(theta) * radius;
    points.push({x, y, z, idx: i});
  }
  return points;
}

// Distance between two 3D points
function dist3d(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  const dz = p1.z - p2.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

// Find nearest neighbors for tensegrity structure
function findEdges(points, k = 6) {
  const edges = [];
  for (let i = 0; i < points.length; i++) {
    const distances = points.map((p, j) => ({idx: j, dist: dist3d(points[i], p)}))
      .filter(d => d.idx !== i)
      .sort((a, b) => a.dist - b.dist);
    
    for (let j = 0; j < Math.min(k, distances.length); j++) {
      const a = i;
      const b = distances[j].idx;
      if (a < b) {
        edges.push([a, b]);
      }
    }
  }
  return edges;
}

// Spherical harmonics Y_2^2
function sphericalHarmonic(theta, phi) {
  const Y22 = 0.25 * Math.sqrt(15 / Math.PI) * Math.sin(theta) * Math.sin(theta) * Math.cos(2 * phi);
  return Y22;
}

// Initialize geometry
const basePoints = fibonacciSphere(120);
const edges = findEdges(basePoints, 6);

// Rotation matrices
function rotateX(p, angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return {
    x: p.x,
    y: p.y * c - p.z * s,
    z: p.y * s + p.z * c
  };
}

function rotateY(p, angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return {
    x: p.x * c + p.z * s,
    y: p.y,
    z: -p.x * s + p.z * c
  };
}

function rotateZ(p, angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return {
    x: p.x * c - p.y * s,
    y: p.x * s + p.y * c,
    z: p.z
  };
}

// Project 3D to 2D
function project(p, scale) {
  const fov = 500;
  const z = p.z + 3;
  const perspective = fov / (fov + z);
  return {
    x: cx + p.x * scale * perspective,
    y: cy + p.y * scale * perspective,
    z: p.z,
    depth: z
  };
}

// Check for reduced motion preference
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

let time = 0;
function render() {
  const params = STATE_PARAMS[state] || STATE_PARAMS.idle;
  
  // Multiplicative frame decay
  ctx.fillStyle = `rgba(5,5,5,${params.decay})`;
  ctx.fillRect(0, 0, w, h);
  
  if (prefersReducedMotion) {
    time += 0.001;
  } else {
    time += 0.01 * params.speed;
  }
  
  const rotSpeed = prefersReducedMotion ? 0.001 : 0.005 * params.speed;
  const rotX = time * rotSpeed;
  const rotY = time * rotSpeed * 0.7;
  const rotZ = time * rotSpeed * 0.3;
  
  // Audio-reactive deformation amplitude
  const deformAmp = 0.1 + audioLevel * params.reactivity * 0.3;
  
  // Transform points with spherical harmonic deformation
  const transformedPoints = basePoints.map(p => {
    const theta = Math.acos(p.y);
    const phi = Math.atan2(p.z, p.x);
    const harmonic = sphericalHarmonic(theta, phi + time);
    const deform = 1 + harmonic * deformAmp;
    
    let tp = {x: p.x * deform, y: p.y * deform, z: p.z * deform};
    tp = rotateX(tp, rotX);
    tp = rotateY(tp, rotY);
    tp = rotateZ(tp, rotZ);
    return tp;
  });
  
  const scale = Math.min(w, h) * 0.25;
  const projectedPoints = transformedPoints.map(p => project(p, scale));
  
  // Depth-sorted edge rendering
  const edgesWithDepth = edges.map(([a, b]) => {
    const pa = projectedPoints[a];
    const pb = projectedPoints[b];
    const avgDepth = (pa.depth + pb.depth) / 2;
    return {a, b, pa, pb, depth: avgDepth};
  });
  
  edgesWithDepth.sort((e1, e2) => e1.depth - e2.depth);
  
  // Render edges
  edgesWithDepth.forEach(({pa, pb, depth}) => {
    const depthNorm = (depth - 2) / 2;
    const intensity = Math.max(0, Math.min(1, 1 - depthNorm * 0.5));
    
    ctx.strokeStyle = shade(intensity * 0.7);
    ctx.lineWidth = 1 + intensity * 2;
    ctx.beginPath();
    ctx.moveTo(pa.x, pa.y);
    ctx.lineTo(pb.x, pb.y);
    ctx.stroke();
  });
  
  // Render points
  projectedPoints.forEach((p, i) => {
    const depthNorm = (p.depth - 2) / 2;
    const intensity = Math.max(0, Math.min(1, 1 - depthNorm * 0.5));
    const size = 2 + intensity * 3;
    
    ctx.fillStyle = shade(intensity);
    ctx.beginPath();
    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
    ctx.fill();
  });
  
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
