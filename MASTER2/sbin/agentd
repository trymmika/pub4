#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "json"

begin
  require "dotenv/load"
rescue LoadError
  # dotenv not available
end

require_relative "../lib/master"

# Setup database
db_path = "#{MASTER.root}/master.db"
MASTER::DB.setup(path: db_path)

# Configure LLM
MASTER::LLM.configure

# Configuration
INBOX_DIR = ENV["MASTER_INBOX"] || "#{MASTER.root}/tmp/inbox"
OUTBOX_DIR = ENV["MASTER_OUTBOX"] || "#{MASTER.root}/tmp/outbox"
POLL_INTERVAL = (ENV["MASTER_POLL_INTERVAL"] || "5").to_i

# Create directories
FileUtils.mkdir_p(INBOX_DIR)
FileUtils.mkdir_p(OUTBOX_DIR)

MASTER::Boot.banner
puts "Watching: #{INBOX_DIR}"
puts "Output: #{OUTBOX_DIR}"
puts "Poll interval: #{POLL_INTERVAL}s"
puts "Press Ctrl+C to stop\n\n"

# Signal handling
running = true
Signal.trap("INT") do
  running = false
  puts "\nShutting down..."
end
Signal.trap("TERM") do
  running = false
  puts "\nShutting down..."
end

pipeline = MASTER::Pipeline.new

while running
  begin
    # Find all .json files in inbox
    files = Dir.glob("#{INBOX_DIR}/*.json").sort

    files.each do |file|
      puts "[#{Time.now}] Processing: #{File.basename(file)}"

      # Read and parse JSON
      input = JSON.parse(File.read(file), symbolize_names: true)

      # Process through pipeline
      result = pipeline.call(input)

      # Write result to outbox (validate basename)
      basename = File.basename(file, ".json")
      raise "Invalid filename" if basename.include?("..") || basename.start_with?("/")
      output_file = File.join(OUTBOX_DIR, "#{basename}_#{Time.now.to_i}.json")

      if result.ok?
        File.write(output_file, JSON.pretty_generate(result.value))
        puts "  ✓ Success: #{output_file}"
      else
        File.write(output_file, JSON.pretty_generate({ error: result.error }))
        puts "  ✗ Error: #{result.error}"
      end

      # Remove processed file
      File.delete(file) if File.exist?(file)
    rescue StandardError => e
      puts "  ✗ Failed to process #{file}: #{e.message}"
      # Move to error directory
      error_dir = "#{INBOX_DIR}/errors"
      FileUtils.mkdir_p(error_dir)
      FileUtils.mv(file, "#{error_dir}/#{File.basename(file)}")
    end

    sleep POLL_INTERVAL
  rescue Interrupt
    running = false
  rescue StandardError => e
    puts "Error in main loop: #{e.message}"
    sleep POLL_INTERVAL
  end
end

puts "agentd stopped."
