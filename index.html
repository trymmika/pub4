<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>pub4</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { display: flex; align-items: center; justify-content: center; background: #0b0f1a; color: #e7eefc; }
    canvas { width: min(92vw, 920px); height: min(92vw, 920px); background: #0b0f1a; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; }
    .hud { position: fixed; left: 12px; bottom: 10px; font-size: 12px; opacity: 0.8; user-select: none; }
    .hud code { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <canvas id="c" width="900" height="900" aria-label="animation canvas"></canvas>
  <div class="hud">
    <div>Toggle: <code>Space</code> Pause/Play</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const W = canvas.width;
  const H = canvas.height;

  // Constants
  const LINK_DISTANCE = 60;
  const LINK_BASE_ALPHA = 0.12;
  const MIN_FRAME_MS = 1000 / 120;
  const MAX_DT_MS = 100;
  const DOT_COUNT = 80;

  let rafId = 0;
  let running = true;
  let pausedByVisibility = false;

  let lastFrameT = performance.now();
  let lastRenderT = lastFrameT;
  let lastSeenFrameT = lastFrameT; // used for stall watchdog

  // Scene state - 80 dots for performance (3K checks/frame vs 24K)
  const dots = [];
  for (let i = 0; i < DOT_COUNT; i++) {
    dots.push({
      x: Math.random() * W,
      y: Math.random() * H,
      vx: (Math.random() * 2 - 1) * 35,
      vy: (Math.random() * 2 - 1) * 35,
      r: 1.2 + Math.random() * 2.6,
    });
  }

  function resizeToCSSPixels() {
    // intentionally keep fixed backing store for crispness; CSS scales
    // (no-op placeholder)
  }

  function step(dt) {
    const s = dt / 1000;
    for (const p of dots) {
      p.x += p.vx * s;
      p.y += p.vy * s;
      bounceIfNeeded(p);
    }
  }

  function bounceIfNeeded(p) {
    if (p.x < 0) { p.x = 0; p.vx *= -1; }
    if (p.x > W) { p.x = W; p.vx *= -1; }
    if (p.y < 0) { p.y = 0; p.vy *= -1; }
    if (p.y > H) { p.y = H; p.vy *= -1; }
  }

  function render() {
    ctx.fillStyle = '#0b0f1a';
    ctx.fillRect(0, 0, W, H);
    renderLinks();
    renderDots();
  }

  function renderLinks() {
    ctx.lineWidth = 1;
    for (let i = 0; i < DOT_COUNT; i++) {
      const a = dots[i];
      for (let j = i + 1; j < DOT_COUNT; j++) {
        const b = dots[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const d2 = dx * dx + dy * dy;
        const threshold = LINK_DISTANCE * LINK_DISTANCE;
        
        if (d2 < threshold) {
          const alpha = (1 - Math.sqrt(d2) / LINK_DISTANCE) * LINK_BASE_ALPHA;
          ctx.strokeStyle = `rgba(140,190,255,${alpha})`;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }
  }

  function renderDots() {
    ctx.fillStyle = '#cfe3ff';
    for (const p of dots) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function cancelAnimFrame() {
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = 0;
    }
  }

  function restartAnimFrame() {
    // Reset timing baselines so we don't get a huge dt spike on resume.
    const now = performance.now();
    lastFrameT = now;
    lastRenderT = now;
    lastSeenFrameT = now;

    if (!rafId) rafId = requestAnimationFrame(animate);
  }

  // Visible-only stall watchdog: if rAF stops delivering frames while visible,
  // restart it. (Some browsers/extensions can occasionally stall rAF.)
  let stallTimer = 0;
  function startStallWatchdog() {
    stopStallWatchdog();
    stallTimer = window.setInterval(() => {
      if (!running) return;
      if (document.hidden) return;
      const now = performance.now();
      if (now - lastSeenFrameT > 2000) {
        // restart
        cancelAnimFrame();
        restartAnimFrame();
      }
    }, 500);
  }
  function stopStallWatchdog() {
    if (stallTimer) {
      clearInterval(stallTimer);
      stallTimer = 0;
    }
  }

  function animate(t) {
    rafId = 0;

    // If hidden, do not schedule more frames. visibilitychange handler will resume.
    if (document.hidden) {
      pausedByVisibility = true;
      cancelAnimFrame();
      return;
    }

    lastSeenFrameT = t;

    if (!running) {
      // paused by user; don't enqueue
      return;
    }

    const dt = Math.min(MAX_DT_MS, t - lastFrameT);
    if (dt >= MIN_FRAME_MS) {
      lastFrameT = t;
      step(dt);
      render();
      lastRenderT = t;
    }

    rafId = requestAnimationFrame(animate);
  }

  function play() {
    if (running) return;
    running = true;
    restartAnimFrame();
    startStallWatchdog();
  }

  function pause() {
    if (!running) return;
    running = false;
    cancelAnimFrame();
    // keep watchdog running only when playing
    stopStallWatchdog();
  }

  // Proper pause/resume on visibilitychange:
  // - when hidden: cancel rAF immediately
  // - when visible: restart rAF and reset timing baselines
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      if (rafId) cancelAnimFrame();
      pausedByVisibility = true;
      // watchdog should not run when hidden
      // (it is visible-only anyway, but stop it to avoid needless work)
      stopStallWatchdog();
      return;
    }

    if (pausedByVisibility) {
      pausedByVisibility = false;
      if (running) {
        restartAnimFrame();
        startStallWatchdog();
      }
    }
  }, { passive: true });

  // Controls
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      running ? pause() : play();
    }
  });

  window.addEventListener('resize', resizeToCSSPixels, { passive: true });

  // Start
  render();
  restartAnimFrame();
  startStallWatchdog();
})();
</script>
</body>
</html>
