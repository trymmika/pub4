<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Organic AI Orb</title>
<script src="https://unpkg.com/css-doodle@0.40.5/css-doodle.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
<style>
/* ============================================
   ACCESSIBILITY & REDUCED MOTION (nngroup, web.dev)
   ============================================ */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

:focus-visible {
  outline: 2px solid #fff;
  outline-offset: 2px;
}

/* ============================================
   CUSTOM PROPERTIES
   ============================================ */
:root {
  --color-bg: #000;
  --color-fg: #fff;
  --orb-size: 35vmin;
}

/* ============================================
   KEYFRAMES
   ============================================ */
@keyframes breathe {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.03); }
}



/* === DIMENSIONAL KEYFRAMES === */
@keyframes dimensional-shift {
  0%, 100% { 
    filter: hue-rotate(0deg);
    opacity: 0.08;
  }
  25% { 
    filter: hue-rotate(-15deg);
    opacity: 0.12;
  }
  50% { 
    filter: hue-rotate(-30deg);
    opacity: 0.15;
  }
  75% { 
    filter: hue-rotate(-15deg);
    opacity: 0.12;
  }
}

@keyframes sacred-rotate {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

@keyframes presence-pulse {
  0%, 100% { 
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
  }
  50% { 
    opacity: 0.06;
    transform: translate(-50%, -50%) scale(1.2);
  }
}

@keyframes grain-jitter {
  0%, 100% { transform: translate(1px, 6px); }
  10% { transform: translate(-8px, 14px); }
  20% { transform: translate(9px, 13px); }
  30% { transform: translate(-10px, -11px); }
  40% { transform: translate(14px, -7px); }
  50% { transform: translate(-13px, -6px); }
  60% { transform: translate(10px, 9px); }
  70% { transform: translate(-14px, -8px); }
  80% { transform: translate(9px, 6px); }
  90% { transform: translate(-10px, 7px); }
}

@keyframes light-leak {
  0%, 100% { opacity: 0; }
  50% { opacity: 0.2; }
}

/* ============================================
   BASE
   ============================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  width: 100vw;
  height: 100vh;
  height: 100dvh; /* Dynamic viewport for mobile */
  overflow: hidden;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  overscroll-behavior: none;
}

h1 {
  position: fixed;
  top: 20px;
  left: 20px;
  margin: 0;
  font-family: "Inter", sans-serif;
  font-optical-sizing: auto;
  font-size: 18px;
  font-weight: 600;
  font-style: normal;
  color: #fff;
  letter-spacing: -0.02em;
  z-index: 1000;
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
  background: transparent !important;
  min-width: 100px;
  padding: 8px 12px;
  cursor: text;
  -webkit-user-modify: read-write-plaintext-only;
  -webkit-appearance: none;
  -moz-appearance: none;
  caret-color: #fff;
}

h1:focus, h1:active, h1:focus-visible {
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
  background: transparent !important;
}

h1:empty::before {
  content: attr(data-placeholder);
  color: rgba(255,255,255,0.4);
}

/* ============================================
   STAGE
   ============================================ */
.stage {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
}

#effects-canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.tracking-wrapper {
  /* No 3D transforms - keep orb flat facing forward */
  transform: none !important;
  transform-style: flat;
}

.blob-wrapper {
  width: 35vmin;
  height: 35vmin;
  filter: none;
  animation: breathe 4s ease-in-out infinite;
  transform-origin: center center;
  transform: none !important;
}

.blob {
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: #fff;
  transform: none !important;
  /* Pure flat white circle - no 3D */
}

.blob-shape {
  /* Override - just a circle */
  clip-path: circle(50%);
  transform: none;
}

/* Tunnel canvas - disabled for flat design */
.orb-tunnel {
  display: none;
}

/* Star field - disabled for flat design */
.star-field {
  display: none;
}

@supports (clip-path: shape(from 0% 0%, move to 100% 100%)) {
  .blob-shape {
    clip-path: content-box shape(
      from var(--mx6) var(--my6),
      curve to var(--mx0) var(--my0) with var(--x0) var(--y0),
      curve to var(--mx1) var(--my1) with var(--x1) var(--y1),
      curve to var(--mx2) var(--my2) with var(--x2) var(--y2),
      curve to var(--mx3) var(--my3) with var(--x3) var(--y3),
      curve to var(--mx4) var(--my4) with var(--x4) var(--y4),
      curve to var(--mx5) var(--my5) with var(--x5) var(--y5),
      curve to var(--mx6) var(--my6) with var(--x6) var(--y6)
    );
    transform: scale(calc(1 + var(--depth)));
  }
}

/* ============================================
   INTELLIGENCE FEATURES
   ============================================ */
/* ============================================
   FLAT MINIMALIST DESIGN - no effects
   ============================================ */
.sacred-geometry {
  display: none;
}

.dimensional-aura {
  display: none;
}

.presence-ring {
  display: none;
}

/* No shimmer - flat white only */
.blob::after {
  display: none;
}

/* Listening state indicator - simple border */
.blob-wrapper.listening::before {
  content: '';
  position: absolute;
  inset: -5%;
  border: 2px solid #fff;
  border-radius: 50%;
  animation: pulse-ring 1.5s ease-in-out infinite;
  pointer-events: none;
}

@keyframes pulse-ring {
  0%, 100% { opacity: 0.3; transform: scale(1); }
  50% { opacity: 0.6; transform: scale(1.02); }
}

/* Speaking state - faster breathe */
.blob-wrapper.speaking {
  animation: breathe 2s ease-in-out infinite;
}

/* ============================================
   FLAT DESIGN - no depth effects
   ============================================ */

/* No shadow */
.orb-shadow {
  display: none;
}

/* No afterimage */
.afterimage {
  display: none;
}

/* No membrane ripple */
.membrane-ripple {
  display: none;
}

/* No caustics */
.caustics {
  display: none;
}

/* ============================================
   FLAT OVERLAY - no grain/vignette/leak
   ============================================ */
.grain-overlay {
  display: none;
}

.vignette {
  display: none;
}

.light-leak {
  display: none;
}

/* ============================================
   FIREFOX FALLBACK
   ============================================ */
@-moz-document url-prefix() {
  .blob-wrapper, .grain-overlay { filter: none; }
}
</style>
</head>
<body>

<h1 id="aresInput" contenteditable="true" data-placeholder="Johann sin AI">Johann sin AI</h1>

<!-- SVG Filters -->
<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="filmGrain">
      <feTurbulence type="fractalNoise" baseFrequency="1.5" numOctaves="4" seed="42" result="noise"/>
      <feColorMatrix in="noise" type="saturate" values="0" result="desaturatedNoise"/>
      <feComponentTransfer in="desaturatedNoise" result="grain">
        <feFuncA type="discrete" tableValues="0 0 0 1 1"/>
      </feComponentTransfer>
    </filter>

  </defs>
</svg>

<!-- Stage -->
<div class="stage">
  <div class="tracking-wrapper">
    <div class="blob-wrapper" id="blobWrapper">
      <div class="dimensional-aura"></div>
      <div class="sacred-geometry"></div>
      <div class="presence-ring"></div>
      <div class="blob blob-shape">
        <!-- CSS-doodle generative pattern -->
        <css-doodle>
          :doodle {
            @grid: 12x12;
            @size: 100%;
            overflow: hidden;
            border-radius: 50%;
          }
          background: @pick(transparent, rgba(255,255,255,0.03));
          transform: scale(@rand(0.8, 1.2));
          animation: cell-breathe @rand(4s, 8s) ease-in-out infinite;
          animation-delay: @rand(-5s, 0s);
          @keyframes cell-breathe {
            0%, 100% { opacity: 0.02; }
            50% { opacity: @rand(0.05, 0.12); }
          }
        </css-doodle>
      </div>
    </div>
    <!-- Shadow beneath -->
    <div class="orb-shadow"></div>
  </div>
</div>

<!-- Caustic light on floor -->
<div class="caustics"></div>

<!-- Effects canvas for astral particles -->
<canvas id="effects-canvas"></canvas>

<!-- Afterimage container -->
<div id="afterimageContainer" style="position:fixed; inset:0; pointer-events:none; z-index:1;"></div>

<!-- Status indicators -->
<div id="statusIndicator" style="position:fixed; top:20px; right:20px; font-family:'Courier New',monospace; font-size:16px; color:rgba(255,255,255,0.9); z-index:1000; pointer-events:none;">
  <style>
    .mic-icon { opacity: 0.5; transition: opacity 0.2s; font-size: 14px; }
    .mic-icon.mic-active { opacity: 1; animation: pulse-mic 1s ease-in-out infinite; }
    .spinner { color: rgba(255,255,255,0.7); font-size: 12px; }
    .speaking-icon { font-size: 14px; animation: pulse-speak 0.5s ease-in-out infinite; }
    @keyframes pulse-mic { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
    @keyframes pulse-speak { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
  </style>
</div>

<!-- Fullscreen Effects (flat only) -->
<div class="grain-overlay"></div>
<div class="vignette"></div>
<div class="light-leak"></div>

<!-- Audio element for visualization (no autoplay) -->
<audio id="audioPlayer" style="opacity: 0; position: absolute; pointer-events: none;" crossorigin="anonymous"></audio>

<script>
// ============================================
// CONFIG
// ============================================
const CONFIG = {
  intensity: 1.5,
  baseDepth: 0.3,
  fftSize: 512,
  onsetThreshold: 0.015,
  onsetSensitivity: 3,
  energySmoothing: 0.3,
  depthSmoothing: 0.5,
  depthDecay: 0.92,
  mouseTrackingStrength: 0.25,  // Increased for more response
  geometryMorphSpeed: 0.0001,
  
  // Pixelation
  pixelSteps: 8,  // Quantize movements to N steps
  
  // Autonomous wandering
  wanderSpeed: 0.0005,
  wanderRadius: 80,
  driftSpeed: 0.02,
  
  // Startle
  startleThreshold: 0.08,
  startleDistance: 40,
  startleDecay: 0.85,
  startleRotation: 15,
  
  // Asymmetric deformation
  asymmetryIntensity: 0.3,
  deformationStrength: 0.15,
  
  // Spin
  spinDecay: 0.95,
  spinImpulse: 0.5,
  
  // Ripples
  maxRipples: 5,
  rippleSpeed: 2,
  
  // Pulse
  aggressivePulseMin: 0.8,
  aggressivePulseMax: 1.4,
  
  // Tentacles
  maxTentacles: 4,
  tentacleLength: 120,
  tentacleDecay: 0.92,
  
  // Color shifts
  colorShiftAmount: 8,
  
  // Convulsions
  convulsionAmount: 4,
  
  // Gravity
  gravityRadius: 250,
  gravityStrength: 0.8,
  escapeSpeed: 1.5,
  escapeVelocity: 2,
  
  // === NEW: 3D LIFE ENHANCEMENTS ===
  // Breathing
  breathingCycle: 4000,      // 4 second breath cycle
  breathingMin: 0.97,
  breathingMax: 1.03,
  
  // Parallax layers
  parallaxStrength: 0.15,    // Inner particles move slower
  
  // Micro-jitter
  jitterAmount: 1.5,         // Pixels of random jitter
  jitterSpeed: 0.05,
  
  // Idle sway
  idleSwayAmount: 8,         // Pixels of gentle drift
  idleSwaySpeed: 0.0008,
  
  // Light source
  lightAngleSpeed: 0.0003,   // Slow rotation of fake light
  rimLightIntensity: 0.15,
  specularIntensity: 0.2,
  
  // Audio anticipation
  anticipationShrink: 0.95,
  anticipationDuration: 150,
  
  // Attention (look toward mouse)
  attentionStrength: 0.03
};

// ============================================
// STAR FIELD RENDERER - deep space background
// ============================================
const starFieldCanvas = document.getElementById('starField');
const starFieldCtx = starFieldCanvas?.getContext('2d', { alpha: true });

class StarField {
  constructor(ctx) {
    this.ctx = ctx;
    this.w = 0;
    this.h = 0;
    this.stars = [];
    this.numStars = 80; // Fewer stars for 8-bit feel
    this.speed = 0.5;
  }
  
  resize(w, h) {
    this.w = w;
    this.h = h;
    this.init();
  }
  
  init() {
    this.stars = [];
    for (let i = 0; i < this.numStars; i++) {
      this.stars.push({
        x: (Math.random() - 0.5) * this.w * 3,
        y: (Math.random() - 0.5) * this.h * 3,
        z: Math.random() * 1000,
        color: this.randomStarColor()
      });
    }
  }
  
  randomStarColor() {
    // 8-bit palette - limited colors
    const colors = ['#ffffff', '#c0c0ff', '#8080ff', '#c0ffff', '#ffffc0'];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  frame(audioData) {
    if (!this.ctx || this.w === 0) return;
    
    const bass = audioData?.bass || 0.5;
    this.ctx.clearRect(0, 0, this.w, this.h);
    
    const cx = this.w / 2;
    const cy = this.h / 2;
    
    // Disable anti-aliasing for pixel look
    this.ctx.imageSmoothingEnabled = false;
    
    for (const star of this.stars) {
      // Move toward viewer
      star.z -= this.speed * (1 + bass * 2);
      if (star.z <= 1) {
        star.z = 1000;
        star.x = (Math.random() - 0.5) * this.w * 3;
        star.y = (Math.random() - 0.5) * this.h * 3;
      }
      
      // Project to 2D
      const scale = 300 / star.z;
      const sx = Math.floor(cx + star.x * scale);
      const sy = Math.floor(cy + star.y * scale);
      
      // Size based on depth - 1-3 pixels only (8-bit style)
      const depth = 1 - star.z / 1000;
      const size = Math.max(1, Math.floor(depth * 3));
      
      // Draw as hard pixel rectangles - no gradients
      this.ctx.fillStyle = star.color;
      this.ctx.fillRect(sx, sy, size, size);
    }
  }
}

let starField = null;
if (starFieldCtx) {
  starField = new StarField(starFieldCtx);
}

function resizeStarField() {
  if (starFieldCanvas && starField) {
    const rect = starFieldCanvas.parentElement?.getBoundingClientRect();
    if (rect) {
      starFieldCanvas.width = rect.width;
      starFieldCanvas.height = rect.height;
      starField.resize(rect.width, rect.height);
    }
  }
}

// ============================================
// ORB TUNNEL RENDERER (from index.html)
// ============================================
const orbTunnelCanvas = document.getElementById('orbTunnel');
const orbTunnelCtx = orbTunnelCanvas?.getContext('2d', { alpha: true });

class OrbTunnel {
  constructor(ctx) {
    this.ctx = ctx;
    this.w = 0;
    this.h = 0;
    this.fov = 150;
    this.speed = 0.5;
    this.segments = 24;
    this.baseRadius = 40;
    this.zStep = 8;
    this.particles = [];
    this.time = 0;
  }
  
  resize(w, h) {
    this.w = w;
    this.h = h;
    this.init();
  }
  
  init() {
    this.particles = [];
    for (let z = -this.fov; z < this.fov; z += this.zStep) {
      const row = [];
      for (let i = 0; i < this.segments; i++) {
        const a = (i * Math.PI * 2) / this.segments;
        row.push({ x: Math.cos(a) * this.baseRadius, y: Math.sin(a) * this.baseRadius, z });
      }
      this.particles.push(row);
    }
  }
  
  frame(audioData) {
    if (!this.ctx || this.w === 0) return;
    
    const bass = audioData?.bass || 0.5;
    const beat = audioData?.beat || 0;
    
    this.ctx.clearRect(0, 0, this.w, this.h);
    
    // Sort by depth
    this.particles.sort((a, b) => b[0].z - a[0].z);
    
    for (let i = 0; i < this.particles.length; i++) {
      const row = this.particles[i];
      const d = i / this.particles.length;
      
      // Color based on depth and audio
      const r = Math.round(80 + d * 60 + beat * 40);
      const g = Math.round(60 + d * 40);
      const b = Math.round(120 + d * 80);
      const alpha = 0.3 + d * 0.5;
      
      this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      this.ctx.lineWidth = 1 + d;
      this.ctx.beginPath();
      
      for (let j = 0; j < row.length; j++) {
        const p = row[j];
        
        // Move toward camera
        p.z -= this.speed * (1 + bass * 0.5);
        if (p.z < -this.fov) p.z += this.fov * 2;
        
        // Rotate over time
        const a = (j * Math.PI * 2) / this.segments + this.time;
        const radiusMod = this.baseRadius * (1 + beat * 0.2);
        p.x = Math.cos(a) * radiusMod;
        p.y = Math.sin(a) * radiusMod;
        
        // Project to 2D
        const scale = this.fov / (this.fov + p.z);
        const x2d = this.w / 2 + p.x * scale;
        const y2d = this.h / 2 + p.y * scale;
        
        if (j === 0) this.ctx.moveTo(x2d, y2d);
        else this.ctx.lineTo(x2d, y2d);
      }
      
      this.ctx.closePath();
      this.ctx.stroke();
    }
    
    this.time += 0.02;
  }
}

let orbTunnel = null;
if (orbTunnelCtx) {
  orbTunnel = new OrbTunnel(orbTunnelCtx);
}

function resizeOrbTunnel() {
  if (orbTunnelCanvas && orbTunnel) {
    const rect = orbTunnelCanvas.parentElement?.getBoundingClientRect();
    if (rect) {
      orbTunnelCanvas.width = rect.width;
      orbTunnelCanvas.height = rect.height;
      orbTunnel.resize(rect.width, rect.height);
    }
  }
}

// ============================================
// ELEMENTS
// ============================================
const blob = document.querySelector('.blob');
const trackingWrapper = document.querySelector('.tracking-wrapper');
const blobWrapper = document.querySelector('.blob-wrapper');
const audio = document.getElementById('audioPlayer');
const effectsCanvas = document.getElementById('effects-canvas');
const effectsCtx = effectsCanvas?.getContext('2d');

// Setup canvas
function resizeCanvas() {
  if (!effectsCanvas) return;
  effectsCanvas.width = window.innerWidth;
  effectsCanvas.height = window.innerHeight;
}
resizeCanvas();
resizeOrbTunnel();
resizeStarField();
window.addEventListener('resize', () => { resizeCanvas(); resizeOrbTunnel(); resizeStarField(); });

// ============================================
// DRAWING FUNCTIONS
// ============================================
function drawTentacles() {
  if (!effectsCtx) return;
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  
  tentacles.forEach(t => {
    const startX = centerX + Math.cos(t.angle) * blobSize;
    const startY = centerY + Math.sin(t.angle) * blobSize;
    const endX = centerX + Math.cos(t.angle) * (blobSize + t.length);
    const endY = centerY + Math.sin(t.angle) * (blobSize + t.length);
    
    // Draw organic tentacle with bezier curve
    const cpX = (startX + endX) / 2 + Math.sin(t.angle + Date.now() * 0.003) * 30;
    const cpY = (startY + endY) / 2 + Math.cos(t.angle + Date.now() * 0.003) * 30;
    
    effectsCtx.strokeStyle = `rgba(0, 0, 0, ${t.life * 0.8})`;
    effectsCtx.lineWidth = 3 * t.life;
    effectsCtx.beginPath();
    effectsCtx.moveTo(startX, startY);
    effectsCtx.quadraticCurveTo(cpX, cpY, endX, endY);
    effectsCtx.stroke();
    
    // Draw tip
    effectsCtx.fillStyle = `rgba(0, 0, 0, ${t.life})`;
    effectsCtx.beginPath();
    effectsCtx.arc(endX, endY, 4 * t.life, 0, Math.PI * 2);
    effectsCtx.fill();
  });
}

function drawRipples() {
  if (!effectsCtx) return;
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  
  ripples.forEach(r => {
    const x = centerX + r.x * blobSize;
    const y = centerY + r.y * blobSize;
    const radius = r.radius * blobSize;
    
    effectsCtx.strokeStyle = `rgba(0, 0, 0, ${r.alpha * 0.3})`;
    effectsCtx.lineWidth = 2;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, radius, 0, Math.PI * 2);
    effectsCtx.stroke();
    
    // Inner ring
    if (radius > 20) {
      effectsCtx.strokeStyle = `rgba(0, 0, 0, ${r.alpha * 0.15})`;
      effectsCtx.lineWidth = 1;
      effectsCtx.beginPath();
      effectsCtx.arc(x, y, radius - 15, 0, Math.PI * 2);
      effectsCtx.stroke();
    }
  });
}

// ============================================
// AUDIO STATE
// ============================================
let ctx, analyser, source, dataArray, frequencyData;
let depth = CONFIG.baseDepth;
let smoothedDepth = CONFIG.baseDepth;
let prevEnergy = 0;
let smoothedEnergy = 0;

// Frequency bands
let bassEnergy = 0;
let midEnergy = 0;
let trebleEnergy = 0;

// Beat detection
let beatDetected = false;
let lastBeatTime = 0;
let tempo = 120; // BPM
let beatInterval = 60000 / tempo;

// ============================================
// POSITION & MOVEMENT STATE
// ============================================
let orbX = 0; // Offset from center
let orbY = 0;
let orbVelX = 0;
let orbVelY = 0;
let orbitAngle = 0;

// Startle state
let startleVelX = 0;
let startleVelY = 0;
let startleRotation = 0;

// Spin state
let spinVelocity = 0;
let spinAngle = 0;

// ============================================
// DEFORMATION STATE
// ============================================
let bassDeform = 0;
let midDeform = 0;
let trebleDeform = 0;
let subDeform = 0;

// ============================================
// RIPPLE STATE
// ============================================
let ripples = [];

// ============================================
// TENTACLE STATE
// ============================================
let tentacles = [];

// ============================================
// ASTRAL PARTICLE STATE
// ============================================
let astralParticles = [];
const MAX_ASTRAL_PARTICLES = 40;

function initAstralParticles() {
  for (let i = 0; i < MAX_ASTRAL_PARTICLES; i++) {
    astralParticles.push(createAstralParticle());
  }
}

function createAstralParticle() {
  const angle = Math.random() * Math.PI * 2;
  const distance = 0.3 + Math.random() * 0.7; // 30-100% of orb radius
  return {
    angle: angle,
    distance: distance,
    speed: 0.0002 + Math.random() * 0.0003,
    size: 0.5 + Math.random() * 2,
    alpha: 0.1 + Math.random() * 0.3,
    phase: Math.random() * Math.PI * 2,
    pulseSpeed: 0.001 + Math.random() * 0.002,
    layer: Math.floor(Math.random() * 3), // 0=inner, 1=mid, 2=outer
    hue: 220 + Math.random() * 40 // Blue to violet range
  };
}

function updateAstralParticles(time) {
  astralParticles.forEach(p => {
    p.angle += p.speed * (1 + smoothedEnergy * 2);
    p.phase += p.pulseSpeed;
    // Pulse alpha
    p.currentAlpha = p.alpha * (0.5 + 0.5 * Math.sin(p.phase));
  });
}

function drawAstralParticles() {
  if (!effectsCtx) return;
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.28;
  
  astralParticles.forEach(p => {
    const layerOffset = [0.5, 0.8, 1.2][p.layer];
    const x = centerX + Math.cos(p.angle) * blobSize * p.distance * layerOffset;
    const y = centerY + Math.sin(p.angle) * blobSize * p.distance * layerOffset;
    
    // Draw particle with glow
    const gradient = effectsCtx.createRadialGradient(x, y, 0, x, y, p.size * 3);
    gradient.addColorStop(0, `hsla(${p.hue}, 70%, 70%, ${p.currentAlpha})`);
    gradient.addColorStop(0.5, `hsla(${p.hue}, 60%, 50%, ${p.currentAlpha * 0.3})`);
    gradient.addColorStop(1, `hsla(${p.hue}, 50%, 30%, 0)`);
    
    effectsCtx.fillStyle = gradient;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, p.size * 3, 0, Math.PI * 2);
    effectsCtx.fill();
    
    // Bright core
    effectsCtx.fillStyle = `hsla(${p.hue}, 80%, 90%, ${p.currentAlpha * 0.8})`;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, p.size * 0.5, 0, Math.PI * 2);
    effectsCtx.fill();
  });
}

// ============================================
// UI STATE
// ============================================
let uiState = 'idle'; // idle, listening, thinking, speaking
const blobWrapperEl = document.getElementById('blobWrapper');
const statusIndicator = document.getElementById('statusIndicator');

// Ora-style braille spinner frames
const spinnerFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
let spinnerIndex = 0;
let spinnerInterval = null;

function setUIState(state) {
  uiState = state;
  if (blobWrapperEl) {
    blobWrapperEl.classList.remove('listening', 'thinking', 'speaking');
    if (state !== 'idle') {
      blobWrapperEl.classList.add(state);
    }
  }
  
  // Clear existing spinner
  if (spinnerInterval) {
    clearInterval(spinnerInterval);
    spinnerInterval = null;
  }
  
  // Flat icons (SVG-style unicode)
  const micIcon = '–';       // Simple dash for idle
  const micActiveIcon = '•';  // Simple dot when active  
  const speakIcon = '—';      // Em dash for speaking
  
  // Update status indicator with ora-style spinner + flat icons
  if (!statusIndicator) return;
  
  if (state === 'idle') {
    statusIndicator.innerHTML = `<span class="mic-icon">${micIcon}</span>`;
  } else if (state === 'listening') {
    statusIndicator.innerHTML = `<span class="mic-icon mic-active">${micActiveIcon}</span>`;
    // Animate spinner
    spinnerInterval = setInterval(() => {
      spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
      if (statusIndicator) statusIndicator.innerHTML = `<span class="spinner">${spinnerFrames[spinnerIndex]}</span> <span class="mic-icon mic-active">${micActiveIcon}</span>`;
    }, 80);
  } else if (state === 'thinking') {
    spinnerInterval = setInterval(() => {
      spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
      if (statusIndicator) statusIndicator.innerHTML = `<span class="spinner">${spinnerFrames[spinnerIndex]}</span>`;
    }, 80);
  } else if (state === 'speaking') {
    statusIndicator.innerHTML = `<span class="speaking-icon">${speakIcon}</span>`;
  }
}

// ============================================
// VISUAL STATE
// ============================================
let colorHueShift = 0;
let colorSatShift = 0;
let convulsionX = 0;
let convulsionY = 0;
let aggressiveScale = 1;

// === NEW: 3D LIFE STATE ===
let breathingPhase = 0;
let breathingScale = 1;
let jitterOffsetX = 0;
let jitterOffsetY = 0;
let idleSwayX = 0;
let idleSwayY = 0;
let idleSwayPhase = Math.random() * Math.PI * 2;
let lightAngle = 0;
let isAnticipating = false;
let anticipationScale = 1;
let attentionOffsetX = 0;
let attentionOffsetY = 0;

// ============================================
// MOUSE TRACKING
// ============================================
let mouseX = window.innerWidth / 2;
let mouseY = window.innerHeight / 2;
let targetRotateX = 0;
let targetRotateY = 0;
let currentRotateX = 0;
let currentRotateY = 0;

document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  
  targetRotateY = (mouseX - centerX) * CONFIG.mouseTrackingStrength;
  targetRotateX = (centerY - mouseY) * CONFIG.mouseTrackingStrength;
  
  // Parallax for 3D orb rotation
  const parallaxX = (mouseX - centerX) / centerX; // -1 to 1
  const parallaxY = (mouseY - centerY) / centerY; // -1 to 1
  document.querySelector('.blob')?.style.setProperty('--parallax-x', parallaxX);
  document.querySelector('.blob')?.style.setProperty('--parallax-y', parallaxY);
  
  // Pressure response - orb leans toward mouse
  const dist = Math.hypot(mouseX - centerX, mouseY - centerY);
  const maxDist = Math.hypot(centerX, centerY);
  pressureX = ((mouseX - centerX) / maxDist) * 15;
  pressureY = ((mouseY - centerY) / maxDist) * 15;
  proximityGlow = 1 - (dist / maxDist);
  
  // Track interaction for self-modifying geometry
  interactionCount = Math.min(interactionCount + 0.01, 10);
});

// Gyroscope for phone parallax
let gyroX = 0, gyroY = 0;
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', (e) => {
    if (e.gamma !== null && e.beta !== null) {
      // gamma: left/right tilt (-90 to 90), beta: front/back tilt (-180 to 180)
      gyroX = e.gamma * 0.3;  // Scale down
      gyroY = (e.beta - 45) * 0.3;  // Center around 45° (holding phone)
      targetRotateY = gyroX;
      targetRotateX = -gyroY;
    }
  });
}

// Depth state
let pressureX = 0, pressureY = 0;
let proximityGlow = 0;
let pupilSize = 1;
let flickerPhase = 0;
let afterimages = [];

function updateMouseTracking() {
  // Flat orb - no rotation, just track position for other effects
  currentRotateX += (targetRotateX - currentRotateX) * 0.08;
  currentRotateY += (targetRotateY - currentRotateY) * 0.08;
  
  // No 3D rotation - keep orb flat
  if (trackingWrapper) trackingWrapper.style.transform = 'none';
}

// ============================================
// SELF-MODIFYING GEOMETRY
// ============================================
let geometryMorphState = 0;
let interactionCount = 0;

function updateGeometry() {
  if (!blob) return;
  geometryMorphState += CONFIG.geometryMorphSpeed * (1 + interactionCount * 0.1);
  
  // Gradually modify blob shape based on interaction
  const morphFactor = Math.sin(geometryMorphState) * 0.1;
  blob.style.setProperty('--morph', morphFactor.toFixed(3));
  
  // Adapt animation speed based on interaction
  const animations = blob.getAnimations();
  const adaptiveSpeed = 1 + (interactionCount / 10) * 0.5;
  animations.forEach(anim => {
    if (!anim.id || anim.id !== 'hover') {
      anim.playbackRate = adaptiveSpeed;
    }
  });
}

// ============================================
// AUDIO
// ============================================
async function initAudio() {
  if (ctx) return;
  try {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = ctx.createAnalyser();
    analyser.fftSize = CONFIG.fftSize;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    frequencyData = new Uint8Array(analyser.frequencyBinCount);
    source = ctx.createMediaElementSource(audio);
    source.connect(analyser);
    analyser.connect(ctx.destination);
  } catch (e) {
    console.error('Audio init failed:', e);
  }
}

function getFrequencyBand(lowFreq, highFreq) {
  if (!analyser) return 0;
  
  const nyquist = ctx.sampleRate / 2;
  const lowBin = Math.floor(lowFreq / nyquist * analyser.frequencyBinCount);
  const highBin = Math.floor(highFreq / nyquist * analyser.frequencyBinCount);
  
  let sum = 0;
  for (let i = lowBin; i <= highBin; i++) {
    sum += frequencyData[i];
  }
  return sum / ((highBin - lowBin + 1) * 255); // Normalize 0-1
}

function detectBeat(currentEnergy) {
  const now = Date.now();
  const timeSinceLastBeat = now - lastBeatTime;
  
  if (currentEnergy > CONFIG.startleThreshold && timeSinceLastBeat > beatInterval * 0.5) {
    beatDetected = true;
    lastBeatTime = now;
    
    // Estimate tempo from beat intervals
    if (timeSinceLastBeat < 2000 && timeSinceLastBeat > 200) {
      tempo = tempo * 0.9 + (60000 / timeSinceLastBeat) * 0.1;
      beatInterval = 60000 / tempo;
    }
    return true;
  }
  return false;
}

function updateDepth() {
  if (!analyser) return;
  
  // Time domain for onset detection
  analyser.getByteTimeDomainData(dataArray);
  analyser.getByteFrequencyData(frequencyData);
  
  // Calculate RMS energy
  let sumSquares = 0;
  for (let i = 0; i < dataArray.length; i++) {
    const normalized = (dataArray[i] - 128) / 128;
    sumSquares += normalized * normalized;
  }
  const rmsEnergy = Math.sqrt(sumSquares / dataArray.length);
  
  smoothedEnergy += (rmsEnergy - smoothedEnergy) * CONFIG.energySmoothing;
  
  // Frequency band analysis
  bassEnergy = getFrequencyBand(50, 200);
  midEnergy = getFrequencyBand(200, 2000);
  trebleEnergy = getFrequencyBand(2000, 20000);
  
  // Beat detection
  const energyDelta = smoothedEnergy - prevEnergy;
  prevEnergy = smoothedEnergy;
  
  beatDetected = detectBeat(energyDelta);
  
  if (energyDelta > CONFIG.onsetThreshold) {
    const impulse = energyDelta * CONFIG.onsetSensitivity * CONFIG.intensity;
    depth = Math.min(1.0, depth + impulse);
    
    // Trigger startle on strong onset
    if (energyDelta > CONFIG.startleThreshold) {
      triggerStartle();
    }
    
    // Trigger tentacle on strong onset
    if (energyDelta > CONFIG.startleThreshold * 0.7 && tentacles.length < CONFIG.maxTentacles) {
      spawnTentacle();
    }
    
    // Spin impulse on beats
    if (beatDetected) {
      spinVelocity += CONFIG.spinImpulse * (0.5 + Math.random() * 0.5);
      if (Math.random() > 0.7) spinVelocity *= -1; // Random direction change
    }
    
    // Spawn ripple
    if (ripples.length < CONFIG.maxRipples && Math.random() > 0.6) {
      spawnRipple();
    }
  }
  
  depth = CONFIG.baseDepth + (depth - CONFIG.baseDepth) * CONFIG.depthDecay;
  smoothedDepth += (depth - smoothedDepth) * CONFIG.depthSmoothing;
  if (blob) blob.style.setProperty('--depth', smoothedDepth.toFixed(3));
}

// ============================================
// ALIEN BEHAVIORS
// ============================================

// 1. AUTONOMOUS WANDERING
function updateWandering(time) {
  orbitAngle += CONFIG.wanderSpeed;
  
  // Orbital motion with audio influence
  const orbitRadius = CONFIG.wanderRadius * (1 + smoothedEnergy * 1.5);
  const bassInfluence = bassEnergy * 40; // Bass pulls down
  const trebleInfluence = trebleEnergy * 40; // Treble lifts up
  
  const targetX = Math.cos(orbitAngle) * orbitRadius;
  const targetY = Math.sin(orbitAngle) * orbitRadius + bassInfluence - trebleInfluence;
  
  // Perlin-like drift
  const driftX = Math.sin(time * 0.0003) * Math.cos(time * 0.0007) * 20;
  const driftY = Math.cos(time * 0.0005) * Math.sin(time * 0.0009) * 20;
  
  orbVelX += (targetX + driftX - orbX) * CONFIG.driftSpeed;
  orbVelY += (targetY + driftY - orbY) * CONFIG.driftSpeed;
  
  orbX += orbVelX;
  orbY += orbVelY;
  
  orbVelX *= 0.95;
  orbVelY *= 0.95;
  
  // Elastic boundaries
  const maxDist = Math.min(window.innerWidth, window.innerHeight) * 0.4;
  const dist = Math.sqrt(orbX * orbX + orbY * orbY);
  if (dist > maxDist) {
    const angle = Math.atan2(orbY, orbX);
    orbX = Math.cos(angle) * maxDist;
    orbY = Math.sin(angle) * maxDist;
    orbVelX *= -0.5;
    orbVelY *= -0.5;
  }
}

// 2. STARTLE BEHAVIOR
function triggerStartle() {
  const angle = Math.random() * Math.PI * 2;
  startleVelX = Math.cos(angle) * CONFIG.startleDistance;
  startleVelY = Math.sin(angle) * CONFIG.startleDistance;
  startleRotation = (Math.random() - 0.5) * CONFIG.startleRotation * 2;
}

function updateStartle() {
  orbX += startleVelX;
  orbY += startleVelY;
  
  startleVelX *= CONFIG.startleDecay;
  startleVelY *= CONFIG.startleDecay;
  startleRotation *= CONFIG.startleDecay;
}

// 3. FREQUENCY DEFORMATION
function updateAsymmetricDeformation() {
  const targetBass = bassEnergy * CONFIG.deformationStrength;
  const targetMid = midEnergy * CONFIG.deformationStrength;
  const targetTreble = trebleEnergy * CONFIG.deformationStrength;
  
  bassDeform += (targetBass - bassDeform) * 0.2;
  midDeform += (targetMid - midDeform) * 0.2;
  trebleDeform += (targetTreble - trebleDeform) * 0.2;
}

// 4. SPIN/ROTATION
function updateSpin() {
  spinAngle += spinVelocity;
  spinVelocity *= CONFIG.spinDecay;
  
  // Wobble the rotation axis
  const wobbleX = Math.sin(spinAngle * 0.3) * 10 * Math.abs(spinVelocity);
  const wobbleY = Math.cos(spinAngle * 0.5) * 10 * Math.abs(spinVelocity);
  
  return { angle: spinAngle, wobbleX, wobbleY };
}

// 5. RIPPLE SYSTEM
function spawnRipple() {
  const angle = Math.random() * Math.PI * 2;
  ripples.push({
    x: Math.cos(angle) * 0.5,
    y: Math.sin(angle) * 0.5,
    radius: 0,
    maxRadius: 0.6 + Math.random() * 0.4,
    alpha: 1
  });
}

function updateRipples() {
  ripples.forEach(ripple => {
    ripple.radius += CONFIG.rippleSpeed * 0.01;
    ripple.alpha = 1 - (ripple.radius / ripple.maxRadius);
  });
  
  ripples = ripples.filter(r => r.radius < r.maxRadius);
}

// 6. AGGRESSIVE PULSE
function updateAggressivePulse() {
  // Calculate target scale based on audio
  const attackTime = bassEnergy * 0.2 + trebleEnergy * 0.8; // Treble = fast, bass = slow
  const targetScale = CONFIG.aggressivePulseMin + (smoothedEnergy * (CONFIG.aggressivePulseMax - CONFIG.aggressivePulseMin));
  
  // Overshoot and elastic bounce
  const diff = targetScale - aggressiveScale;
  aggressiveScale += diff * (0.1 + attackTime * 0.3);
  
  // Apply to breathing animation
  if (blob) blob.style.setProperty('animation-duration', `${4 - attackTime * 2}s`);
}

// 7. TENTACLES
function spawnTentacle() {
  const angle = Math.random() * Math.PI * 2;
  tentacles.push({
    angle: angle,
    length: 0,
    maxLength: CONFIG.tentacleLength * (0.7 + Math.random() * 0.6),
    life: 1
  });
}

function updateTentacles() {
  tentacles.forEach(t => {
    if (t.length < t.maxLength) {
      t.length += 8;
    } else {
      t.life -= 0.02;
    }
  });
  
  tentacles = tentacles.filter(t => t.life > 0);
}

// 8. COLOR TEMPERATURE SHIFTS
function updateColorShifts() {
  // Bass = warm (orange), treble = cool (cyan)
  const targetHue = (bassEnergy - trebleEnergy) * CONFIG.colorShiftAmount;
  const targetSat = (bassEnergy + trebleEnergy) * 0.05;
  
  colorHueShift += (targetHue - colorHueShift) * 0.15;
  colorSatShift += (targetSat - colorSatShift) * 0.15;
}

// 9. TEMPO-SYNCED CONVULSIONS  
function updateConvulsions() {
  if (beatDetected) {
    convulsionX = (Math.random() - 0.5) * CONFIG.convulsionAmount;
    convulsionY = (Math.random() - 0.5) * CONFIG.convulsionAmount;
  }
  
  convulsionX *= 0.8;
  convulsionY *= 0.8;
}

// 10. GRAVITATIONAL SLINGSHOT
function updateGravity() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  
  const dx = mouseX - centerX;
  const dy = mouseY - centerY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < CONFIG.gravityRadius && distance > 10) {
    // Attract orb toward cursor
    const force = CONFIG.gravityStrength * (1 - distance / CONFIG.gravityRadius);
    const angle = Math.atan2(dy, dx);
    
    orbVelX += Math.cos(angle) * force;
    orbVelY += Math.sin(angle) * force;
    
    // Add perpendicular velocity for orbit effect
    orbVelX += -Math.sin(angle) * force * 0.5;
    orbVelY += Math.cos(angle) * force * 0.5;
    
    // If getting too close, apply escape velocity
    if (distance < 50) {
      orbVelX += -Math.cos(angle) * CONFIG.escapeVelocity;
      orbVelY += -Math.sin(angle) * CONFIG.escapeVelocity;
    }
  }
}

// ============================================
// 3D LIFE ENHANCEMENTS
// ============================================

// 11. BREATHING RHYTHM - Slow organic scale pulse
function updateBreathing(time) {
  breathingPhase = (time % CONFIG.breathingCycle) / CONFIG.breathingCycle;
  const breath = Math.sin(breathingPhase * Math.PI * 2);
  breathingScale = CONFIG.breathingMin + (breath + 1) * 0.5 * (CONFIG.breathingMax - CONFIG.breathingMin);
}

// 12. MICRO-JITTER - Tiny random position offsets for organic feel
function updateJitter(time) {
  const jitterPhase = time * CONFIG.jitterSpeed;
  jitterOffsetX = (Math.sin(jitterPhase * 7.3) + Math.sin(jitterPhase * 11.7)) * CONFIG.jitterAmount * 0.5;
  jitterOffsetY = (Math.cos(jitterPhase * 8.9) + Math.cos(jitterPhase * 13.1)) * CONFIG.jitterAmount * 0.5;
}

// 13. IDLE SWAY - Gentle floating motion when not active
function updateIdleSway(time) {
  idleSwayPhase += CONFIG.idleSwaySpeed;
  // Figure-8 pattern for organic movement
  idleSwayX = Math.sin(idleSwayPhase) * Math.cos(idleSwayPhase * 0.5) * CONFIG.idleSwayAmount;
  idleSwayY = Math.sin(idleSwayPhase * 0.7) * CONFIG.idleSwayAmount * 0.6;
}

// 14. LIGHT SOURCE - Rotating specular highlight and rim light
function updateLighting(time) {
  lightAngle += CONFIG.lightAngleSpeed;
}

// 15. AUDIO ANTICIPATION - Slight shrink before speaking
function triggerAnticipation() {
  if (isAnticipating) return;
  isAnticipating = true;
  anticipationScale = CONFIG.anticipationShrink;
  setTimeout(() => {
    isAnticipating = false;
    anticipationScale = 1.05; // Slight expand after
    setTimeout(() => { anticipationScale = 1; }, 200);
  }, CONFIG.anticipationDuration);
}

// 16. ATTENTION - Subtle lean toward mouse
function updateAttention() {
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  const dx = mouseX - centerX;
  const dy = mouseY - centerY;
  
  attentionOffsetX += (dx * CONFIG.attentionStrength - attentionOffsetX) * 0.05;
  attentionOffsetY += (dy * CONFIG.attentionStrength - attentionOffsetY) * 0.05;
}

// Draw lighting effects on canvas
function drawLighting() {
  if (!effectsCtx) return;
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.28;
  
  // Specular highlight (bright spot that rotates)
  const specX = centerX + Math.cos(lightAngle) * blobSize * 0.3;
  const specY = centerY + Math.sin(lightAngle) * blobSize * 0.3;
  const specGradient = effectsCtx.createRadialGradient(specX, specY, 0, specX, specY, blobSize * 0.4);
  specGradient.addColorStop(0, `rgba(255, 255, 255, ${CONFIG.specularIntensity})`);
  specGradient.addColorStop(0.5, `rgba(255, 255, 255, ${CONFIG.specularIntensity * 0.3})`);
  specGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  effectsCtx.fillStyle = specGradient;
  effectsCtx.beginPath();
  effectsCtx.arc(centerX, centerY, blobSize * 1.1, 0, Math.PI * 2);
  effectsCtx.fill();
  
  // Rim lighting (edge glow opposite to light)
  const rimAngle = lightAngle + Math.PI;
  const rimX = centerX + Math.cos(rimAngle) * blobSize * 0.85;
  const rimY = centerY + Math.sin(rimAngle) * blobSize * 0.85;
  const rimGradient = effectsCtx.createRadialGradient(rimX, rimY, 0, rimX, rimY, blobSize * 0.5);
  rimGradient.addColorStop(0, `rgba(200, 220, 255, ${CONFIG.rimLightIntensity})`);
  rimGradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
  effectsCtx.fillStyle = rimGradient;
  effectsCtx.beginPath();
  effectsCtx.arc(rimX, rimY, blobSize * 0.5, 0, Math.PI * 2);
  effectsCtx.fill();
  
  // Shadow gradient (dark region opposite light)
  const shadowAngle = lightAngle + Math.PI;
  const shadowX = centerX + Math.cos(shadowAngle) * blobSize * 0.2;
  const shadowY = centerY + Math.sin(shadowAngle) * blobSize * 0.2;
  const shadowGradient = effectsCtx.createRadialGradient(shadowX, shadowY, 0, centerX, centerY, blobSize);
  shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.08)');
  shadowGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.03)');
  shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  effectsCtx.fillStyle = shadowGradient;
  effectsCtx.beginPath();
  effectsCtx.arc(centerX, centerY, blobSize, 0, Math.PI * 2);
  effectsCtx.fill();
}

// ============================================
// DEPTH EFFECTS
// ============================================
const orbShadow = document.querySelector('.orb-shadow');
const afterimageContainer = document.getElementById('afterimageContainer');
const pupilCore = document.querySelector('.pupil-core');
const dimensionalFlicker = document.querySelector('.dimensional-flicker');

let lastOrbX = 0, lastOrbY = 0;
let membraneRippleTimer = 0;

function updateDepthEffects(time) {
  // Breathing shadow
  if (orbShadow) {
    const shadowScale = 0.8 + breathingScale * 0.2 + smoothedEnergy * 0.3;
    orbShadow.style.transform = `translateX(-50%) scaleX(${shadowScale}) scaleY(${shadowScale * 0.5})`;
    orbShadow.style.opacity = 0.25 + smoothedEnergy * 0.15;
  }
  
  // Pupil dilation based on audio energy
  if (pupilCore) {
    pupilSize = 15 - smoothedEnergy * 10; // Contracts with sound
    const size = Math.max(5, pupilSize);
    pupilCore.style.width = size + '%';
    pupilCore.style.height = size + '%';
  }
  
  // Dimensional flicker (rare subtle glitch)
  flickerPhase += 0.01;
  if (dimensionalFlicker && Math.random() < 0.001) {
    dimensionalFlicker.style.opacity = 0.15;
    setTimeout(() => { dimensionalFlicker.style.opacity = 0; }, 80);
  }
  
  // Pressure response (lean toward mouse) - smooth
  if (blobWrapper) {
    blobWrapper.style.marginLeft = (pressureX * 0.5) + 'px';
    blobWrapper.style.marginTop = (pressureY * 0.5) + 'px';
  }
  
  // Afterimage trail when moving fast
  const velocity = Math.hypot(orbX - lastOrbX, orbY - lastOrbY);
  if (velocity > 3 && afterimageContainer) {
    createAfterimage(orbX, orbY);
  }
  lastOrbX = orbX;
  lastOrbY = orbY;
  
  // Membrane ripples on beat
  membraneRippleTimer++;
  if (beatDetected && membraneRippleTimer > 15) {
    createMembraneRipple();
    membraneRippleTimer = 0;
  }
}

function createAfterimage(x, y) {
  const afterimage = document.createElement('div');
  afterimage.className = 'afterimage';
  const size = Math.min(window.innerWidth, window.innerHeight) * 0.25;
  afterimage.style.cssText = `
    left: ${window.innerWidth/2 + x - size/2}px;
    top: ${window.innerHeight/2 + y - size/2}px;
    width: ${size}px;
    height: ${size}px;
  `;
  afterimageContainer.appendChild(afterimage);
  setTimeout(() => afterimage.remove(), 300);
}

function createMembraneRipple() {
  const ripple = document.createElement('div');
  ripple.className = 'membrane-ripple';
  const size = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  ripple.style.cssText = `
    left: 50%;
    top: 50%;
    width: ${size}px;
    height: ${size}px;
  `;
  blobWrapper.appendChild(ripple);
  setTimeout(() => ripple.remove(), 1000);
}

// ============================================
// MAIN LOOP
// ============================================
function animate(time) {
  // Clear canvas
  if (effectsCtx && effectsCanvas) {
    effectsCtx.clearRect(0, 0, effectsCanvas.width, effectsCanvas.height);
  }
  
  // Update star field (deep space background)
  if (starField) {
    starField.frame({ bass: smoothedEnergy, beat: beatDetected ? 1 : 0 });
  }
  
  // Update orb tunnel with audio data
  if (orbTunnel) {
    orbTunnel.frame({ bass: smoothedEnergy, beat: beatDetected ? 1 : 0, average: depth });
  }
  
  // Core updates
  updateMouseTracking();
  updateDepth();
  updateGeometry();
  
  // Alien behaviors
  updateWandering(time);
  updateStartle();
  updateAsymmetricDeformation();
  const spinData = updateSpin();
  updateRipples();
  updateAggressivePulse();
  updateTentacles();
  updateColorShifts();
  updateConvulsions();
  updateGravity();
  
  // 3D Life enhancements
  updateBreathing(time);
  updateJitter(time);
  updateIdleSway(time);
  updateLighting(time);
  updateAttention();
  
  // Pixelated depth effects
  updateDepthEffects(time);
  
  // Combine all position offsets
  const finalX = orbX + convulsionX + jitterOffsetX + idleSwayX + attentionOffsetX;
  const finalY = orbY + convulsionY + jitterOffsetY + idleSwayY + attentionOffsetY;
  
  // Combine all scale factors
  const finalScale = aggressiveScale * breathingScale * anticipationScale;
  
  if (blobWrapper) blobWrapper.style.transform = `translate(${finalX}px, ${finalY}px) scale(${finalScale})`;
  
  // Apply spin rotation
  const spinTransform = `rotate(${spinData.angle}rad) rotateX(${spinData.wobbleX}deg) rotateY(${spinData.wobbleY}deg)`;
  if (blob) {
    blob.style.transform = spinTransform;
    
    // Apply asymmetric deformation to shape
    blob.style.setProperty('--bass-deform', bassDeform.toFixed(3));
    blob.style.setProperty('--mid-deform', midDeform.toFixed(3));
    blob.style.setProperty('--treble-deform', trebleDeform.toFixed(3));
    
    // Apply color shifts - add subtle blue/violet tint
    const hue = colorHueShift - 10; // Shift toward blue
    const sat = colorSatShift * 100;
    blob.style.filter = `hue-rotate(${hue}deg) saturate(${1 + sat}%)`;
  }
  
  // Draw lighting effects (specular, rim, shadow)
  drawLighting();
  
  // Draw tentacles
  drawTentacles();
  
  // Draw ripples
  drawRipples();
  
  // Interaction decay
  interactionCount *= 0.995;
  beatDetected = false; // Reset beat flag
  
  requestAnimationFrame(animate);
}

// ============================================
// INITIALIZATION
// ============================================
initAstralParticles();

// Keyboard shortcut - spacebar to toggle listening
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
    e.preventDefault();
    if (Ares.isListening) {
      Ares.stopListening();
    } else {
      Ares.startListening();
    }
  }
});

// Start animation loop
animate(0);

// Click interaction effects
document.body.addEventListener('click', async (e) => {
  // Boost interaction count
  interactionCount = Math.min(interactionCount + 2, 10);
  
  // Start audio if paused
  await initAudio();
  if (audio.paused) {
    try {
      await audio.play();
    } catch (e) {
      console.error('Play failed:', e);
    }
  }
}, { once: false });

// ============================================
// ARES - Click orb to speak
// ============================================
const Ares = {
  recognition: null,
  synthesis: window.speechSynthesis,
  isListening: false,
  isSpeaking: false,
  voice: null,
  
  firstClick: true,
  lastSpoken: null,
  
  pollRetryDelay: 1000,
  maxPollRetry: 30000,
  pollActive: false,
  
  init() {
    this.setupSpeechRecognition();
    this.findVoice();
    this.setupClickToSpeak();
    this.setupTextInput();
    // Only poll if server is running (skip for standalone HTML)
    this.startPolling();
    
    // Circuit breaker: pause polling when tab hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.pollActive = false;
      } else if (!this.pollActive) {
        this.pollActive = true;
        this.pollForTTS();
      }
    });
  },
  
  startPolling() {
    fetch('/poll', { signal: AbortSignal.timeout(5000) })
      .then(() => {
        this.pollRetryDelay = 1000; // Reset on success
        this.pollActive = true;
        this.pollForTTS();
      })
      .catch(() => {
        // Server not available, retry with backoff (silent)
        this.pollRetryDelay = Math.min(this.pollRetryDelay * 1.5, this.maxPollRetry);
        setTimeout(() => this.startPolling(), this.pollRetryDelay);
      });
  },
  
  setupClickToSpeak() {
    document.body.addEventListener('click', () => {
      // If speaking, cancel and allow new input
      if (this.isSpeaking) {
        this.synthesis.cancel();
        this.isSpeaking = false;
        setUIState('idle');
      }
      
      // First click just activates audio context, then start listening
      if (this.firstClick) {
        this.firstClick = false;
      }
      
      if (this.isListening) {
        this.stopListening();
      } else {
        this.startListening();
      }
    });
  },
  
  setupSpeechRecognition() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return;
    
    this.recognition = new SR();
    this.recognition.continuous = false;
    this.recognition.interimResults = false;
    this.recognition.lang = 'en-US';
    
    this.recognition.onresult = (e) => {
      const text = e.results[0][0].transcript;
      setUIState('thinking');
      this.send(text);
    };
    
    this.recognition.onend = () => {
      this.isListening = false;
      if (uiState === 'listening') setUIState('idle');
      document.body.style.cursor = 'pointer';
    };
    
    this.recognition.onerror = () => {
      this.isListening = false;
      setUIState('idle');
    };
  },
  
  setupTextInput() {
    const input = document.getElementById('aresInput');
    if (!input) return;
    
    const defaultText = input.dataset.placeholder || 'Johann sin AI';
    
    // Handle Enter key to send message
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const text = input.innerText.trim();
        if (text && text !== defaultText) {
          setUIState('thinking');
          this.send(text);
          input.innerText = '';  // Clear, don't restore default
          // Don't blur - placeholder will show via CSS :empty
        }
      }
    });
    
    // Clear default text immediately on click/focus
    input.addEventListener('click', (e) => {
      e.stopPropagation();
      if (input.innerText.trim() === defaultText) {
        input.innerText = '';
      }
    });
    
    input.addEventListener('focus', () => {
      if (input.innerText.trim() === defaultText) {
        input.innerText = '';
      }
    });
    
    // Restore default text if empty on blur
    input.addEventListener('blur', () => {
      if (!input.innerText.trim()) {
        input.innerText = defaultText;
      }
    });
  },
  
  findVoice() {
    const load = () => {
      this.allVoices = this.synthesis.getVoices();
      // Prefer warm, natural-sounding voices
      const prefer = ['Samantha', 'Karen', 'Evan', 'Tom', 'Google US English Male', 'Microsoft Guy', 'Reed'];
      for (const n of prefer) {
        const v = this.allVoices.find(v => v.name.includes(n));
        if (v) { this.voice = v; return; }
      }
      this.voice = this.allVoices.find(v => v.lang === 'en-US') || this.allVoices.find(v => v.lang.startsWith('en')) || this.allVoices[0];
    };
    if (this.synthesis.getVoices().length) load();
    else this.synthesis.onvoiceschanged = load;
  },
  
  // Voice profiles for browser TTS - ronin style (low, slow, minimal)
  voiceProfiles: {
    ronin: { pitch: 0.6, rate: 0.65 },            // Deep, deliberate, samurai
    default: { pitch: 0.6, rate: 0.65 }
  },
  
  currentPersona: 'ronin',
  
  startListening() {
    if (!this.recognition || this.isListening) return;
    this.isListening = true;
    setUIState('listening');
    document.body.style.cursor = 'crosshair';
    if (typeof depth !== 'undefined') depth = 0.8;
    try { this.recognition.start(); } catch(e) { /* expected if already started */ }
  },
  
  stopListening() {
    if (!this.recognition) return;
    this.isListening = false;
    setUIState('idle');
    try { this.recognition.stop(); } catch(e) { /* expected if already stopped */ }
  },
  
  send(message) {
    // Visual feedback via depth
    if (typeof depth !== 'undefined') depth = 0.6;
    
    fetch('/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message }),
      keepalive: true
    })
      .then(r => r.json())
      .then(data => { 
        if (data.response) {
          // If server provided audio URL, play that instead of browser TTS
          if (data.audio) {
            this.playServerAudio(data.audio, data.response);
          } else {
            this.speak(data.response);
          }
        }
      })
      .catch(() => this.speak("Connection issues... but I'm still thinking about you."));
  },
  
  pollForTTS() {
    // Circuit breaker: stop if inactive or tab hidden
    if (!this.pollActive || document.hidden) return;
    
    fetch('/poll', { signal: AbortSignal.timeout(10000) })
      .then(r => r.json())
      .then(data => {
        if (!this.pollActive) return; // Check again after async
        this.pollRetryDelay = 1000; // Reset on success
        // Update persona if server sent one
        if (data.persona && data.persona !== this.currentPersona) {
          this.setPersona(data.persona);
        }
        // Play server audio if available
        if (data.audio && !this.isSpeaking) {
          this.playServerAudio(data.audio, data.text);
        }
        // Fallback to browser TTS if text but no audio
        else if (data.text && data.text !== this.lastSpoken && !this.isSpeaking) {
          this.speak(data.text);
        }
        if (this.pollActive) setTimeout(() => this.pollForTTS(), 1000);
      })
      .catch(() => {
        if (!this.pollActive) return;
        // Retry with exponential backoff (silent)
        this.pollRetryDelay = Math.min(this.pollRetryDelay * 1.5, this.maxPollRetry);
        if (this.pollActive) setTimeout(() => this.pollForTTS(), this.pollRetryDelay);
      });
  },
  
  // Play audio from server (ElevenLabs)
  playServerAudio(url, text) {
    this.lastSpoken = text;
    
    // Trigger anticipation animation
    if (typeof triggerAnticipation === 'function') triggerAnticipation();
    
    const audio = new Audio(url);
    audio.onplay = () => {
      this.isSpeaking = true;
      setUIState('speaking');
      if (typeof depth !== 'undefined') depth = 0.7;
    };
    audio.onended = () => {
      this.isSpeaking = false;
      setUIState('idle');
    };
    audio.onerror = () => {
      // Fallback to browser TTS
      if (text) this.speak(text);
    };
    audio.play().catch(() => {
      if (text) this.speak(text);
    });
  },
  
  speak(text) {
    if (!this.synthesis || !text) return;
    this.synthesis.cancel();
    
    // Trigger anticipation animation before speaking
    if (typeof triggerAnticipation === 'function') triggerAnticipation();
    
    const clean = text.replace(/```[\s\S]*?```/g, '').replace(/\*[^*]+\*/g, '').replace(/[#_`]/g, '').slice(0, 800);
    this.lastSpoken = text;
    
    // Get voice profile for current persona
    const profile = this.voiceProfiles[this.currentPersona] || this.voiceProfiles.default;
    
    const u = new SpeechSynthesisUtterance(clean);
    u.voice = this.voice;
    u.rate = profile.rate;
    u.pitch = profile.pitch;
    
    u.onstart = () => { 
      this.isSpeaking = true; 
      setUIState('speaking');
      if (typeof depth !== 'undefined') depth = 0.7;
    };
    u.onend = () => { 
      this.isSpeaking = false; 
      setUIState('idle');
    };
    
    this.synthesis.speak(u);
  },
  
  setPersona(name) {
    this.currentPersona = name;
    console.log('Persona:', name, this.voiceProfiles[name] || this.voiceProfiles.default);
  }
};

Ares.init();
</script>

</body>
</html>
