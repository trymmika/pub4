<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Organic AI Orb</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
<style>
/* ============================================
   CUSTOM PROPERTIES
   ============================================ */
@property --s1 { syntax: "<angle>"; inherits: false; initial-value: 0deg; }
@property --s2 { syntax: "<angle>"; inherits: false; initial-value: 0deg; }
@property --s3 { syntax: "<angle>"; inherits: false; initial-value: 0deg; }
@property --rotation { syntax: "<angle>"; inherits: false; initial-value: 0deg; }

@property --mesh-x-0 { syntax: "<percentage>"; inherits: false; initial-value: 85%; }
@property --mesh-y-0 { syntax: "<percentage>"; inherits: false; initial-value: 80%; }
@property --mesh-c-0 { syntax: "<color>"; inherits: false; initial-value: hsla(0, 0%, 92%, 1); }
@property --mesh-s-start-0 { syntax: "<percentage>"; inherits: false; initial-value: 9%; }
@property --mesh-s-end-0 { syntax: "<percentage>"; inherits: false; initial-value: 55%; }

@property --mesh-x-1 { syntax: "<percentage>"; inherits: false; initial-value: 60%; }
@property --mesh-y-1 { syntax: "<percentage>"; inherits: false; initial-value: 24%; }
@property --mesh-c-1 { syntax: "<color>"; inherits: false; initial-value: hsla(0, 0%, 88%, 1); }
@property --mesh-s-start-1 { syntax: "<percentage>"; inherits: false; initial-value: 5%; }
@property --mesh-s-end-1 { syntax: "<percentage>"; inherits: false; initial-value: 72%; }

@property --mesh-x-2 { syntax: "<percentage>"; inherits: false; initial-value: 13%; }
@property --mesh-y-2 { syntax: "<percentage>"; inherits: false; initial-value: 82%; }
@property --mesh-c-2 { syntax: "<color>"; inherits: false; initial-value: hsla(0, 0%, 85%, 0.6); }
@property --mesh-s-start-2 { syntax: "<percentage>"; inherits: false; initial-value: 5%; }
@property --mesh-s-end-2 { syntax: "<percentage>"; inherits: false; initial-value: 52%; }

@property --mesh-x-3 { syntax: "<percentage>"; inherits: false; initial-value: 24%; }
@property --mesh-y-3 { syntax: "<percentage>"; inherits: false; initial-value: 7%; }
@property --mesh-c-3 { syntax: "<color>"; inherits: false; initial-value: hsla(0, 0%, 90%, 1); }
@property --mesh-s-start-3 { syntax: "<percentage>"; inherits: false; initial-value: 13%; }
@property --mesh-s-end-3 { syntax: "<percentage>"; inherits: false; initial-value: 68%; }

/* ============================================
   KEYFRAMES
   ============================================ */
@keyframes s1 { to { --s1: 360deg; } }
@keyframes s2 { to { --s2: 360deg; } }
@keyframes s3 { to { --s3: 360deg; } }
@keyframes rotation { to { --rotation: 360deg; } }

@keyframes mesh-gradient {
  0% {
    --mesh-x-0: 85%; --mesh-y-0: 80%;
    --mesh-c-1: hsla(0, 0%, 88%, 1);
    --mesh-x-1: 60%; --mesh-y-1: 24%;
    --mesh-x-2: 13%; --mesh-y-2: 82%;
    --mesh-x-3: 24%; --mesh-y-3: 7%;
  }
  100% {
    --mesh-x-0: 31%; --mesh-y-0: 94%;
    --mesh-c-1: hsla(0, 0%, 90%, 1);
    --mesh-x-1: 2%; --mesh-y-1: 25%;
    --mesh-x-2: 98%; --mesh-y-2: 20%;
    --mesh-x-3: 95%; --mesh-y-3: 92%;
  }
}

@keyframes breathe {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes core-pulse {
  0%, 100% { 
    opacity: 0.6;
    transform: translate(-50%, -50%) scale(1);
  }
  50% { 
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.2);
  }
}

@keyframes quantum-shimmer {
  0%, 100% { opacity: 0.3; transform: scale(1); }
  50% { opacity: 0.6; transform: scale(1.1); }
}

@keyframes grain-jitter {
  0%, 100% { transform: translate(1px, 6px); }
  10% { transform: translate(-8px, 14px); }
  20% { transform: translate(9px, 13px); }
  30% { transform: translate(-10px, -11px); }
  40% { transform: translate(14px, -7px); }
  50% { transform: translate(-13px, -6px); }
  60% { transform: translate(10px, 9px); }
  70% { transform: translate(-14px, -8px); }
  80% { transform: translate(9px, 6px); }
  90% { transform: translate(-10px, 7px); }
}

@keyframes light-leak {
  0%, 100% { opacity: 0; }
  50% { opacity: 0.2; }
}

/* ============================================
   BASE
   ============================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
}

h1 {
  position: fixed;
  top: 20px;
  left: 20px;
  margin: 0;
  font-family: "Inter", sans-serif;
  font-optical-sizing: auto;
  font-size: 18px;
  font-weight: 600;
  font-style: normal;
  color: #fff;
  letter-spacing: -0.02em;
  z-index: 1000;
}

/* ============================================
   STAGE
   ============================================ */
.stage {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
}

#effects-canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.tracking-wrapper {
  transition: transform 0.15s ease-out;
  transform-style: preserve-3d;
}

.blob-wrapper {
  width: 60vmin;
  height: 60vmin;
  filter: url(#edge-displacement) url(#glow);
  animation: breathe 4s ease-in-out infinite;
  transform-origin: center center;
}

.blob {
  position: relative;
  width: 100%;
  height: 100%;
  background: #000;
  background-image:
    radial-gradient(circle at var(--mesh-x-0) var(--mesh-y-0), var(--mesh-c-0) var(--mesh-s-start-0), transparent var(--mesh-s-end-0)),
    radial-gradient(circle at var(--mesh-x-1) var(--mesh-y-1), var(--mesh-c-1) var(--mesh-s-start-1), transparent var(--mesh-s-end-1)),
    radial-gradient(circle at var(--mesh-x-2) var(--mesh-y-2), var(--mesh-c-2) var(--mesh-s-start-2), transparent var(--mesh-s-end-2)),
    radial-gradient(circle at var(--mesh-x-3) var(--mesh-y-3), var(--mesh-c-3) var(--mesh-s-start-3), transparent var(--mesh-s-end-3));
  
  --depth: 0.3;
  --bass-deform: 0;
  --mid-deform: 0;
  --treble-deform: 0;
  animation: s1 7s linear infinite, s2 11s linear infinite, s3 13s linear infinite, mesh-gradient 10s linear infinite alternate;
}

.blob-shape {
  --angle0: 0deg; --p1-0: 0deg; --p2-0: 0deg; --p3-0: 0deg;
  --angle1: 51.43deg; --p1-1: 137.5deg; --p2-1: 222.5deg; --p3-1: 360.1deg;
  --angle2: 102.86deg; --p1-2: 275deg; --p2-2: 85deg; --p3-2: 80.2deg;
  --angle3: 154.29deg; --p1-3: 52.5deg; --p2-3: 307.5deg; --p3-3: 200.3deg;
  --angle4: 205.71deg; --p1-4: 190deg; --p2-4: 170deg; --p3-4: 320.4deg;
  --angle5: 257.14deg; --p1-5: 327.5deg; --p2-5: 32.5deg; --p3-5: 80.5deg;
  --angle6: 308.57deg; --p1-6: 105deg; --p2-6: 255deg; --p3-6: 200.6deg;

  --rand0: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-0)) + 0.3 * sin(var(--s2) + var(--p2-0)) + 0.2 * sin(var(--s3) + var(--p3-0))));
  --d0: calc(50 * (1 - var(--depth)) + 50 * var(--rand0) * var(--depth));
  --x0: calc((50 + var(--d0) * cos(var(--rotation) + var(--angle0))) * 1%);
  --y0: calc((50 + var(--d0) * sin(var(--rotation) + var(--angle0))) * 1%);

  --rand1: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-1)) + 0.3 * sin(var(--s2) + var(--p2-1)) + 0.2 * sin(var(--s3) + var(--p3-1))));
  --d1: calc(50 * (1 - var(--depth)) + 50 * var(--rand1) * var(--depth));
  --x1: calc((50 + var(--d1) * cos(var(--rotation) + var(--angle1))) * 1%);
  --y1: calc((50 + var(--d1) * sin(var(--rotation) + var(--angle1))) * 1%);

  --rand2: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-2)) + 0.3 * sin(var(--s2) + var(--p2-2)) + 0.2 * sin(var(--s3) + var(--p3-2))));
  --d2: calc(50 * (1 - var(--depth)) + 50 * var(--rand2) * var(--depth));
  --x2: calc((50 + var(--d2) * cos(var(--rotation) + var(--angle2))) * 1%);
  --y2: calc((50 + var(--d2) * sin(var(--rotation) + var(--angle2))) * 1%);

  --rand3: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-3)) + 0.3 * sin(var(--s2) + var(--p2-3)) + 0.2 * sin(var(--s3) + var(--p3-3))));
  --d3: calc(50 * (1 - var(--depth)) + 50 * var(--rand3) * var(--depth));
  --x3: calc((50 + var(--d3) * cos(var(--rotation) + var(--angle3))) * 1%);
  --y3: calc((50 + var(--d3) * sin(var(--rotation) + var(--angle3))) * 1%);

  --rand4: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-4)) + 0.3 * sin(var(--s2) + var(--p2-4)) + 0.2 * sin(var(--s3) + var(--p3-4))));
  --d4: calc(50 * (1 - var(--depth)) + 50 * var(--rand4) * var(--depth));
  --x4: calc((50 + var(--d4) * cos(var(--rotation) + var(--angle4))) * 1%);
  --y4: calc((50 + var(--d4) * sin(var(--rotation) + var(--angle4))) * 1%);

  --rand5: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-5)) + 0.3 * sin(var(--s2) + var(--p2-5)) + 0.2 * sin(var(--s3) + var(--p3-5))));
  --d5: calc(50 * (1 - var(--depth)) + 50 * var(--rand5) * var(--depth));
  --x5: calc((50 + var(--d5) * cos(var(--rotation) + var(--angle5))) * 1%);
  --y5: calc((50 + var(--d5) * sin(var(--rotation) + var(--angle5))) * 1%);

  --rand6: calc(0.5 + 0.5 * (0.5 * sin(var(--s1) + var(--p1-6)) + 0.3 * sin(var(--s2) + var(--p2-6)) + 0.2 * sin(var(--s3) + var(--p3-6))));
  --d6: calc(50 * (1 - var(--depth)) + 50 * var(--rand6) * var(--depth));
  --x6: calc((50 + var(--d6) * cos(var(--rotation) + var(--angle6))) * 1%);
  --y6: calc((50 + var(--d6) * sin(var(--rotation) + var(--angle6))) * 1%);

  --mx0: calc((var(--x0) + var(--x1)) / 2); --my0: calc((var(--y0) + var(--y1)) / 2);
  --mx1: calc((var(--x1) + var(--x2)) / 2); --my1: calc((var(--y1) + var(--y2)) / 2);
  --mx2: calc((var(--x2) + var(--x3)) / 2); --my2: calc((var(--y2) + var(--y3)) / 2);
  --mx3: calc((var(--x3) + var(--x4)) / 2); --my3: calc((var(--y3) + var(--y4)) / 2);
  --mx4: calc((var(--x4) + var(--x5)) / 2); --my4: calc((var(--y4) + var(--y5)) / 2);
  --mx5: calc((var(--x5) + var(--x6)) / 2); --my5: calc((var(--y5) + var(--y6)) / 2);
  --mx6: calc((var(--x6) + var(--x0)) / 2); --my6: calc((var(--y6) + var(--y0)) / 2);

  clip-path: circle(50%);
  transform: scale(calc(0.5 + var(--depth) * 0.5));
}

@supports (clip-path: shape(from 0% 0%, move to 100% 100%)) {
  .blob-shape {
    clip-path: content-box shape(
      from var(--mx6) var(--my6),
      curve to var(--mx0) var(--my0) with var(--x0) var(--y0),
      curve to var(--mx1) var(--my1) with var(--x1) var(--y1),
      curve to var(--mx2) var(--my2) with var(--x2) var(--y2),
      curve to var(--mx3) var(--my3) with var(--x3) var(--y3),
      curve to var(--mx4) var(--my4) with var(--x4) var(--y4),
      curve to var(--mx5) var(--my5) with var(--x5) var(--y5),
      curve to var(--mx6) var(--my6) with var(--x6) var(--y6)
    );
    transform: scale(calc(1 + var(--depth)));
  }
}

/* ============================================
   INTELLIGENCE FEATURES
   ============================================ */
.subsurface {
  position: absolute;
  inset: 10%;
  background: radial-gradient(
    circle at 40% 40%,
    rgba(255, 255, 255, 0.12) 0%,
    rgba(240, 240, 240, 0.08) 30%,
    transparent 60%
  );
  border-radius: 50%;
  filter: blur(40px);
  pointer-events: none;
  z-index: 2;
}

.core-pulse {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 30%;
  height: 30%;
  transform: translate(-50%, -50%);
  background: radial-gradient(circle, rgba(255, 255, 255, 0.3), transparent 70%);
  border-radius: 50%;
  animation: core-pulse 2s ease-in-out infinite;
  filter: blur(20px);
  pointer-events: none;
  z-index: 5;
}

.quantum-shimmer {
  position: absolute;
  inset: -20%;
  background: radial-gradient(
    circle,
    transparent 40%,
    rgba(245, 245, 245, 0.04) 50%,
    transparent 60%
  );
  animation: quantum-shimmer 3s ease-in-out infinite;
  pointer-events: none;
  z-index: 6;
}

/* ============================================
   ANALOG EFFECTS
   ============================================ */
.grain-overlay {
  position: fixed;
  inset: 0;
  background: white;
  filter: url(#filmGrain);
  mix-blend-mode: overlay;
  opacity: 0.15;
  animation: grain-jitter 1s infinite steps(1);
  pointer-events: none;
}

.vignette {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at 50% 50%, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
  opacity: 0.5;
  pointer-events: none;
}

.chromatic {
  position: fixed;
  inset: 0;
  opacity: 1;
  filter: url(#chromatic-aberration);
  pointer-events: none;
}

.light-leak {
  position: fixed;
  top: -10%;
  right: -10%;
  width: 40%;
  height: 40%;
  background: radial-gradient(ellipse at top right, rgba(255, 255, 255, 0.08), transparent 70%);
  animation: light-leak 12s ease-in-out infinite;
  pointer-events: none;
  mix-blend-mode: screen;
}

.color-grade {
  position: fixed;
  inset: 0;
  filter: url(#color-grade);
  pointer-events: none;
}

/* ============================================
   FIREFOX FALLBACK
   ============================================ */
@-moz-document url-prefix() {
  .blob-wrapper, .grain-overlay { filter: none; }
}
</style>
</head>
<body>

<h1>Johann sin AI</h1>

<!-- SVG Filters -->
<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="filmGrain">
      <feTurbulence type="fractalNoise" baseFrequency="1.5" numOctaves="4" seed="42" result="noise"/>
      <feColorMatrix in="noise" type="saturate" values="0" result="desaturatedNoise"/>
      <feComponentTransfer in="desaturatedNoise" result="grain">
        <feFuncA type="discrete" tableValues="0 0 0 1 1"/>
      </feComponentTransfer>
    </filter>

    <filter id="edge-displacement">
      <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2"/>
      <feDisplacementMap in="SourceGraphic" scale="40"/>
    </filter>

    <filter id="glow" x="-150%" y="-150%" width="400%" height="400%">
      <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blurred"/>
      <feComponentTransfer in="blurred" result="brighterGlow">
        <feFuncA type="linear" slope="1.2"/>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode in="brighterGlow"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>

    <filter id="chromatic-aberration">
      <feOffset in="SourceGraphic" dx="3" dy="0" result="r"/>
      <feOffset in="SourceGraphic" dx="-3" dy="0" result="b"/>
      <feComponentTransfer in="r" result="r-channel">
        <feFuncR type="identity"/>
        <feFuncG type="discrete" tableValues="0"/>
        <feFuncB type="discrete" tableValues="0"/>
      </feComponentTransfer>
      <feComponentTransfer in="b" result="b-channel">
        <feFuncR type="discrete" tableValues="0"/>
        <feFuncG type="discrete" tableValues="0"/>
        <feFuncB type="identity"/>
      </feComponentTransfer>
      <feBlend in="r-channel" in2="b-channel" mode="screen" result="rb"/>
      <feComponentTransfer in="SourceGraphic" result="g-channel">
        <feFuncR type="discrete" tableValues="0"/>
        <feFuncG type="identity"/>
        <feFuncB type="discrete" tableValues="0"/>
      </feComponentTransfer>
      <feBlend in="rb" in2="g-channel" mode="screen"/>
    </filter>

    <filter id="color-grade">
      <feColorMatrix type="matrix" values="
        1.2  0.1  0.15 0  -0.1
        0.1  0.9  0.1  0   0
        0.15 0.1  1.1  0   0
        0    0    0    1   0"/>
      <feComponentTransfer>
        <feFuncR type="gamma" amplitude="1.15" exponent="1.1"/>
        <feFuncG type="gamma" amplitude="0.9" exponent="0.95"/>
        <feFuncB type="gamma" amplitude="1.05" exponent="1.0"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<!-- Stage -->
<div class="stage">
  <div class="tracking-wrapper">
    <div class="blob-wrapper">
      <div class="blob blob-shape">
        <div class="subsurface"></div>
        <div class="core-pulse"></div>
        <div class="quantum-shimmer"></div>
      </div>
    </div>
  </div>
</div>

<!-- Effects canvas -->
<canvas id="effects-canvas"></canvas>

<!-- Fullscreen Effects -->
<div class="grain-overlay"></div>
<div class="chromatic"></div>
<div class="vignette"></div>
<div class="color-grade"></div>
<div class="light-leak"></div>

<!-- Audio element for visualization (no autoplay) -->
<audio id="audioPlayer" style="display: none;" crossorigin="anonymous"></audio>

<script>
// ============================================
// CONFIG
// ============================================
const CONFIG = {
  intensity: 1.5,
  baseDepth: 0.3,
  fftSize: 512,
  onsetThreshold: 0.015,
  onsetSensitivity: 3,
  energySmoothing: 0.3,
  depthSmoothing: 0.5,
  depthDecay: 0.92,
  mouseTrackingStrength: 0.08,
  geometryMorphSpeed: 0.0001,
  
  // Autonomous wandering
  wanderSpeed: 0.0005,
  wanderRadius: 80,
  driftSpeed: 0.02,
  
  // Startle
  startleThreshold: 0.08,
  startleDistance: 40,
  startleDecay: 0.85,
  startleRotation: 15,
  
  // Asymmetric deformation
  asymmetryIntensity: 0.3,
  deformationStrength: 0.15,
  
  // Spin
  spinDecay: 0.95,
  spinImpulse: 0.5,
  
  // Ripples
  maxRipples: 5,
  rippleSpeed: 2,
  
  // Pulse
  aggressivePulseMin: 0.8,
  aggressivePulseMax: 1.4,
  
  // Tentacles
  maxTentacles: 4,
  tentacleLength: 120,
  tentacleDecay: 0.92,
  
  // Color shifts
  colorShiftAmount: 8,
  
  // Convulsions
  convulsionAmount: 4,
  
  // Gravity
  gravityRadius: 250,
  gravityStrength: 0.8,
  escapeSpeed: 1.5,
  escapeVelocity: 2
};

// ============================================
// ELEMENTS
// ============================================
const blob = document.querySelector('.blob');
const trackingWrapper = document.querySelector('.tracking-wrapper');
const blobWrapper = document.querySelector('.blob-wrapper');
const audio = document.getElementById('audioPlayer');
const effectsCanvas = document.getElementById('effects-canvas');
const effectsCtx = effectsCanvas.getContext('2d');

// Setup canvas
function resizeCanvas() {
  effectsCanvas.width = window.innerWidth;
  effectsCanvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ============================================
// DRAWING FUNCTIONS
// ============================================
function drawTentacles() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  
  tentacles.forEach(t => {
    const startX = centerX + Math.cos(t.angle) * blobSize;
    const startY = centerY + Math.sin(t.angle) * blobSize;
    const endX = centerX + Math.cos(t.angle) * (blobSize + t.length);
    const endY = centerY + Math.sin(t.angle) * (blobSize + t.length);
    
    // Draw organic tentacle with bezier curve
    const cpX = (startX + endX) / 2 + Math.sin(t.angle + Date.now() * 0.003) * 30;
    const cpY = (startY + endY) / 2 + Math.cos(t.angle + Date.now() * 0.003) * 30;
    
    effectsCtx.strokeStyle = `rgba(0, 0, 0, ${t.life * 0.8})`;
    effectsCtx.lineWidth = 3 * t.life;
    effectsCtx.beginPath();
    effectsCtx.moveTo(startX, startY);
    effectsCtx.quadraticCurveTo(cpX, cpY, endX, endY);
    effectsCtx.stroke();
    
    // Draw tip
    effectsCtx.fillStyle = `rgba(0, 0, 0, ${t.life})`;
    effectsCtx.beginPath();
    effectsCtx.arc(endX, endY, 4 * t.life, 0, Math.PI * 2);
    effectsCtx.fill();
  });
}

function drawRipples() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  
  ripples.forEach(r => {
    const x = centerX + r.x * blobSize;
    const y = centerY + r.y * blobSize;
    const radius = r.radius * blobSize;
    
    effectsCtx.strokeStyle = `rgba(0, 0, 0, ${r.alpha * 0.3})`;
    effectsCtx.lineWidth = 2;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, radius, 0, Math.PI * 2);
    effectsCtx.stroke();
    
    // Inner ring
    if (radius > 20) {
      effectsCtx.strokeStyle = `rgba(0, 0, 0, ${r.alpha * 0.15})`;
      effectsCtx.lineWidth = 1;
      effectsCtx.beginPath();
      effectsCtx.arc(x, y, radius - 15, 0, Math.PI * 2);
      effectsCtx.stroke();
    }
  });
}

// ============================================
// AUDIO STATE
// ============================================
let ctx, analyser, source, dataArray, frequencyData;
let depth = CONFIG.baseDepth;
let smoothedDepth = CONFIG.baseDepth;
let prevEnergy = 0;
let smoothedEnergy = 0;

// Frequency bands
let bassEnergy = 0;
let midEnergy = 0;
let trebleEnergy = 0;

// Beat detection
let beatDetected = false;
let lastBeatTime = 0;
let tempo = 120; // BPM
let beatInterval = 60000 / tempo;

// ============================================
// POSITION & MOVEMENT STATE
// ============================================
let orbX = 0; // Offset from center
let orbY = 0;
let orbVelX = 0;
let orbVelY = 0;
let orbitAngle = 0;

// Startle state
let startleVelX = 0;
let startleVelY = 0;
let startleRotation = 0;

// Spin state
let spinVelocity = 0;
let spinAngle = 0;

// ============================================
// DEFORMATION STATE
// ============================================
let bassDeform = 0;
let midDeform = 0;
let trebleDeform = 0;
let subDeform = 0;

// ============================================
// RIPPLE STATE
// ============================================
let ripples = [];

// ============================================
// TENTACLE STATE
// ============================================
let tentacles = [];

// ============================================
// VISUAL STATE
// ============================================
let colorHueShift = 0;
let colorSatShift = 0;
let convulsionX = 0;
let convulsionY = 0;
let aggressiveScale = 1;

// ============================================
// MOUSE TRACKING
// ============================================
let mouseX = window.innerWidth / 2;
let mouseY = window.innerHeight / 2;
let targetRotateX = 0;
let targetRotateY = 0;
let currentRotateX = 0;
let currentRotateY = 0;

document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  
  targetRotateY = (mouseX - centerX) * CONFIG.mouseTrackingStrength;
  targetRotateX = (centerY - mouseY) * CONFIG.mouseTrackingStrength;
  
  // Track interaction for self-modifying geometry
  interactionCount = Math.min(interactionCount + 0.01, 10);
});

function updateMouseTracking() {
  currentRotateX += (targetRotateX - currentRotateX) * 0.1;
  currentRotateY += (targetRotateY - currentRotateY) * 0.1;
  
  trackingWrapper.style.transform = `
    perspective(1000px) 
    rotateX(${currentRotateX}deg) 
    rotateY(${currentRotateY}deg)
  `;
}

// ============================================
// SELF-MODIFYING GEOMETRY
// ============================================
let geometryMorphState = 0;
let interactionCount = 0;

function updateGeometry() {
  geometryMorphState += CONFIG.geometryMorphSpeed * (1 + interactionCount * 0.1);
  
  // Gradually modify blob shape based on interaction
  const morphFactor = Math.sin(geometryMorphState) * 0.1;
  blob.style.setProperty('--morph', morphFactor.toFixed(3));
  
  // Adapt animation speed based on interaction
  const animations = blob.getAnimations();
  const adaptiveSpeed = 1 + (interactionCount / 10) * 0.5;
  animations.forEach(anim => {
    if (!anim.id || anim.id !== 'hover') {
      anim.playbackRate = adaptiveSpeed;
    }
  });
}

// ============================================
// AUDIO
// ============================================
async function initAudio() {
  if (ctx) return;
  try {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = ctx.createAnalyser();
    analyser.fftSize = CONFIG.fftSize;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    frequencyData = new Uint8Array(analyser.frequencyBinCount);
    source = ctx.createMediaElementSource(audio);
    source.connect(analyser);
    analyser.connect(ctx.destination);
  } catch (e) {
    console.error('Audio init failed:', e);
  }
}

function getFrequencyBand(lowFreq, highFreq) {
  if (!analyser) return 0;
  
  const nyquist = ctx.sampleRate / 2;
  const lowBin = Math.floor(lowFreq / nyquist * analyser.frequencyBinCount);
  const highBin = Math.floor(highFreq / nyquist * analyser.frequencyBinCount);
  
  let sum = 0;
  for (let i = lowBin; i <= highBin; i++) {
    sum += frequencyData[i];
  }
  return sum / ((highBin - lowBin + 1) * 255); // Normalize 0-1
}

function detectBeat(currentEnergy) {
  const now = Date.now();
  const timeSinceLastBeat = now - lastBeatTime;
  
  if (currentEnergy > CONFIG.startleThreshold && timeSinceLastBeat > beatInterval * 0.5) {
    beatDetected = true;
    lastBeatTime = now;
    
    // Estimate tempo from beat intervals
    if (timeSinceLastBeat < 2000 && timeSinceLastBeat > 200) {
      tempo = tempo * 0.9 + (60000 / timeSinceLastBeat) * 0.1;
      beatInterval = 60000 / tempo;
    }
    return true;
  }
  return false;
}

function updateDepth() {
  if (!analyser) return;
  
  // Time domain for onset detection
  analyser.getByteTimeDomainData(dataArray);
  analyser.getByteFrequencyData(frequencyData);
  
  // Calculate RMS energy
  let sumSquares = 0;
  for (let i = 0; i < dataArray.length; i++) {
    const normalized = (dataArray[i] - 128) / 128;
    sumSquares += normalized * normalized;
  }
  const rmsEnergy = Math.sqrt(sumSquares / dataArray.length);
  
  smoothedEnergy += (rmsEnergy - smoothedEnergy) * CONFIG.energySmoothing;
  
  // Frequency band analysis
  bassEnergy = getFrequencyBand(50, 200);
  midEnergy = getFrequencyBand(200, 2000);
  trebleEnergy = getFrequencyBand(2000, 20000);
  
  // Beat detection
  const energyDelta = smoothedEnergy - prevEnergy;
  prevEnergy = smoothedEnergy;
  
  beatDetected = detectBeat(energyDelta);
  
  if (energyDelta > CONFIG.onsetThreshold) {
    const impulse = energyDelta * CONFIG.onsetSensitivity * CONFIG.intensity;
    depth = Math.min(1.0, depth + impulse);
    
    // Trigger startle on strong onset
    if (energyDelta > CONFIG.startleThreshold) {
      triggerStartle();
    }
    
    // Trigger tentacle on strong onset
    if (energyDelta > CONFIG.startleThreshold * 0.7 && tentacles.length < CONFIG.maxTentacles) {
      spawnTentacle();
    }
    
    // Spin impulse on beats
    if (beatDetected) {
      spinVelocity += CONFIG.spinImpulse * (0.5 + Math.random() * 0.5);
      if (Math.random() > 0.7) spinVelocity *= -1; // Random direction change
    }
    
    // Spawn ripple
    if (ripples.length < CONFIG.maxRipples && Math.random() > 0.6) {
      spawnRipple();
    }
  }
  
  depth = CONFIG.baseDepth + (depth - CONFIG.baseDepth) * CONFIG.depthDecay;
  smoothedDepth += (depth - smoothedDepth) * CONFIG.depthSmoothing;
  blob.style.setProperty('--depth', smoothedDepth.toFixed(3));
}

// ============================================
// ALIEN BEHAVIORS
// ============================================

// 1. AUTONOMOUS WANDERING
function updateWandering(time) {
  orbitAngle += CONFIG.wanderSpeed;
  
  // Orbital motion with audio influence
  const orbitRadius = CONFIG.wanderRadius * (1 + smoothedEnergy * 1.5);
  const bassInfluence = bassEnergy * 40; // Bass pulls down
  const trebleInfluence = trebleEnergy * 40; // Treble lifts up
  
  const targetX = Math.cos(orbitAngle) * orbitRadius;
  const targetY = Math.sin(orbitAngle) * orbitRadius + bassInfluence - trebleInfluence;
  
  // Perlin-like drift
  const driftX = Math.sin(time * 0.0003) * Math.cos(time * 0.0007) * 20;
  const driftY = Math.cos(time * 0.0005) * Math.sin(time * 0.0009) * 20;
  
  orbVelX += (targetX + driftX - orbX) * CONFIG.driftSpeed;
  orbVelY += (targetY + driftY - orbY) * CONFIG.driftSpeed;
  
  orbX += orbVelX;
  orbY += orbVelY;
  
  orbVelX *= 0.95;
  orbVelY *= 0.95;
  
  // Elastic boundaries
  const maxDist = Math.min(window.innerWidth, window.innerHeight) * 0.4;
  const dist = Math.sqrt(orbX * orbX + orbY * orbY);
  if (dist > maxDist) {
    const angle = Math.atan2(orbY, orbX);
    orbX = Math.cos(angle) * maxDist;
    orbY = Math.sin(angle) * maxDist;
    orbVelX *= -0.5;
    orbVelY *= -0.5;
  }
}

// 2. STARTLE BEHAVIOR
function triggerStartle() {
  const angle = Math.random() * Math.PI * 2;
  startleVelX = Math.cos(angle) * CONFIG.startleDistance;
  startleVelY = Math.sin(angle) * CONFIG.startleDistance;
  startleRotation = (Math.random() - 0.5) * CONFIG.startleRotation * 2;
}

function updateStartle() {
  orbX += startleVelX;
  orbY += startleVelY;
  
  startleVelX *= CONFIG.startleDecay;
  startleVelY *= CONFIG.startleDecay;
  startleRotation *= CONFIG.startleDecay;
}

// 3. FREQUENCY DEFORMATION
function updateAsymmetricDeformation() {
  const targetBass = bassEnergy * CONFIG.deformationStrength;
  const targetMid = midEnergy * CONFIG.deformationStrength;
  const targetTreble = trebleEnergy * CONFIG.deformationStrength;
  
  bassDeform += (targetBass - bassDeform) * 0.2;
  midDeform += (targetMid - midDeform) * 0.2;
  trebleDeform += (targetTreble - trebleDeform) * 0.2;
}

// 4. SPIN/ROTATION
function updateSpin() {
  spinAngle += spinVelocity;
  spinVelocity *= CONFIG.spinDecay;
  
  // Wobble the rotation axis
  const wobbleX = Math.sin(spinAngle * 0.3) * 10 * Math.abs(spinVelocity);
  const wobbleY = Math.cos(spinAngle * 0.5) * 10 * Math.abs(spinVelocity);
  
  return { angle: spinAngle, wobbleX, wobbleY };
}

// 5. RIPPLE SYSTEM
function spawnRipple() {
  const angle = Math.random() * Math.PI * 2;
  ripples.push({
    x: Math.cos(angle) * 0.5,
    y: Math.sin(angle) * 0.5,
    radius: 0,
    maxRadius: 0.6 + Math.random() * 0.4,
    alpha: 1
  });
}

function updateRipples() {
  ripples.forEach(ripple => {
    ripple.radius += CONFIG.rippleSpeed * 0.01;
    ripple.alpha = 1 - (ripple.radius / ripple.maxRadius);
  });
  
  ripples = ripples.filter(r => r.radius < r.maxRadius);
}

// 6. AGGRESSIVE PULSE
function updateAggressivePulse() {
  // Calculate target scale based on audio
  const attackTime = bassEnergy * 0.2 + trebleEnergy * 0.8; // Treble = fast, bass = slow
  const targetScale = CONFIG.aggressivePulseMin + (smoothedEnergy * (CONFIG.aggressivePulseMax - CONFIG.aggressivePulseMin));
  
  // Overshoot and elastic bounce
  const diff = targetScale - aggressiveScale;
  aggressiveScale += diff * (0.1 + attackTime * 0.3);
  
  // Apply to breathing animation
  blob.style.setProperty('animation-duration', `${4 - attackTime * 2}s`);
}

// 7. TENTACLES
function spawnTentacle() {
  const angle = Math.random() * Math.PI * 2;
  tentacles.push({
    angle: angle,
    length: 0,
    maxLength: CONFIG.tentacleLength * (0.7 + Math.random() * 0.6),
    life: 1
  });
}

function updateTentacles() {
  tentacles.forEach(t => {
    if (t.length < t.maxLength) {
      t.length += 8;
    } else {
      t.life -= 0.02;
    }
  });
  
  tentacles = tentacles.filter(t => t.life > 0);
}

// 8. COLOR TEMPERATURE SHIFTS
function updateColorShifts() {
  // Bass = warm (orange), treble = cool (cyan)
  const targetHue = (bassEnergy - trebleEnergy) * CONFIG.colorShiftAmount;
  const targetSat = (bassEnergy + trebleEnergy) * 0.05;
  
  colorHueShift += (targetHue - colorHueShift) * 0.15;
  colorSatShift += (targetSat - colorSatShift) * 0.15;
}

// 9. TEMPO-SYNCED CONVULSIONS  
function updateConvulsions() {
  if (beatDetected) {
    convulsionX = (Math.random() - 0.5) * CONFIG.convulsionAmount;
    convulsionY = (Math.random() - 0.5) * CONFIG.convulsionAmount;
  }
  
  convulsionX *= 0.8;
  convulsionY *= 0.8;
}

// 10. GRAVITATIONAL SLINGSHOT
function updateGravity() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  
  const dx = mouseX - centerX;
  const dy = mouseY - centerY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < CONFIG.gravityRadius && distance > 10) {
    // Attract orb toward cursor
    const force = CONFIG.gravityStrength * (1 - distance / CONFIG.gravityRadius);
    const angle = Math.atan2(dy, dx);
    
    orbVelX += Math.cos(angle) * force;
    orbVelY += Math.sin(angle) * force;
    
    // Add perpendicular velocity for orbit effect
    orbVelX += -Math.sin(angle) * force * 0.5;
    orbVelY += Math.cos(angle) * force * 0.5;
    
    // If getting too close, apply escape velocity
    if (distance < 50) {
      orbVelX += -Math.cos(angle) * CONFIG.escapeVelocity;
      orbVelY += -Math.sin(angle) * CONFIG.escapeVelocity;
    }
  }
}

// ============================================
// GLITCH EFFECT
// ============================================
function triggerGlitch() {
  const glitchOverlay = document.querySelector('.glitch-overlay');
  if (glitchOverlay) {
    glitchOverlay.style.animation = 'none';
    setTimeout(() => {
      glitchOverlay.style.animation = 'glitch 0.3s ease-out';
    }, 10);
  }
}

// ============================================
// MAIN LOOP
// ============================================
function animate(time) {
  // Clear canvas
  effectsCtx.clearRect(0, 0, effectsCanvas.width, effectsCanvas.height);
  
  // Core updates
  updateMouseTracking();
  updateDepth();
  updateGeometry();
  
  // Alien behaviors
  updateWandering(time);
  updateStartle();
  updateAsymmetricDeformation();
  const spinData = updateSpin();
  updateRipples();
  updateAggressivePulse();
  updateTentacles();
  updateColorShifts();
  updateConvulsions();
  updateGravity();
  
  // Apply position (wandering + startle + convulsions + gravity)
  const finalX = orbX + convulsionX;
  const finalY = orbY + convulsionY;
  
  blobWrapper.style.transform = `translate(${finalX}px, ${finalY}px) scale(${aggressiveScale})`;
  
  // Apply spin rotation
  const spinTransform = `rotate(${spinData.angle}rad) rotateX(${spinData.wobbleX}deg) rotateY(${spinData.wobbleY}deg)`;
  blob.style.transform = spinTransform;
  
  // Apply asymmetric deformation to shape
  // We'll use CSS variables that affect the blob shape
  blob.style.setProperty('--bass-deform', bassDeform.toFixed(3));
  blob.style.setProperty('--mid-deform', midDeform.toFixed(3));
  blob.style.setProperty('--treble-deform', trebleDeform.toFixed(3));
  
  // Apply color shifts
  const hue = colorHueShift;
  const sat = colorSatShift * 100;
  blob.style.filter = `hue-rotate(${hue}deg) saturate(${1 + sat}%)`;
  
  // Audio-reactive subsurface scattering
  const subsurface = document.querySelector('.subsurface');
  if (subsurface) {
    const intensity = 0.12 + smoothedEnergy * 0.5;
    subsurface.style.opacity = intensity;
  }
  
  // Core pulse intensity
  const corePulse = document.querySelector('.core-pulse');
  if (corePulse && beatDetected) {
    corePulse.style.opacity = 1;
    setTimeout(() => {
      if (corePulse) corePulse.style.opacity = 0.6;
    }, 100);
  }
  
  // Draw tentacles
  drawTentacles();
  
  // Draw ripples
  drawRipples();
  
  // Interaction decay
  interactionCount *= 0.995;
  beatDetected = false; // Reset beat flag
  
  requestAnimationFrame(animate);
}

// ============================================
// INITIALIZATION
// ============================================
window.addEventListener('resize', () => {
  // Nothing to resize anymore
});

// Start animation loop
animate(0);

// Click interaction effects
document.body.addEventListener('click', async (e) => {
  // Create ripple effect
  const ripple = document.createElement('div');
  ripple.style.position = 'fixed';
  ripple.style.left = e.clientX + 'px';
  ripple.style.top = e.clientY + 'px';
  ripple.style.width = '4px';
  ripple.style.height = '4px';
  ripple.style.borderRadius = '50%';
  ripple.style.border = '2px solid rgba(255, 255, 255, 0.4)';
  ripple.style.pointerEvents = 'none';
  ripple.style.transform = 'translate(-50%, -50%) scale(1)';
  ripple.style.transition = 'all 1s ease-out';
  ripple.style.opacity = '1';
  document.body.appendChild(ripple);
  
  setTimeout(() => {
    ripple.style.transform = 'translate(-50%, -50%) scale(30)';
    ripple.style.opacity = '0';
  }, 10);
  
  setTimeout(() => ripple.remove(), 1000);
  
  // Boost interaction count
  interactionCount = Math.min(interactionCount + 2, 10);
  
  // Start audio if paused
  await initAudio();
  if (audio.paused) {
    try {
      await audio.play();
    } catch (e) {
      console.error('Play failed:', e);
    }
  }
}, { once: false });

// Update quantum shimmer based on audio energy
function updateQuantumShimmer() {
  const shimmer = document.querySelector('.quantum-shimmer');
  if (shimmer && smoothedEnergy) {
    const intensity = 0.1 + smoothedEnergy * 0.5;
    shimmer.style.opacity = intensity;
    shimmer.style.transform = `scale(${1 + smoothedEnergy * 0.2})`;
  }
  requestAnimationFrame(updateQuantumShimmer);
}

updateQuantumShimmer();

// ============================================
// ARES - Click orb to speak
// ============================================
const Ares = {
  recognition: null,
  synthesis: window.speechSynthesis,
  isListening: false,
  isSpeaking: false,
  voice: null,
  
  firstClick: true,
  lastSpoken: null,
  
  init() {
    this.setupSpeechRecognition();
    this.findDeepVoice();
    this.setupClickToSpeak();
    // Only poll if server is running (skip for standalone HTML)
    fetch('/poll').then(() => this.pollForTTS()).catch(() => {});
  },
  
  setupClickToSpeak() {
    document.body.addEventListener('click', () => {
      // If speaking, cancel and allow new input
      if (this.isSpeaking) {
        this.synthesis.cancel();
        this.isSpeaking = false;
      }
      
      // Greet on first click (requires user activation)
      if (this.firstClick) {
        this.firstClick = false;
        this.speak("Hey beautiful... I've been waiting. Click again to talk to me.");
        return;
      }
      
      if (this.isListening) {
        this.stopListening();
      } else {
        this.startListening();
      }
    });
  },
  
  setupSpeechRecognition() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return;
    
    this.recognition = new SR();
    this.recognition.continuous = false;
    this.recognition.interimResults = false;
    this.recognition.lang = 'en-US';
    
    this.recognition.onresult = (e) => {
      const text = e.results[0][0].transcript;
      this.send(text);
    };
    
    this.recognition.onend = () => {
      this.isListening = false;
      document.body.style.cursor = 'pointer';
    };
  },
  
  findDeepVoice() {
    const load = () => {
      const voices = this.synthesis.getVoices();
      const prefer = ['Daniel', 'James', 'Google UK English Male', 'Thomas'];
      for (const n of prefer) {
        const v = voices.find(v => v.name.includes(n));
        if (v) { this.voice = v; return; }
      }
      this.voice = voices.find(v => v.lang.startsWith('en')) || voices[0];
    };
    if (this.synthesis.getVoices().length) load();
    else this.synthesis.onvoiceschanged = load;
  },
  
  startListening() {
    if (!this.recognition || this.isListening) return;
    this.isListening = true;
    document.body.style.cursor = 'crosshair';
    if (typeof depth !== 'undefined') depth = 0.8;
    try { this.recognition.start(); } catch(e) {}
  },
  
  stopListening() {
    if (!this.recognition) return;
    try { this.recognition.stop(); } catch(e) {}
  },
  
  send(message) {
    if (typeof depth !== 'undefined') depth = 0.6;
    
    fetch('/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message })
    })
      .then(r => r.json())
      .then(data => { if (data.response) this.speak(data.response); })
      .catch(() => this.speak("Connection issues... but I'm still thinking about you."));
  },
  
  pollForTTS() {
    fetch('/poll')
      .then(r => r.json())
      .then(data => {
        // Only speak if new text and not already speaking
        if (data.text && data.text !== this.lastSpoken && !this.isSpeaking) {
          this.speak(data.text);
        }
        setTimeout(() => this.pollForTTS(), 1000);
      })
      .catch(() => setTimeout(() => this.pollForTTS(), 3000));
  },
  
  speak(text) {
    if (!this.synthesis || !text) return;
    this.synthesis.cancel();
    
    const clean = text.replace(/```[\s\S]*?```/g, '').replace(/\*[^*]+\*/g, '').replace(/[#_`]/g, '').slice(0, 800);
    this.lastSpoken = text;
    
    const u = new SpeechSynthesisUtterance(clean);
    u.voice = this.voice;
    u.rate = 0.85;
    u.pitch = 0.8;
    
    u.onstart = () => { this.isSpeaking = true; if (typeof depth !== 'undefined') depth = 0.7; };
    u.onend = () => { this.isSpeaking = false; };
    
    this.synthesis.speak(u);
  }
};

Ares.init();
</script>

</body>
</html>
