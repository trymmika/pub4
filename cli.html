<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Organic AI Orb</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
<style>
/* ============================================
   CUSTOM PROPERTIES
   ============================================ */
/* ============================================
   KEYFRAMES
   ============================================ */
@keyframes breathe {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}



/* === DIMENSIONAL KEYFRAMES === */
@keyframes dimensional-shift {
  0%, 100% { 
    filter: hue-rotate(0deg);
    opacity: 0.08;
  }
  25% { 
    filter: hue-rotate(-15deg);
    opacity: 0.12;
  }
  50% { 
    filter: hue-rotate(-30deg);
    opacity: 0.15;
  }
  75% { 
    filter: hue-rotate(-15deg);
    opacity: 0.12;
  }
}

@keyframes sacred-rotate {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

@keyframes presence-pulse {
  0%, 100% { 
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
  }
  50% { 
    opacity: 0.06;
    transform: translate(-50%, -50%) scale(1.2);
  }
}

@keyframes grain-jitter {
  0%, 100% { transform: translate(1px, 6px); }
  10% { transform: translate(-8px, 14px); }
  20% { transform: translate(9px, 13px); }
  30% { transform: translate(-10px, -11px); }
  40% { transform: translate(14px, -7px); }
  50% { transform: translate(-13px, -6px); }
  60% { transform: translate(10px, 9px); }
  70% { transform: translate(-14px, -8px); }
  80% { transform: translate(9px, 6px); }
  90% { transform: translate(-10px, 7px); }
}

@keyframes light-leak {
  0%, 100% { opacity: 0; }
  50% { opacity: 0.2; }
}

/* ============================================
   BASE
   ============================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  width: 100vw;
  height: 100vh;
  height: 100dvh; /* Dynamic viewport for mobile */
  overflow: hidden;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  overscroll-behavior: none;
}

h1 {
  position: fixed;
  top: 20px;
  left: 20px;
  margin: 0;
  font-family: "Inter", sans-serif;
  font-optical-sizing: auto;
  font-size: 18px;
  font-weight: 600;
  font-style: normal;
  color: #fff;
  letter-spacing: -0.02em;
  z-index: 1000;
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
  background: transparent !important;
  min-width: 100px;
  padding: 8px 12px;
  cursor: text;
  -webkit-user-modify: read-write-plaintext-only;
  -webkit-appearance: none;
  -moz-appearance: none;
  caret-color: #fff;
}

h1:focus, h1:active, h1:focus-visible {
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
  background: transparent !important;
}

h1:empty::before {
  content: attr(data-placeholder);
  color: rgba(255,255,255,0.4);
}

/* ============================================
   STAGE
   ============================================ */
.stage {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
}

#effects-canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.tracking-wrapper {
  /* No 3D transforms - keep orb flat facing forward */
  transform: none !important;
  transform-style: flat;
}

.blob-wrapper {
  width: 60vmin;
  height: 60vmin;
  filter: none;
  animation: breathe 4s ease-in-out infinite;
  transform-origin: center center;
  transform: none !important;
}

.blob {
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: #fff;
  transform: none !important;
  /* Pure flat white circle - no 3D */
}

.blob-shape {
  /* Override - just a circle */
  clip-path: circle(50%);
  transform: none;
}

/* Tunnel canvas inside orb */
.orb-tunnel {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  opacity: 0.5;
  mix-blend-mode: screen;
  pointer-events: none;
  /* Mask to create depth illusion - fades at edges */
  mask-image: radial-gradient(circle, white 30%, transparent 70%);
  -webkit-mask-image: radial-gradient(circle, white 30%, transparent 70%);
}

/* Star field canvas behind tunnel */
.star-field {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  opacity: 0.6;
  pointer-events: none;
  mask-image: radial-gradient(circle, white 20%, black 50%, transparent 70%);
  -webkit-mask-image: radial-gradient(circle, white 20%, black 50%, transparent 70%);
}

@supports (clip-path: shape(from 0% 0%, move to 100% 100%)) {
  .blob-shape {
    clip-path: content-box shape(
      from var(--mx6) var(--my6),
      curve to var(--mx0) var(--my0) with var(--x0) var(--y0),
      curve to var(--mx1) var(--my1) with var(--x1) var(--y1),
      curve to var(--mx2) var(--my2) with var(--x2) var(--y2),
      curve to var(--mx3) var(--my3) with var(--x3) var(--y3),
      curve to var(--mx4) var(--my4) with var(--x4) var(--y4),
      curve to var(--mx5) var(--my5) with var(--x5) var(--y5),
      curve to var(--mx6) var(--my6) with var(--x6) var(--y6)
    );
    transform: scale(calc(1 + var(--depth)));
  }
}

/* ============================================
   INTELLIGENCE FEATURES
   ============================================ */
/* ============================================
   DIMENSIONAL / DMT REALM EFFECTS
   ============================================ */
.sacred-geometry {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 140%;
  height: 140%;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Ccircle cx='100' cy='100' r='80' fill='none' stroke='%23667eea' stroke-width='0.3' opacity='0.3'/%3E%3Ccircle cx='100' cy='100' r='60' fill='none' stroke='%23764ba2' stroke-width='0.3' opacity='0.25'/%3E%3Ccircle cx='100' cy='100' r='40' fill='none' stroke='%23667eea' stroke-width='0.3' opacity='0.2'/%3E%3Cpath d='M100 20 L170 145 L30 145 Z' fill='none' stroke='%236B7FD7' stroke-width='0.2' opacity='0.15'/%3E%3Cpath d='M100 180 L30 55 L170 55 Z' fill='none' stroke='%236B7FD7' stroke-width='0.2' opacity='0.15'/%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  animation: sacred-rotate 120s linear infinite;
  opacity: 0.4;
  pointer-events: none;
  z-index: 1;
  mix-blend-mode: screen;
}

.dimensional-aura {
  position: absolute;
  inset: -30%;
  background: radial-gradient(
    ellipse at center,
    rgba(102, 126, 234, 0.08) 0%,
    rgba(118, 75, 162, 0.05) 30%,
    rgba(102, 126, 234, 0.03) 50%,
    transparent 70%
  );
  animation: dimensional-shift 20s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

.presence-ring {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 120%;
  height: 120%;
  border: 1px solid rgba(102, 126, 234, 0.15);
  border-radius: 50%;
  animation: presence-pulse 8s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

/* Subtle iridescent shimmer on the blob surface */
.blob::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(
    135deg,
    transparent 20%,
    rgba(102, 126, 234, 0.04) 40%,
    rgba(147, 112, 219, 0.06) 50%,
    rgba(102, 126, 234, 0.04) 60%,
    transparent 80%
  );
  border-radius: inherit;
  animation: dimensional-shift 15s ease-in-out infinite reverse;
  pointer-events: none;
  mix-blend-mode: overlay;
}

/* Listening state indicator */
.blob-wrapper.listening::before {
  content: '';
  position: absolute;
  inset: -10%;
  border: 2px solid rgba(102, 126, 234, 0.4);
  border-radius: 50%;
  animation: presence-pulse 1.5s ease-in-out infinite;
  pointer-events: none;
}

/* Speaking state - more active */
.blob-wrapper.speaking {
  animation: breathe 2s ease-in-out infinite;
}

/* ============================================
   PIXELATED DEPTH EFFECTS
   ============================================ */

/* Breathing shadow beneath orb */
.orb-shadow {
  position: absolute;
  bottom: -20%;
  left: 50%;
  width: 80%;
  height: 20%;
  background: radial-gradient(ellipse, rgba(0,0,0,0.3) 0%, transparent 70%);
  transform: translateX(-50%);
  filter: blur(15px);
  pointer-events: none;
  transition: transform 0.3s ease-out, opacity 0.3s ease-out;
}

/* Afterimage trail container */
.afterimage {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0.3;
  filter: blur(5px);
  background: rgba(102, 126, 234, 0.2);
}

/* Membrane ripple effect */
.membrane-ripple {
  position: absolute;
  border-radius: 50%;
  border: 1px solid rgba(140,120,200,0.25);
  pointer-events: none;
  animation: membrane-expand 1.2s ease-out forwards;
}

@keyframes membrane-expand {
  0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.5; }
  100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}

/* Caustic light pattern on "floor" - simplified */
.caustics {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 25%;
  background: radial-gradient(ellipse at 50% 100%, rgba(120,100,180,0.04) 0%, transparent 50%);
  pointer-events: none;
  animation: caustic-shimmer 6s ease-in-out infinite;
}

@keyframes caustic-shimmer {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 0.7; }
}

/* ============================================
   ANALOG EFFECTS
   ============================================ */
.grain-overlay {
  position: fixed;
  inset: 0;
  background: white;
  filter: url(#filmGrain);
  mix-blend-mode: overlay;
  opacity: 0.15;
  animation: grain-jitter 1s infinite steps(1);
  pointer-events: none;
}

.vignette {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at 50% 50%, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
  opacity: 0.5;
  pointer-events: none;
}

.light-leak {
  position: fixed;
  top: -10%;
  right: -10%;
  width: 40%;
  height: 40%;
  background: radial-gradient(ellipse at top right, rgba(255, 255, 255, 0.08), transparent 70%);
  animation: light-leak 12s ease-in-out infinite;
  pointer-events: none;
  mix-blend-mode: screen;
}

/* ============================================
   FIREFOX FALLBACK
   ============================================ */
@-moz-document url-prefix() {
  .blob-wrapper, .grain-overlay { filter: none; }
}
</style>
</head>
<body>

<h1 id="aresInput" contenteditable="true" data-placeholder="Johann sin AI">Johann sin AI</h1>

<!-- SVG Filters -->
<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="filmGrain">
      <feTurbulence type="fractalNoise" baseFrequency="1.5" numOctaves="4" seed="42" result="noise"/>
      <feColorMatrix in="noise" type="saturate" values="0" result="desaturatedNoise"/>
      <feComponentTransfer in="desaturatedNoise" result="grain">
        <feFuncA type="discrete" tableValues="0 0 0 1 1"/>
      </feComponentTransfer>
    </filter>

  </defs>
</svg>

<!-- Stage -->
<div class="stage">
  <div class="tracking-wrapper">
    <div class="blob-wrapper" id="blobWrapper">
      <div class="dimensional-aura"></div>
      <div class="sacred-geometry"></div>
      <div class="presence-ring"></div>
      <div class="blob blob-shape">
        <!-- Flat white circle - no effects -->
      </div>
    </div>
    <!-- Shadow beneath -->
    <div class="orb-shadow"></div>
  </div>
</div>

<!-- Caustic light on floor -->
<div class="caustics"></div>

<!-- Effects canvas for astral particles -->
<canvas id="effects-canvas"></canvas>

<!-- Afterimage container -->
<div id="afterimageContainer" style="position:fixed; inset:0; pointer-events:none; z-index:1;"></div>

<!-- Status indicators -->
<div id="statusIndicator" style="position:fixed; top:20px; right:20px; font-family:'Courier New',monospace; font-size:16px; color:rgba(255,255,255,0.9); z-index:1000; pointer-events:none;">
  <style>
    .mic-icon { opacity: 0.5; transition: opacity 0.2s; font-size: 14px; }
    .mic-icon.mic-active { opacity: 1; animation: pulse-mic 1s ease-in-out infinite; }
    .spinner { color: rgba(255,255,255,0.7); font-size: 12px; }
    .speaking-icon { font-size: 14px; animation: pulse-speak 0.5s ease-in-out infinite; }
    @keyframes pulse-mic { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
    @keyframes pulse-speak { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
  </style>
</div>

<!-- Fullscreen Effects (flat only) -->
<div class="grain-overlay"></div>
<div class="vignette"></div>
<div class="light-leak"></div>

<!-- Audio element for visualization (no autoplay) -->
<audio id="audioPlayer" style="opacity: 0; position: absolute; pointer-events: none;" crossorigin="anonymous"></audio>

<script>
// ============================================
// CONFIG
// ============================================
const CONFIG = {
  intensity: 1.5,
  baseDepth: 0.3,
  fftSize: 512,
  onsetThreshold: 0.015,
  onsetSensitivity: 3,
  energySmoothing: 0.3,
  depthSmoothing: 0.5,
  depthDecay: 0.92,
  mouseTrackingStrength: 0.25,  // Increased for more response
  geometryMorphSpeed: 0.0001,
  
  // Pixelation
  pixelSteps: 8,  // Quantize movements to N steps
  
  // Autonomous wandering
  wanderSpeed: 0.0005,
  wanderRadius: 80,
  driftSpeed: 0.02,
  
  // Startle
  startleThreshold: 0.08,
  startleDistance: 40,
  startleDecay: 0.85,
  startleRotation: 15,
  
  // Asymmetric deformation
  asymmetryIntensity: 0.3,
  deformationStrength: 0.15,
  
  // Spin
  spinDecay: 0.95,
  spinImpulse: 0.5,
  
  // Ripples
  maxRipples: 5,
  rippleSpeed: 2,
  
  // Pulse
  aggressivePulseMin: 0.8,
  aggressivePulseMax: 1.4,
  
  // Tentacles
  maxTentacles: 4,
  tentacleLength: 120,
  tentacleDecay: 0.92,
  
  // Color shifts
  colorShiftAmount: 8,
  
  // Convulsions
  convulsionAmount: 4,
  
  // Gravity
  gravityRadius: 250,
  gravityStrength: 0.8,
  escapeSpeed: 1.5,
  escapeVelocity: 2,
  
  // === NEW: 3D LIFE ENHANCEMENTS ===
  // Breathing
  breathingCycle: 4000,      // 4 second breath cycle
  breathingMin: 0.97,
  breathingMax: 1.03,
  
  // Parallax layers
  parallaxStrength: 0.15,    // Inner particles move slower
  
  // Micro-jitter
  jitterAmount: 1.5,         // Pixels of random jitter
  jitterSpeed: 0.05,
  
  // Idle sway
  idleSwayAmount: 8,         // Pixels of gentle drift
  idleSwaySpeed: 0.0008,
  
  // Light source
  lightAngleSpeed: 0.0003,   // Slow rotation of fake light
  rimLightIntensity: 0.15,
  specularIntensity: 0.2,
  
  // Audio anticipation
  anticipationShrink: 0.95,
  anticipationDuration: 150,
  
  // Attention (look toward mouse)
  attentionStrength: 0.03
};

// ============================================
// STAR FIELD RENDERER - deep space background
// ============================================
const starFieldCanvas = document.getElementById('starField');
const starFieldCtx = starFieldCanvas?.getContext('2d', { alpha: true });

class StarField {
  constructor(ctx) {
    this.ctx = ctx;
    this.w = 0;
    this.h = 0;
    this.stars = [];
    this.numStars = 80; // Fewer stars for 8-bit feel
    this.speed = 0.5;
  }
  
  resize(w, h) {
    this.w = w;
    this.h = h;
    this.init();
  }
  
  init() {
    this.stars = [];
    for (let i = 0; i < this.numStars; i++) {
      this.stars.push({
        x: (Math.random() - 0.5) * this.w * 3,
        y: (Math.random() - 0.5) * this.h * 3,
        z: Math.random() * 1000,
        color: this.randomStarColor()
      });
    }
  }
  
  randomStarColor() {
    // 8-bit palette - limited colors
    const colors = ['#ffffff', '#c0c0ff', '#8080ff', '#c0ffff', '#ffffc0'];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  frame(audioData) {
    if (!this.ctx || this.w === 0) return;
    
    const bass = audioData?.bass || 0.5;
    this.ctx.clearRect(0, 0, this.w, this.h);
    
    const cx = this.w / 2;
    const cy = this.h / 2;
    
    // Disable anti-aliasing for pixel look
    this.ctx.imageSmoothingEnabled = false;
    
    for (const star of this.stars) {
      // Move toward viewer
      star.z -= this.speed * (1 + bass * 2);
      if (star.z <= 1) {
        star.z = 1000;
        star.x = (Math.random() - 0.5) * this.w * 3;
        star.y = (Math.random() - 0.5) * this.h * 3;
      }
      
      // Project to 2D
      const scale = 300 / star.z;
      const sx = Math.floor(cx + star.x * scale);
      const sy = Math.floor(cy + star.y * scale);
      
      // Size based on depth - 1-3 pixels only (8-bit style)
      const depth = 1 - star.z / 1000;
      const size = Math.max(1, Math.floor(depth * 3));
      
      // Draw as hard pixel rectangles - no gradients
      this.ctx.fillStyle = star.color;
      this.ctx.fillRect(sx, sy, size, size);
    }
  }
}

let starField = null;
if (starFieldCtx) {
  starField = new StarField(starFieldCtx);
}

function resizeStarField() {
  if (starFieldCanvas && starField) {
    const rect = starFieldCanvas.parentElement?.getBoundingClientRect();
    if (rect) {
      starFieldCanvas.width = rect.width;
      starFieldCanvas.height = rect.height;
      starField.resize(rect.width, rect.height);
    }
  }
}

// ============================================
// ORB TUNNEL RENDERER (from index.html)
// ============================================
const orbTunnelCanvas = document.getElementById('orbTunnel');
const orbTunnelCtx = orbTunnelCanvas?.getContext('2d', { alpha: true });

class OrbTunnel {
  constructor(ctx) {
    this.ctx = ctx;
    this.w = 0;
    this.h = 0;
    this.fov = 150;
    this.speed = 0.5;
    this.segments = 24;
    this.baseRadius = 40;
    this.zStep = 8;
    this.particles = [];
    this.time = 0;
  }
  
  resize(w, h) {
    this.w = w;
    this.h = h;
    this.init();
  }
  
  init() {
    this.particles = [];
    for (let z = -this.fov; z < this.fov; z += this.zStep) {
      const row = [];
      for (let i = 0; i < this.segments; i++) {
        const a = (i * Math.PI * 2) / this.segments;
        row.push({ x: Math.cos(a) * this.baseRadius, y: Math.sin(a) * this.baseRadius, z });
      }
      this.particles.push(row);
    }
  }
  
  frame(audioData) {
    if (!this.ctx || this.w === 0) return;
    
    const bass = audioData?.bass || 0.5;
    const beat = audioData?.beat || 0;
    
    this.ctx.clearRect(0, 0, this.w, this.h);
    
    // Sort by depth
    this.particles.sort((a, b) => b[0].z - a[0].z);
    
    for (let i = 0; i < this.particles.length; i++) {
      const row = this.particles[i];
      const d = i / this.particles.length;
      
      // Color based on depth and audio
      const r = Math.round(80 + d * 60 + beat * 40);
      const g = Math.round(60 + d * 40);
      const b = Math.round(120 + d * 80);
      const alpha = 0.3 + d * 0.5;
      
      this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      this.ctx.lineWidth = 1 + d;
      this.ctx.beginPath();
      
      for (let j = 0; j < row.length; j++) {
        const p = row[j];
        
        // Move toward camera
        p.z -= this.speed * (1 + bass * 0.5);
        if (p.z < -this.fov) p.z += this.fov * 2;
        
        // Rotate over time
        const a = (j * Math.PI * 2) / this.segments + this.time;
        const radiusMod = this.baseRadius * (1 + beat * 0.2);
        p.x = Math.cos(a) * radiusMod;
        p.y = Math.sin(a) * radiusMod;
        
        // Project to 2D
        const scale = this.fov / (this.fov + p.z);
        const x2d = this.w / 2 + p.x * scale;
        const y2d = this.h / 2 + p.y * scale;
        
        if (j === 0) this.ctx.moveTo(x2d, y2d);
        else this.ctx.lineTo(x2d, y2d);
      }
      
      this.ctx.closePath();
      this.ctx.stroke();
    }
    
    this.time += 0.02;
  }
}

let orbTunnel = null;
if (orbTunnelCtx) {
  orbTunnel = new OrbTunnel(orbTunnelCtx);
}

function resizeOrbTunnel() {
  if (orbTunnelCanvas && orbTunnel) {
    const rect = orbTunnelCanvas.parentElement?.getBoundingClientRect();
    if (rect) {
      orbTunnelCanvas.width = rect.width;
      orbTunnelCanvas.height = rect.height;
      orbTunnel.resize(rect.width, rect.height);
    }
  }
}

// ============================================
// ELEMENTS
// ============================================
const blob = document.querySelector('.blob');
const trackingWrapper = document.querySelector('.tracking-wrapper');
const blobWrapper = document.querySelector('.blob-wrapper');
const audio = document.getElementById('audioPlayer');
const effectsCanvas = document.getElementById('effects-canvas');
const effectsCtx = effectsCanvas.getContext('2d');

// Setup canvas
function resizeCanvas() {
  effectsCanvas.width = window.innerWidth;
  effectsCanvas.height = window.innerHeight;
}
resizeCanvas();
resizeOrbTunnel();
resizeStarField();
window.addEventListener('resize', () => { resizeCanvas(); resizeOrbTunnel(); resizeStarField(); });

// ============================================
// DRAWING FUNCTIONS
// ============================================
function drawTentacles() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  
  tentacles.forEach(t => {
    const startX = centerX + Math.cos(t.angle) * blobSize;
    const startY = centerY + Math.sin(t.angle) * blobSize;
    const endX = centerX + Math.cos(t.angle) * (blobSize + t.length);
    const endY = centerY + Math.sin(t.angle) * (blobSize + t.length);
    
    // Draw organic tentacle with bezier curve
    const cpX = (startX + endX) / 2 + Math.sin(t.angle + Date.now() * 0.003) * 30;
    const cpY = (startY + endY) / 2 + Math.cos(t.angle + Date.now() * 0.003) * 30;
    
    effectsCtx.strokeStyle = `rgba(0, 0, 0, ${t.life * 0.8})`;
    effectsCtx.lineWidth = 3 * t.life;
    effectsCtx.beginPath();
    effectsCtx.moveTo(startX, startY);
    effectsCtx.quadraticCurveTo(cpX, cpY, endX, endY);
    effectsCtx.stroke();
    
    // Draw tip
    effectsCtx.fillStyle = `rgba(0, 0, 0, ${t.life})`;
    effectsCtx.beginPath();
    effectsCtx.arc(endX, endY, 4 * t.life, 0, Math.PI * 2);
    effectsCtx.fill();
  });
}

function drawRipples() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  
  ripples.forEach(r => {
    const x = centerX + r.x * blobSize;
    const y = centerY + r.y * blobSize;
    const radius = r.radius * blobSize;
    
    effectsCtx.strokeStyle = `rgba(0, 0, 0, ${r.alpha * 0.3})`;
    effectsCtx.lineWidth = 2;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, radius, 0, Math.PI * 2);
    effectsCtx.stroke();
    
    // Inner ring
    if (radius > 20) {
      effectsCtx.strokeStyle = `rgba(0, 0, 0, ${r.alpha * 0.15})`;
      effectsCtx.lineWidth = 1;
      effectsCtx.beginPath();
      effectsCtx.arc(x, y, radius - 15, 0, Math.PI * 2);
      effectsCtx.stroke();
    }
  });
}

// ============================================
// AUDIO STATE
// ============================================
let ctx, analyser, source, dataArray, frequencyData;
let depth = CONFIG.baseDepth;
let smoothedDepth = CONFIG.baseDepth;
let prevEnergy = 0;
let smoothedEnergy = 0;

// Frequency bands
let bassEnergy = 0;
let midEnergy = 0;
let trebleEnergy = 0;

// Beat detection
let beatDetected = false;
let lastBeatTime = 0;
let tempo = 120; // BPM
let beatInterval = 60000 / tempo;

// ============================================
// POSITION & MOVEMENT STATE
// ============================================
let orbX = 0; // Offset from center
let orbY = 0;
let orbVelX = 0;
let orbVelY = 0;
let orbitAngle = 0;

// Startle state
let startleVelX = 0;
let startleVelY = 0;
let startleRotation = 0;

// Spin state
let spinVelocity = 0;
let spinAngle = 0;

// ============================================
// DEFORMATION STATE
// ============================================
let bassDeform = 0;
let midDeform = 0;
let trebleDeform = 0;
let subDeform = 0;

// ============================================
// RIPPLE STATE
// ============================================
let ripples = [];

// ============================================
// TENTACLE STATE
// ============================================
let tentacles = [];

// ============================================
// ASTRAL PARTICLE STATE
// ============================================
let astralParticles = [];
const MAX_ASTRAL_PARTICLES = 40;

function initAstralParticles() {
  for (let i = 0; i < MAX_ASTRAL_PARTICLES; i++) {
    astralParticles.push(createAstralParticle());
  }
}

function createAstralParticle() {
  const angle = Math.random() * Math.PI * 2;
  const distance = 0.3 + Math.random() * 0.7; // 30-100% of orb radius
  return {
    angle: angle,
    distance: distance,
    speed: 0.0002 + Math.random() * 0.0003,
    size: 0.5 + Math.random() * 2,
    alpha: 0.1 + Math.random() * 0.3,
    phase: Math.random() * Math.PI * 2,
    pulseSpeed: 0.001 + Math.random() * 0.002,
    layer: Math.floor(Math.random() * 3), // 0=inner, 1=mid, 2=outer
    hue: 220 + Math.random() * 40 // Blue to violet range
  };
}

function updateAstralParticles(time) {
  astralParticles.forEach(p => {
    p.angle += p.speed * (1 + smoothedEnergy * 2);
    p.phase += p.pulseSpeed;
    // Pulse alpha
    p.currentAlpha = p.alpha * (0.5 + 0.5 * Math.sin(p.phase));
  });
}

function drawAstralParticles() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.28;
  
  astralParticles.forEach(p => {
    const layerOffset = [0.5, 0.8, 1.2][p.layer];
    const x = centerX + Math.cos(p.angle) * blobSize * p.distance * layerOffset;
    const y = centerY + Math.sin(p.angle) * blobSize * p.distance * layerOffset;
    
    // Draw particle with glow
    const gradient = effectsCtx.createRadialGradient(x, y, 0, x, y, p.size * 3);
    gradient.addColorStop(0, `hsla(${p.hue}, 70%, 70%, ${p.currentAlpha})`);
    gradient.addColorStop(0.5, `hsla(${p.hue}, 60%, 50%, ${p.currentAlpha * 0.3})`);
    gradient.addColorStop(1, `hsla(${p.hue}, 50%, 30%, 0)`);
    
    effectsCtx.fillStyle = gradient;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, p.size * 3, 0, Math.PI * 2);
    effectsCtx.fill();
    
    // Bright core
    effectsCtx.fillStyle = `hsla(${p.hue}, 80%, 90%, ${p.currentAlpha * 0.8})`;
    effectsCtx.beginPath();
    effectsCtx.arc(x, y, p.size * 0.5, 0, Math.PI * 2);
    effectsCtx.fill();
  });
}

// ============================================
// UI STATE
// ============================================
let uiState = 'idle'; // idle, listening, thinking, speaking
const blobWrapperEl = document.getElementById('blobWrapper');
const statusIndicator = document.getElementById('statusIndicator');

// Ora-style braille spinner frames
const spinnerFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
let spinnerIndex = 0;
let spinnerInterval = null;

function setUIState(state) {
  uiState = state;
  blobWrapperEl.classList.remove('listening', 'thinking', 'speaking');
  if (state !== 'idle') {
    blobWrapperEl.classList.add(state);
  }
  
  // Clear existing spinner
  if (spinnerInterval) {
    clearInterval(spinnerInterval);
    spinnerInterval = null;
  }
  
  // Flat icons (SVG-style unicode)
  const micIcon = '–';       // Simple dash for idle
  const micActiveIcon = '•';  // Simple dot when active  
  const speakIcon = '—';      // Em dash for speaking
  
  // Update status indicator with ora-style spinner + flat icons
  if (state === 'idle') {
    statusIndicator.innerHTML = `<span class="mic-icon">${micIcon}</span>`;
  } else if (state === 'listening') {
    statusIndicator.innerHTML = `<span class="mic-icon mic-active">${micActiveIcon}</span>`;
    // Animate spinner
    spinnerInterval = setInterval(() => {
      spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
      statusIndicator.innerHTML = `<span class="spinner">${spinnerFrames[spinnerIndex]}</span> <span class="mic-icon mic-active">${micActiveIcon}</span>`;
    }, 80);
  } else if (state === 'thinking') {
    spinnerInterval = setInterval(() => {
      spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
      statusIndicator.innerHTML = `<span class="spinner">${spinnerFrames[spinnerIndex]}</span>`;
    }, 80);
  } else if (state === 'speaking') {
    statusIndicator.innerHTML = `<span class="speaking-icon">${speakIcon}</span>`;
  }
}

// ============================================
// VISUAL STATE
// ============================================
let colorHueShift = 0;
let colorSatShift = 0;
let convulsionX = 0;
let convulsionY = 0;
let aggressiveScale = 1;

// === NEW: 3D LIFE STATE ===
let breathingPhase = 0;
let breathingScale = 1;
let jitterOffsetX = 0;
let jitterOffsetY = 0;
let idleSwayX = 0;
let idleSwayY = 0;
let idleSwayPhase = Math.random() * Math.PI * 2;
let lightAngle = 0;
let isAnticipating = false;
let anticipationScale = 1;
let attentionOffsetX = 0;
let attentionOffsetY = 0;

// ============================================
// MOUSE TRACKING
// ============================================
let mouseX = window.innerWidth / 2;
let mouseY = window.innerHeight / 2;
let targetRotateX = 0;
let targetRotateY = 0;
let currentRotateX = 0;
let currentRotateY = 0;

document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  
  targetRotateY = (mouseX - centerX) * CONFIG.mouseTrackingStrength;
  targetRotateX = (centerY - mouseY) * CONFIG.mouseTrackingStrength;
  
  // Parallax for 3D orb rotation
  const parallaxX = (mouseX - centerX) / centerX; // -1 to 1
  const parallaxY = (mouseY - centerY) / centerY; // -1 to 1
  document.querySelector('.blob')?.style.setProperty('--parallax-x', parallaxX);
  document.querySelector('.blob')?.style.setProperty('--parallax-y', parallaxY);
  
  // Pressure response - orb leans toward mouse
  const dist = Math.hypot(mouseX - centerX, mouseY - centerY);
  const maxDist = Math.hypot(centerX, centerY);
  pressureX = ((mouseX - centerX) / maxDist) * 15;
  pressureY = ((mouseY - centerY) / maxDist) * 15;
  proximityGlow = 1 - (dist / maxDist);
  
  // Track interaction for self-modifying geometry
  interactionCount = Math.min(interactionCount + 0.01, 10);
});

// Gyroscope for phone parallax
let gyroX = 0, gyroY = 0;
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', (e) => {
    if (e.gamma !== null && e.beta !== null) {
      // gamma: left/right tilt (-90 to 90), beta: front/back tilt (-180 to 180)
      gyroX = e.gamma * 0.3;  // Scale down
      gyroY = (e.beta - 45) * 0.3;  // Center around 45° (holding phone)
      targetRotateY = gyroX;
      targetRotateX = -gyroY;
    }
  });
}

// Depth state
let pressureX = 0, pressureY = 0;
let proximityGlow = 0;
let pupilSize = 1;
let flickerPhase = 0;
let afterimages = [];

function updateMouseTracking() {
  // Flat orb - no rotation, just track position for other effects
  currentRotateX += (targetRotateX - currentRotateX) * 0.08;
  currentRotateY += (targetRotateY - currentRotateY) * 0.08;
  
  // No 3D rotation - keep orb flat
  trackingWrapper.style.transform = 'none';
}

// ============================================
// SELF-MODIFYING GEOMETRY
// ============================================
let geometryMorphState = 0;
let interactionCount = 0;

function updateGeometry() {
  geometryMorphState += CONFIG.geometryMorphSpeed * (1 + interactionCount * 0.1);
  
  // Gradually modify blob shape based on interaction
  const morphFactor = Math.sin(geometryMorphState) * 0.1;
  blob.style.setProperty('--morph', morphFactor.toFixed(3));
  
  // Adapt animation speed based on interaction
  const animations = blob.getAnimations();
  const adaptiveSpeed = 1 + (interactionCount / 10) * 0.5;
  animations.forEach(anim => {
    if (!anim.id || anim.id !== 'hover') {
      anim.playbackRate = adaptiveSpeed;
    }
  });
}

// ============================================
// AUDIO
// ============================================
async function initAudio() {
  if (ctx) return;
  try {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = ctx.createAnalyser();
    analyser.fftSize = CONFIG.fftSize;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    frequencyData = new Uint8Array(analyser.frequencyBinCount);
    source = ctx.createMediaElementSource(audio);
    source.connect(analyser);
    analyser.connect(ctx.destination);
  } catch (e) {
    console.error('Audio init failed:', e);
  }
}

function getFrequencyBand(lowFreq, highFreq) {
  if (!analyser) return 0;
  
  const nyquist = ctx.sampleRate / 2;
  const lowBin = Math.floor(lowFreq / nyquist * analyser.frequencyBinCount);
  const highBin = Math.floor(highFreq / nyquist * analyser.frequencyBinCount);
  
  let sum = 0;
  for (let i = lowBin; i <= highBin; i++) {
    sum += frequencyData[i];
  }
  return sum / ((highBin - lowBin + 1) * 255); // Normalize 0-1
}

function detectBeat(currentEnergy) {
  const now = Date.now();
  const timeSinceLastBeat = now - lastBeatTime;
  
  if (currentEnergy > CONFIG.startleThreshold && timeSinceLastBeat > beatInterval * 0.5) {
    beatDetected = true;
    lastBeatTime = now;
    
    // Estimate tempo from beat intervals
    if (timeSinceLastBeat < 2000 && timeSinceLastBeat > 200) {
      tempo = tempo * 0.9 + (60000 / timeSinceLastBeat) * 0.1;
      beatInterval = 60000 / tempo;
    }
    return true;
  }
  return false;
}

function updateDepth() {
  if (!analyser) return;
  
  // Time domain for onset detection
  analyser.getByteTimeDomainData(dataArray);
  analyser.getByteFrequencyData(frequencyData);
  
  // Calculate RMS energy
  let sumSquares = 0;
  for (let i = 0; i < dataArray.length; i++) {
    const normalized = (dataArray[i] - 128) / 128;
    sumSquares += normalized * normalized;
  }
  const rmsEnergy = Math.sqrt(sumSquares / dataArray.length);
  
  smoothedEnergy += (rmsEnergy - smoothedEnergy) * CONFIG.energySmoothing;
  
  // Frequency band analysis
  bassEnergy = getFrequencyBand(50, 200);
  midEnergy = getFrequencyBand(200, 2000);
  trebleEnergy = getFrequencyBand(2000, 20000);
  
  // Beat detection
  const energyDelta = smoothedEnergy - prevEnergy;
  prevEnergy = smoothedEnergy;
  
  beatDetected = detectBeat(energyDelta);
  
  if (energyDelta > CONFIG.onsetThreshold) {
    const impulse = energyDelta * CONFIG.onsetSensitivity * CONFIG.intensity;
    depth = Math.min(1.0, depth + impulse);
    
    // Trigger startle on strong onset
    if (energyDelta > CONFIG.startleThreshold) {
      triggerStartle();
    }
    
    // Trigger tentacle on strong onset
    if (energyDelta > CONFIG.startleThreshold * 0.7 && tentacles.length < CONFIG.maxTentacles) {
      spawnTentacle();
    }
    
    // Spin impulse on beats
    if (beatDetected) {
      spinVelocity += CONFIG.spinImpulse * (0.5 + Math.random() * 0.5);
      if (Math.random() > 0.7) spinVelocity *= -1; // Random direction change
    }
    
    // Spawn ripple
    if (ripples.length < CONFIG.maxRipples && Math.random() > 0.6) {
      spawnRipple();
    }
  }
  
  depth = CONFIG.baseDepth + (depth - CONFIG.baseDepth) * CONFIG.depthDecay;
  smoothedDepth += (depth - smoothedDepth) * CONFIG.depthSmoothing;
  blob.style.setProperty('--depth', smoothedDepth.toFixed(3));
}

// ============================================
// ALIEN BEHAVIORS
// ============================================

// 1. AUTONOMOUS WANDERING
function updateWandering(time) {
  orbitAngle += CONFIG.wanderSpeed;
  
  // Orbital motion with audio influence
  const orbitRadius = CONFIG.wanderRadius * (1 + smoothedEnergy * 1.5);
  const bassInfluence = bassEnergy * 40; // Bass pulls down
  const trebleInfluence = trebleEnergy * 40; // Treble lifts up
  
  const targetX = Math.cos(orbitAngle) * orbitRadius;
  const targetY = Math.sin(orbitAngle) * orbitRadius + bassInfluence - trebleInfluence;
  
  // Perlin-like drift
  const driftX = Math.sin(time * 0.0003) * Math.cos(time * 0.0007) * 20;
  const driftY = Math.cos(time * 0.0005) * Math.sin(time * 0.0009) * 20;
  
  orbVelX += (targetX + driftX - orbX) * CONFIG.driftSpeed;
  orbVelY += (targetY + driftY - orbY) * CONFIG.driftSpeed;
  
  orbX += orbVelX;
  orbY += orbVelY;
  
  orbVelX *= 0.95;
  orbVelY *= 0.95;
  
  // Elastic boundaries
  const maxDist = Math.min(window.innerWidth, window.innerHeight) * 0.4;
  const dist = Math.sqrt(orbX * orbX + orbY * orbY);
  if (dist > maxDist) {
    const angle = Math.atan2(orbY, orbX);
    orbX = Math.cos(angle) * maxDist;
    orbY = Math.sin(angle) * maxDist;
    orbVelX *= -0.5;
    orbVelY *= -0.5;
  }
}

// 2. STARTLE BEHAVIOR
function triggerStartle() {
  const angle = Math.random() * Math.PI * 2;
  startleVelX = Math.cos(angle) * CONFIG.startleDistance;
  startleVelY = Math.sin(angle) * CONFIG.startleDistance;
  startleRotation = (Math.random() - 0.5) * CONFIG.startleRotation * 2;
}

function updateStartle() {
  orbX += startleVelX;
  orbY += startleVelY;
  
  startleVelX *= CONFIG.startleDecay;
  startleVelY *= CONFIG.startleDecay;
  startleRotation *= CONFIG.startleDecay;
}

// 3. FREQUENCY DEFORMATION
function updateAsymmetricDeformation() {
  const targetBass = bassEnergy * CONFIG.deformationStrength;
  const targetMid = midEnergy * CONFIG.deformationStrength;
  const targetTreble = trebleEnergy * CONFIG.deformationStrength;
  
  bassDeform += (targetBass - bassDeform) * 0.2;
  midDeform += (targetMid - midDeform) * 0.2;
  trebleDeform += (targetTreble - trebleDeform) * 0.2;
}

// 4. SPIN/ROTATION
function updateSpin() {
  spinAngle += spinVelocity;
  spinVelocity *= CONFIG.spinDecay;
  
  // Wobble the rotation axis
  const wobbleX = Math.sin(spinAngle * 0.3) * 10 * Math.abs(spinVelocity);
  const wobbleY = Math.cos(spinAngle * 0.5) * 10 * Math.abs(spinVelocity);
  
  return { angle: spinAngle, wobbleX, wobbleY };
}

// 5. RIPPLE SYSTEM
function spawnRipple() {
  const angle = Math.random() * Math.PI * 2;
  ripples.push({
    x: Math.cos(angle) * 0.5,
    y: Math.sin(angle) * 0.5,
    radius: 0,
    maxRadius: 0.6 + Math.random() * 0.4,
    alpha: 1
  });
}

function updateRipples() {
  ripples.forEach(ripple => {
    ripple.radius += CONFIG.rippleSpeed * 0.01;
    ripple.alpha = 1 - (ripple.radius / ripple.maxRadius);
  });
  
  ripples = ripples.filter(r => r.radius < r.maxRadius);
}

// 6. AGGRESSIVE PULSE
function updateAggressivePulse() {
  // Calculate target scale based on audio
  const attackTime = bassEnergy * 0.2 + trebleEnergy * 0.8; // Treble = fast, bass = slow
  const targetScale = CONFIG.aggressivePulseMin + (smoothedEnergy * (CONFIG.aggressivePulseMax - CONFIG.aggressivePulseMin));
  
  // Overshoot and elastic bounce
  const diff = targetScale - aggressiveScale;
  aggressiveScale += diff * (0.1 + attackTime * 0.3);
  
  // Apply to breathing animation
  blob.style.setProperty('animation-duration', `${4 - attackTime * 2}s`);
}

// 7. TENTACLES
function spawnTentacle() {
  const angle = Math.random() * Math.PI * 2;
  tentacles.push({
    angle: angle,
    length: 0,
    maxLength: CONFIG.tentacleLength * (0.7 + Math.random() * 0.6),
    life: 1
  });
}

function updateTentacles() {
  tentacles.forEach(t => {
    if (t.length < t.maxLength) {
      t.length += 8;
    } else {
      t.life -= 0.02;
    }
  });
  
  tentacles = tentacles.filter(t => t.life > 0);
}

// 8. COLOR TEMPERATURE SHIFTS
function updateColorShifts() {
  // Bass = warm (orange), treble = cool (cyan)
  const targetHue = (bassEnergy - trebleEnergy) * CONFIG.colorShiftAmount;
  const targetSat = (bassEnergy + trebleEnergy) * 0.05;
  
  colorHueShift += (targetHue - colorHueShift) * 0.15;
  colorSatShift += (targetSat - colorSatShift) * 0.15;
}

// 9. TEMPO-SYNCED CONVULSIONS  
function updateConvulsions() {
  if (beatDetected) {
    convulsionX = (Math.random() - 0.5) * CONFIG.convulsionAmount;
    convulsionY = (Math.random() - 0.5) * CONFIG.convulsionAmount;
  }
  
  convulsionX *= 0.8;
  convulsionY *= 0.8;
}

// 10. GRAVITATIONAL SLINGSHOT
function updateGravity() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  
  const dx = mouseX - centerX;
  const dy = mouseY - centerY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < CONFIG.gravityRadius && distance > 10) {
    // Attract orb toward cursor
    const force = CONFIG.gravityStrength * (1 - distance / CONFIG.gravityRadius);
    const angle = Math.atan2(dy, dx);
    
    orbVelX += Math.cos(angle) * force;
    orbVelY += Math.sin(angle) * force;
    
    // Add perpendicular velocity for orbit effect
    orbVelX += -Math.sin(angle) * force * 0.5;
    orbVelY += Math.cos(angle) * force * 0.5;
    
    // If getting too close, apply escape velocity
    if (distance < 50) {
      orbVelX += -Math.cos(angle) * CONFIG.escapeVelocity;
      orbVelY += -Math.sin(angle) * CONFIG.escapeVelocity;
    }
  }
}

// ============================================
// 3D LIFE ENHANCEMENTS
// ============================================

// 11. BREATHING RHYTHM - Slow organic scale pulse
function updateBreathing(time) {
  breathingPhase = (time % CONFIG.breathingCycle) / CONFIG.breathingCycle;
  const breath = Math.sin(breathingPhase * Math.PI * 2);
  breathingScale = CONFIG.breathingMin + (breath + 1) * 0.5 * (CONFIG.breathingMax - CONFIG.breathingMin);
}

// 12. MICRO-JITTER - Tiny random position offsets for organic feel
function updateJitter(time) {
  const jitterPhase = time * CONFIG.jitterSpeed;
  jitterOffsetX = (Math.sin(jitterPhase * 7.3) + Math.sin(jitterPhase * 11.7)) * CONFIG.jitterAmount * 0.5;
  jitterOffsetY = (Math.cos(jitterPhase * 8.9) + Math.cos(jitterPhase * 13.1)) * CONFIG.jitterAmount * 0.5;
}

// 13. IDLE SWAY - Gentle floating motion when not active
function updateIdleSway(time) {
  idleSwayPhase += CONFIG.idleSwaySpeed;
  // Figure-8 pattern for organic movement
  idleSwayX = Math.sin(idleSwayPhase) * Math.cos(idleSwayPhase * 0.5) * CONFIG.idleSwayAmount;
  idleSwayY = Math.sin(idleSwayPhase * 0.7) * CONFIG.idleSwayAmount * 0.6;
}

// 14. LIGHT SOURCE - Rotating specular highlight and rim light
function updateLighting(time) {
  lightAngle += CONFIG.lightAngleSpeed;
}

// 15. AUDIO ANTICIPATION - Slight shrink before speaking
function triggerAnticipation() {
  if (isAnticipating) return;
  isAnticipating = true;
  anticipationScale = CONFIG.anticipationShrink;
  setTimeout(() => {
    isAnticipating = false;
    anticipationScale = 1.05; // Slight expand after
    setTimeout(() => { anticipationScale = 1; }, 200);
  }, CONFIG.anticipationDuration);
}

// 16. ATTENTION - Subtle lean toward mouse
function updateAttention() {
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  const dx = mouseX - centerX;
  const dy = mouseY - centerY;
  
  attentionOffsetX += (dx * CONFIG.attentionStrength - attentionOffsetX) * 0.05;
  attentionOffsetY += (dy * CONFIG.attentionStrength - attentionOffsetY) * 0.05;
}

// Draw lighting effects on canvas
function drawLighting() {
  const centerX = window.innerWidth / 2 + orbX;
  const centerY = window.innerHeight / 2 + orbY;
  const blobSize = Math.min(window.innerWidth, window.innerHeight) * 0.28;
  
  // Specular highlight (bright spot that rotates)
  const specX = centerX + Math.cos(lightAngle) * blobSize * 0.3;
  const specY = centerY + Math.sin(lightAngle) * blobSize * 0.3;
  const specGradient = effectsCtx.createRadialGradient(specX, specY, 0, specX, specY, blobSize * 0.4);
  specGradient.addColorStop(0, `rgba(255, 255, 255, ${CONFIG.specularIntensity})`);
  specGradient.addColorStop(0.5, `rgba(255, 255, 255, ${CONFIG.specularIntensity * 0.3})`);
  specGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  effectsCtx.fillStyle = specGradient;
  effectsCtx.beginPath();
  effectsCtx.arc(centerX, centerY, blobSize * 1.1, 0, Math.PI * 2);
  effectsCtx.fill();
  
  // Rim lighting (edge glow opposite to light)
  const rimAngle = lightAngle + Math.PI;
  const rimX = centerX + Math.cos(rimAngle) * blobSize * 0.85;
  const rimY = centerY + Math.sin(rimAngle) * blobSize * 0.85;
  const rimGradient = effectsCtx.createRadialGradient(rimX, rimY, 0, rimX, rimY, blobSize * 0.5);
  rimGradient.addColorStop(0, `rgba(200, 220, 255, ${CONFIG.rimLightIntensity})`);
  rimGradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
  effectsCtx.fillStyle = rimGradient;
  effectsCtx.beginPath();
  effectsCtx.arc(rimX, rimY, blobSize * 0.5, 0, Math.PI * 2);
  effectsCtx.fill();
  
  // Shadow gradient (dark region opposite light)
  const shadowAngle = lightAngle + Math.PI;
  const shadowX = centerX + Math.cos(shadowAngle) * blobSize * 0.2;
  const shadowY = centerY + Math.sin(shadowAngle) * blobSize * 0.2;
  const shadowGradient = effectsCtx.createRadialGradient(shadowX, shadowY, 0, centerX, centerY, blobSize);
  shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.08)');
  shadowGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.03)');
  shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  effectsCtx.fillStyle = shadowGradient;
  effectsCtx.beginPath();
  effectsCtx.arc(centerX, centerY, blobSize, 0, Math.PI * 2);
  effectsCtx.fill();
}

// ============================================
// DEPTH EFFECTS
// ============================================
const orbShadow = document.querySelector('.orb-shadow');
const afterimageContainer = document.getElementById('afterimageContainer');
const pupilCore = document.querySelector('.pupil-core');
const dimensionalFlicker = document.querySelector('.dimensional-flicker');

let lastOrbX = 0, lastOrbY = 0;
let membraneRippleTimer = 0;

function updateDepthEffects(time) {
  // Breathing shadow
  if (orbShadow) {
    const shadowScale = 0.8 + breathingScale * 0.2 + smoothedEnergy * 0.3;
    orbShadow.style.transform = `translateX(-50%) scaleX(${shadowScale}) scaleY(${shadowScale * 0.5})`;
    orbShadow.style.opacity = 0.25 + smoothedEnergy * 0.15;
  }
  
  // Pupil dilation based on audio energy
  if (pupilCore) {
    pupilSize = 15 - smoothedEnergy * 10; // Contracts with sound
    const size = Math.max(5, pupilSize);
    pupilCore.style.width = size + '%';
    pupilCore.style.height = size + '%';
  }
  
  // Dimensional flicker (rare subtle glitch)
  flickerPhase += 0.01;
  if (dimensionalFlicker && Math.random() < 0.001) {
    dimensionalFlicker.style.opacity = 0.15;
    setTimeout(() => { dimensionalFlicker.style.opacity = 0; }, 80);
  }
  
  // Pressure response (lean toward mouse) - smooth
  blobWrapper.style.marginLeft = (pressureX * 0.5) + 'px';
  blobWrapper.style.marginTop = (pressureY * 0.5) + 'px';
  
  // Afterimage trail when moving fast
  const velocity = Math.hypot(orbX - lastOrbX, orbY - lastOrbY);
  if (velocity > 3 && afterimageContainer) {
    createAfterimage(orbX, orbY);
  }
  lastOrbX = orbX;
  lastOrbY = orbY;
  
  // Membrane ripples on beat
  membraneRippleTimer++;
  if (beatDetected && membraneRippleTimer > 15) {
    createMembraneRipple();
    membraneRippleTimer = 0;
  }
}

function createAfterimage(x, y) {
  const afterimage = document.createElement('div');
  afterimage.className = 'afterimage';
  const size = Math.min(window.innerWidth, window.innerHeight) * 0.25;
  afterimage.style.cssText = `
    left: ${window.innerWidth/2 + x - size/2}px;
    top: ${window.innerHeight/2 + y - size/2}px;
    width: ${size}px;
    height: ${size}px;
  `;
  afterimageContainer.appendChild(afterimage);
  setTimeout(() => afterimage.remove(), 300);
}

function createMembraneRipple() {
  const ripple = document.createElement('div');
  ripple.className = 'membrane-ripple';
  const size = Math.min(window.innerWidth, window.innerHeight) * 0.3;
  ripple.style.cssText = `
    left: 50%;
    top: 50%;
    width: ${size}px;
    height: ${size}px;
  `;
  blobWrapper.appendChild(ripple);
  setTimeout(() => ripple.remove(), 1000);
}

// ============================================
// MAIN LOOP
// ============================================
function animate(time) {
  // Clear canvas
  effectsCtx.clearRect(0, 0, effectsCanvas.width, effectsCanvas.height);
  
  // Update star field (deep space background)
  if (starField) {
    starField.frame({ bass: smoothedEnergy, beat: beatDetected ? 1 : 0 });
  }
  
  // Update orb tunnel with audio data
  if (orbTunnel) {
    orbTunnel.frame({ bass: smoothedEnergy, beat: beatDetected ? 1 : 0, average: depth });
  }
  
  // Core updates
  updateMouseTracking();
  updateDepth();
  updateGeometry();
  
  // Alien behaviors
  updateWandering(time);
  updateStartle();
  updateAsymmetricDeformation();
  const spinData = updateSpin();
  updateRipples();
  updateAggressivePulse();
  updateTentacles();
  updateColorShifts();
  updateConvulsions();
  updateGravity();
  
  // 3D Life enhancements
  updateBreathing(time);
  updateJitter(time);
  updateIdleSway(time);
  updateLighting(time);
  updateAttention();
  
  // Pixelated depth effects
  updateDepthEffects(time);
  
  // Combine all position offsets
  const finalX = orbX + convulsionX + jitterOffsetX + idleSwayX + attentionOffsetX;
  const finalY = orbY + convulsionY + jitterOffsetY + idleSwayY + attentionOffsetY;
  
  // Combine all scale factors
  const finalScale = aggressiveScale * breathingScale * anticipationScale;
  
  blobWrapper.style.transform = `translate(${finalX}px, ${finalY}px) scale(${finalScale})`;
  
  // Apply spin rotation
  const spinTransform = `rotate(${spinData.angle}rad) rotateX(${spinData.wobbleX}deg) rotateY(${spinData.wobbleY}deg)`;
  blob.style.transform = spinTransform;
  
  // Apply asymmetric deformation to shape
  // We'll use CSS variables that affect the blob shape
  blob.style.setProperty('--bass-deform', bassDeform.toFixed(3));
  blob.style.setProperty('--mid-deform', midDeform.toFixed(3));
  blob.style.setProperty('--treble-deform', trebleDeform.toFixed(3));
  
  // Apply color shifts - add subtle blue/violet tint
  const hue = colorHueShift - 10; // Shift toward blue
  const sat = colorSatShift * 100;
  blob.style.filter = `hue-rotate(${hue}deg) saturate(${1 + sat}%)`;
  
  // Draw lighting effects (specular, rim, shadow)
  drawLighting();
  
  // Draw tentacles
  drawTentacles();
  
  // Draw ripples
  drawRipples();
  
  // Interaction decay
  interactionCount *= 0.995;
  beatDetected = false; // Reset beat flag
  
  requestAnimationFrame(animate);
}

// ============================================
// INITIALIZATION
// ============================================
initAstralParticles();

// Keyboard shortcut - spacebar to toggle listening
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
    e.preventDefault();
    if (Ares.isListening) {
      Ares.stopListening();
    } else {
      Ares.startListening();
    }
  }
});

// Start animation loop
animate(0);

// Click interaction effects
document.body.addEventListener('click', async (e) => {
  // Boost interaction count
  interactionCount = Math.min(interactionCount + 2, 10);
  
  // Start audio if paused
  await initAudio();
  if (audio.paused) {
    try {
      await audio.play();
    } catch (e) {
      console.error('Play failed:', e);
    }
  }
}, { once: false });

// ============================================
// ARES - Click orb to speak
// ============================================
const Ares = {
  recognition: null,
  synthesis: window.speechSynthesis,
  isListening: false,
  isSpeaking: false,
  voice: null,
  
  firstClick: true,
  lastSpoken: null,
  
  pollRetryDelay: 1000,
  maxPollRetry: 30000,
  
  init() {
    this.setupSpeechRecognition();
    this.findVoice();
    this.setupClickToSpeak();
    this.setupTextInput();
    // Only poll if server is running (skip for standalone HTML)
    this.startPolling();
  },
  
  startPolling() {
    fetch('/poll', { signal: AbortSignal.timeout(5000) })
      .then(() => {
        this.pollRetryDelay = 1000; // Reset on success
        this.pollForTTS();
      })
      .catch(() => {
        // Server not available, retry with backoff (silent)
        this.pollRetryDelay = Math.min(this.pollRetryDelay * 1.5, this.maxPollRetry);
        setTimeout(() => this.startPolling(), this.pollRetryDelay);
      });
  },
  
  setupClickToSpeak() {
    document.body.addEventListener('click', () => {
      // If speaking, cancel and allow new input
      if (this.isSpeaking) {
        this.synthesis.cancel();
        this.isSpeaking = false;
        setUIState('idle');
      }
      
      // First click just activates audio context, then start listening
      if (this.firstClick) {
        this.firstClick = false;
      }
      
      if (this.isListening) {
        this.stopListening();
      } else {
        this.startListening();
      }
    });
  },
  
  setupSpeechRecognition() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return;
    
    this.recognition = new SR();
    this.recognition.continuous = false;
    this.recognition.interimResults = false;
    this.recognition.lang = 'en-US';
    
    this.recognition.onresult = (e) => {
      const text = e.results[0][0].transcript;
      setUIState('thinking');
      this.send(text);
    };
    
    this.recognition.onend = () => {
      this.isListening = false;
      if (uiState === 'listening') setUIState('idle');
      document.body.style.cursor = 'pointer';
    };
    
    this.recognition.onerror = () => {
      this.isListening = false;
      setUIState('idle');
    };
  },
  
  setupTextInput() {
    const input = document.getElementById('aresInput');
    if (!input) return;
    
    const defaultText = input.dataset.placeholder || 'Johann sin AI';
    
    // Handle Enter key to send message
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const text = input.innerText.trim();
        if (text && text !== defaultText) {
          setUIState('thinking');
          this.send(text);
          input.innerText = '';  // Clear, don't restore default
          // Don't blur - placeholder will show via CSS :empty
        }
      }
    });
    
    // Clear default text immediately on click/focus
    input.addEventListener('click', (e) => {
      e.stopPropagation();
      if (input.innerText.trim() === defaultText) {
        input.innerText = '';
      }
    });
    
    input.addEventListener('focus', () => {
      if (input.innerText.trim() === defaultText) {
        input.innerText = '';
      }
    });
    
    // Restore default text if empty on blur
    input.addEventListener('blur', () => {
      if (!input.innerText.trim()) {
        input.innerText = defaultText;
      }
    });
  },
  
  findVoice() {
    const load = () => {
      this.allVoices = this.synthesis.getVoices();
      // Prefer warm, natural-sounding voices
      const prefer = ['Samantha', 'Karen', 'Evan', 'Tom', 'Google US English Male', 'Microsoft Guy', 'Reed'];
      for (const n of prefer) {
        const v = this.allVoices.find(v => v.name.includes(n));
        if (v) { this.voice = v; return; }
      }
      this.voice = this.allVoices.find(v => v.lang === 'en-US') || this.allVoices.find(v => v.lang.startsWith('en')) || this.allVoices[0];
    };
    if (this.synthesis.getVoices().length) load();
    else this.synthesis.onvoiceschanged = load;
  },
  
  // Voice profiles for browser TTS (pitch, rate combos to simulate different characters)
  voiceProfiles: {
    ares: { pitch: 0.65, rate: 0.75 },           // Deep, slow
    glitch: { pitch: 1.3, rate: 1.4 },           // High, fast, erratic
    noir: { pitch: 0.7, rate: 0.8 },             // Low, deliberate
    cosmic_barista: { pitch: 1.1, rate: 1.15 },  // Upbeat, breezy
    victorian_ghost: { pitch: 0.85, rate: 0.8 }, // Formal, measured
    chaos_gremlin: { pitch: 1.4, rate: 1.5 },    // Manic, high
    sleepy_sage: { pitch: 0.6, rate: 0.6 },      // Very low, very slow
    anxious_guru: { pitch: 1.1, rate: 1.3 },     // Tense, rushed
    depressed_coach: { pitch: 0.75, rate: 0.7 }, // Flat, slow
    southern_alien: { pitch: 1.15, rate: 0.95 }, // Sweet, deliberate
    dragon_librarian: { pitch: 0.5, rate: 0.85 },// Very deep, grumbly
    upside_down: { pitch: 1.2, rate: 1.1 },      // Strained
    enthusiastic_mortician: { pitch: 1.1, rate: 1.25 }, // Chipper
    jazz_robot: { pitch: 0.9, rate: 1.0 },       // Smooth
    vampire_teacher: { pitch: 0.7, rate: 0.75 }, // Transylvanian slow
    default: { pitch: 1.0, rate: 1.0 }
  },
  
  currentPersona: 'ares',
  
  startListening() {
    if (!this.recognition || this.isListening) return;
    this.isListening = true;
    setUIState('listening');
    document.body.style.cursor = 'crosshair';
    if (typeof depth !== 'undefined') depth = 0.8;
    try { this.recognition.start(); } catch(e) { /* expected if already started */ }
  },
  
  stopListening() {
    if (!this.recognition) return;
    this.isListening = false;
    setUIState('idle');
    try { this.recognition.stop(); } catch(e) { /* expected if already stopped */ }
  },
  
  send(message) {
    // Visual feedback via depth
    if (typeof depth !== 'undefined') depth = 0.6;
    
    fetch('/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message }),
      keepalive: true
    })
      .then(r => r.json())
      .then(data => { 
        if (data.response) {
          // If server provided audio URL, play that instead of browser TTS
          if (data.audio) {
            this.playServerAudio(data.audio, data.response);
          } else {
            this.speak(data.response);
          }
        }
      })
      .catch(() => this.speak("Connection issues... but I'm still thinking about you."));
  },
  
  pollForTTS() {
    fetch('/poll', { signal: AbortSignal.timeout(10000) })
      .then(r => r.json())
      .then(data => {
        this.pollRetryDelay = 1000; // Reset on success
        // Update persona if server sent one
        if (data.persona && data.persona !== this.currentPersona) {
          this.setPersona(data.persona);
        }
        // Play server audio if available
        if (data.audio && !this.isSpeaking) {
          this.playServerAudio(data.audio, data.text);
        }
        // Fallback to browser TTS if text but no audio
        else if (data.text && data.text !== this.lastSpoken && !this.isSpeaking) {
          this.speak(data.text);
        }
        setTimeout(() => this.pollForTTS(), 1000);
      })
      .catch(() => {
        // Retry with exponential backoff (silent)
        this.pollRetryDelay = Math.min(this.pollRetryDelay * 1.5, this.maxPollRetry);
        setTimeout(() => this.pollForTTS(), this.pollRetryDelay);
      });
  },
  
  // Play audio from server (ElevenLabs)
  playServerAudio(url, text) {
    this.lastSpoken = text;
    
    // Trigger anticipation animation
    if (typeof triggerAnticipation === 'function') triggerAnticipation();
    
    const audio = new Audio(url);
    audio.onplay = () => {
      this.isSpeaking = true;
      setUIState('speaking');
      if (typeof depth !== 'undefined') depth = 0.7;
    };
    audio.onended = () => {
      this.isSpeaking = false;
      setUIState('idle');
    };
    audio.onerror = () => {
      // Fallback to browser TTS
      if (text) this.speak(text);
    };
    audio.play().catch(() => {
      if (text) this.speak(text);
    });
  },
  
  speak(text) {
    if (!this.synthesis || !text) return;
    this.synthesis.cancel();
    
    // Trigger anticipation animation before speaking
    if (typeof triggerAnticipation === 'function') triggerAnticipation();
    
    const clean = text.replace(/```[\s\S]*?```/g, '').replace(/\*[^*]+\*/g, '').replace(/[#_`]/g, '').slice(0, 800);
    this.lastSpoken = text;
    
    // Get voice profile for current persona
    const profile = this.voiceProfiles[this.currentPersona] || this.voiceProfiles.default;
    
    const u = new SpeechSynthesisUtterance(clean);
    u.voice = this.voice;
    u.rate = profile.rate;
    u.pitch = profile.pitch;
    
    u.onstart = () => { 
      this.isSpeaking = true; 
      setUIState('speaking');
      if (typeof depth !== 'undefined') depth = 0.7;
    };
    u.onend = () => { 
      this.isSpeaking = false; 
      setUIState('idle');
    };
    
    this.synthesis.speak(u);
  },
  
  setPersona(name) {
    this.currentPersona = name;
    console.log('Persona:', name, this.voiceProfiles[name] || this.voiceProfiles.default);
  }
};

Ares.init();

// ============================================
// LUSH PAD SYNTH (Tone.js)
// ============================================
// Chord progressions with rich, atmospheric pads

const Pads = {
  synth: null,
  reverb: null,
  delay: null,
  isPlaying: false,
  currentProgression: 0,
  
  // Common emotional chord progressions
  progressions: {
    // Dreamy/Ethereal - Cmaj7 → Fmaj7 → Am7 → G
    dreamy: [
      ['C4', 'E4', 'G4', 'B4'],
      ['F3', 'A3', 'C4', 'E4'],
      ['A3', 'C4', 'E4', 'G4'],
      ['G3', 'B3', 'D4', 'F4']
    ],
    // Melancholic - Am → F → C → G
    melancholic: [
      ['A3', 'C4', 'E4'],
      ['F3', 'A3', 'C4'],
      ['C3', 'E3', 'G3'],
      ['G3', 'B3', 'D4']
    ],
    // Hopeful/Ascending - C → G → Am → Em → F → C → F → G
    hopeful: [
      ['C3', 'E3', 'G3', 'C4'],
      ['G3', 'B3', 'D4', 'G4'],
      ['A3', 'C4', 'E4'],
      ['E3', 'G3', 'B3'],
      ['F3', 'A3', 'C4'],
      ['C3', 'E3', 'G3'],
      ['F3', 'A3', 'C4'],
      ['G3', 'B3', 'D4']
    ],
    // Mysterious/Tense - Dm → Bb → Gm → A7
    mysterious: [
      ['D3', 'F3', 'A3', 'D4'],
      ['Bb2', 'D3', 'F3', 'Bb3'],
      ['G3', 'Bb3', 'D4'],
      ['A3', 'C#4', 'E4', 'G4']
    ],
    // Cosmic/Ambient - Fmaj9 → Cmaj9 → Am9 → Em9
    cosmic: [
      ['F2', 'A2', 'C3', 'E3', 'G3'],
      ['C2', 'E2', 'G2', 'B2', 'D3'],
      ['A2', 'C3', 'E3', 'G3', 'B3'],
      ['E2', 'G2', 'B2', 'D3', 'F#3']
    ],
    // Lo-fi chill - Dm7 → G7 → Cmaj7 → Am7
    lofi: [
      ['D3', 'F3', 'A3', 'C4'],
      ['G3', 'B3', 'D4', 'F4'],
      ['C3', 'E3', 'G3', 'B3'],
      ['A3', 'C4', 'E4', 'G4']
    ],
    
    // ============================================
    // J DILLA - FANTASTIC VOL. 1 & 2
    // Neo-soul hip-hop harmonic blueprint
    // ============================================
    
    // Players (Vol 1 & 2) - Ebm7 → Abm7 → Fm7 → Bbm7 @ 94 BPM
    // Sample: "Clair" by The Singers Unlimited (1974)
    dilla_players: [
      ['Eb3', 'Gb3', 'Bb3', 'Db4'],  // Ebm7
      ['Ab3', 'Cb4', 'Eb4', 'Gb4'],  // Abm7 (Cb = B)
      ['F3', 'Ab3', 'C4', 'Eb4'],    // Fm7
      ['Bb3', 'Db4', 'F4', 'Ab4']    // Bbm7
    ],
    
    // Look of Love (Remix) - Bm7 → Cmaj7 → Em7
    // Sample: Minnie Riperton "Inside My Love" (1975)
    dilla_look_of_love: [
      ['B3', 'D4', 'F#4', 'A4'],     // Bm7
      ['C3', 'E3', 'G3', 'B3'],      // Cmaj7
      ['E3', 'G3', 'B3', 'D4']       // Em7
    ],
    
    // 5 Ela (Remix) - Dm9 → Em7 → C#m7
    // Sample: Patrice Rushen "Remind Me" (1982)
    // Dual-tonal: D minor + A major simultaneously
    dilla_5ela: [
      ['D3', 'F3', 'A3', 'C4', 'E4'], // Dm9
      ['E3', 'G3', 'B3', 'D4'],       // Em7
      ['C#3', 'E3', 'G#3', 'B3']      // C#m7
    ],
    
    // Give This Nigga - Cm7 → Fm7 → F7 (Eb major)
    // Sample: Zapp "Heartbreaker" (1983)
    dilla_give: [
      ['C3', 'Eb3', 'G3', 'Bb3'],    // Cm7
      ['F3', 'Ab3', 'C4', 'Eb4'],    // Fm7
      ['F3', 'A3', 'C4', 'Eb4']      // F7
    ],
    
    // Fall in Love - Bbm → Ab → Fm7 → Fm (F minor) @ 92 BPM
    // Sample: Gap Mangione "Diana in the Autumn Wind" (1968)
    dilla_fall_in_love: [
      ['Bb3', 'Db4', 'F4'],          // Bbm
      ['Ab3', 'C4', 'Eb4'],          // Ab
      ['F3', 'Ab3', 'C4', 'Eb4'],    // Fm7
      ['F3', 'Ab3', 'C4']            // Fm
    ],
    
    // Climax (Girl Shit) - C#m7 → Emaj7 → D#7 → C#m @ 96 BPM
    dilla_climax: [
      ['C#3', 'E3', 'G#3', 'B3'],    // C#m7
      ['E3', 'G#3', 'B3', 'D#4'],    // Emaj7
      ['D#3', 'F##3', 'A#3', 'C#4'], // D#7 (F## = G)
      ['C#3', 'E3', 'G#3']           // C#m
    ],
    
    // 2U 4U - Am7 → Em7 → Bm7 → F#m7 @ 95 BPM
    // Sample: D'Angelo "Jonz In My Bonz"
    // Descending minor 7th sequence
    dilla_2u4u: [
      ['A3', 'C4', 'E4', 'G4'],      // Am7
      ['E3', 'G3', 'B3', 'D4'],      // Em7
      ['B3', 'D4', 'F#4', 'A4'],     // Bm7
      ['F#3', 'A3', 'C#4', 'E4']     // F#m7
    ],
    
    // Hold Tight (ft. Q-Tip) - C → Db → G → F → Bb @ 97 BPM
    // Sample: Cannonball Adderley "Experience in E"
    dilla_hold_tight: [
      ['C3', 'E3', 'G3'],            // C
      ['Db3', 'F3', 'Ab3'],          // Db
      ['G3', 'B3', 'D4'],            // G
      ['F3', 'A3', 'C4'],            // F
      ['Bb3', 'D4', 'F4']            // Bb
    ],
    
    // Conant Gardens - D → Em → G @ 94 BPM
    // 8 samples including Little Beaver "A Tribute To Wes"
    dilla_conant: [
      ['D3', 'F#3', 'A3'],           // D
      ['E3', 'G3', 'B3'],            // Em
      ['G3', 'B3', 'D4']             // G
    ],
    
    // Intro (Vol 2) - Dm7 → F → G → C @ 93 BPM
    dilla_intro: [
      ['D3', 'F3', 'A3', 'C4'],      // Dm7
      ['F3', 'A3', 'C4'],            // F
      ['G3', 'B3', 'D4'],            // G
      ['C3', 'E3', 'G3']             // C
    ],
    
    // Get Dis Money - Complex 7-bar loop over E pedal @ ~88 BPM
    // Sample: Herbie Hancock "Come Running to Me" (1978)
    // Slowed 4 semitones, bass tuned 50 cents sharp
    dilla_get_dis_money: [
      ['E2', 'D3', 'F#3', 'A3'],     // D/E (E9sus4)
      ['E2', 'Db3', 'F3', 'Ab3'],    // Db/E (ambiguous)
      ['E2', 'C3', 'E3', 'G3'],      // C/E
      ['E2', 'B2', 'D3', 'F#3'],     // Bm/E (like E9 no 3rd)
      ['E2', 'Bb2', 'Db3', 'F3'],    // Bbm/E (ambiguous)
      ['E2', 'A2', 'C3', 'E3'],      // Am/E
      ['E2', 'D3', 'F#3', 'A3']      // Return to D/E
    ],
    
    // Go Ladies - G# → C# → E → F# → C#m → G#m → B @ 95 BPM
    dilla_go_ladies: [
      ['G#3', 'B#3', 'D#4'],         // G# (B# = C)
      ['C#3', 'E#3', 'G#3'],         // C# (E# = F)
      ['E3', 'G#3', 'B3'],           // E
      ['F#3', 'A#3', 'C#4'],         // F#
      ['C#3', 'E3', 'G#3'],          // C#m
      ['G#3', 'B3', 'D#4'],          // G#m
      ['B3', 'D#4', 'F#4']           // B
    ],
    
    // ============================================
    // DONUTS (2006) - Time: The Donut of the Heart
    // Samples Motherlode "When I Die"
    // Dbmaj9 → Cm9 → Fm9 → Bbm9 @ 72 BPM
    // ============================================
    dilla_time_donut: [
      // Dbmaj9: Db (root) + Ab-C-Eb-F (5-7-9-3) - silky Dilla voicing
      ['Db2', 'Ab3', 'C4', 'Eb4', 'F4'],
      // Cm9: C (root) + Bb-Eb-G-D (b7-b3-5-9)
      ['C2', 'Bb3', 'Eb4', 'G4', 'D5'],
      // Fm9: F (root) + Eb-Ab-C-G (b7-b3-5-9)
      ['F2', 'Eb3', 'Ab3', 'C4', 'G4'],
      // Bbm9: Bb (root) + Ab-Db-F-C (b7-b3-5-9)
      ['Bb1', 'Ab3', 'Db4', 'F4', 'C5']
    ]
  },
  
  // Curated Dilla playlist for continuous play
  dillaPlaylist: [
    { name: 'dilla_time_donut', tempo: 72, loops: 4 },  // Lead with Donuts
    { name: 'dilla_players', tempo: 94, loops: 3 },
    { name: 'dilla_fall_in_love', tempo: 92, loops: 3 },
    { name: 'dilla_get_dis_money', tempo: 88, loops: 2 },
    { name: 'dilla_2u4u', tempo: 95, loops: 3 },
    { name: 'dilla_look_of_love', tempo: 90, loops: 3 },
    { name: 'dilla_5ela', tempo: 92, loops: 2 },
    { name: 'dilla_climax', tempo: 96, loops: 2 },
    { name: 'dilla_hold_tight', tempo: 97, loops: 2 },
    { name: 'dilla_conant', tempo: 94, loops: 3 },
    { name: 'dilla_intro', tempo: 93, loops: 2 },
    { name: 'dilla_give', tempo: 90, loops: 2 },
    { name: 'dilla_go_ladies', tempo: 95, loops: 2 }
  ],
  
  async init() {
    // Load Tone.js from CDN if not present
    if (typeof Tone === 'undefined') {
      await this.loadToneJS();
    }
    
    // Start audio context first (required before creating effects)
    await Tone.start();
    
    // Master limiter to prevent clipping
    this.limiter = new Tone.Limiter(-3).toDestination();
    
    // DuoSynth for rich, dual-oscillator warmth (Dilla's sampled Rhodes vibe)
    this.synth = new Tone.PolySynth(Tone.DuoSynth, {
      maxPolyphony: 8,
      vibratoAmount: 0.3,
      vibratoRate: 0.4,
      harmonicity: 1.5,
      voice0: {
        oscillator: { type: 'triangle' },
        envelope: { attack: 2, decay: 1, sustain: 0.8, release: 4 },
        filterEnvelope: { attack: 2, decay: 1, sustain: 0.5, release: 4, baseFrequency: 200, octaves: 3 }
      },
      voice1: {
        oscillator: { type: 'sine' },
        envelope: { attack: 2.5, decay: 1, sustain: 0.7, release: 4.5 },
        filterEnvelope: { attack: 2, decay: 1, sustain: 0.5, release: 4, baseFrequency: 400, octaves: 2 }
      }
    }).connect(this.limiter);
    
    // High-pass filter to remove sub-bass rumble (speaker-friendly)
    this.highpass = new Tone.Filter(120, 'highpass').connect(this.limiter);
    
    // Sub layer - disabled by default (too heavy for most speakers)
    // this.subBass = new Tone.Synth({...}).connect(this.limiter);
    this.subBass = null; // Disabled - uncomment above for subs
    
    // Shimmer layer (very quiet)
    this.airPad = new Tone.PolySynth(Tone.AMSynth, {
      maxPolyphony: 4,
      harmonicity: 0.5,
      oscillator: { type: 'sine' },
      envelope: { attack: 3, decay: 1, sustain: 0.5, release: 6 },
      modulation: { type: 'triangle' },
      modulationEnvelope: { attack: 4, decay: 2, sustain: 0.3, release: 6 }
    }).connect(this.limiter);
    this.airPad.volume.value = -28;
    
    // Lush reverb (through limiter)
    this.reverb = new Tone.Reverb({
      decay: 8,
      wet: 0.5,
      preDelay: 0.2
    }).connect(this.limiter);
    
    // Slow chorus for width
    this.chorus = new Tone.Chorus({
      frequency: 0.4,
      delayTime: 4,
      depth: 0.5,
      wet: 0.35
    }).connect(this.reverb).start();
    
    // Delay
    this.delay = new Tone.FeedbackDelay({
      delayTime: '4n.',
      feedback: 0.2,
      wet: 0.15
    }).connect(this.reverb);
    
    // Chain effects through highpass
    this.synth.connect(this.highpass);
    this.synth.connect(this.chorus);
    this.synth.connect(this.delay);
    this.airPad.connect(this.reverb);
    
    // Volume - quieter to leave room for drums
    this.synth.volume.value = -18;
    
    await this.reverb.generate();
    console.log('[Pads] 🎹 Pad synth ready (limited, -18dB)');
  },
  
  loadToneJS() {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js';
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  },
  
  // Play a single chord on all layers (with optional time for scheduling)
  playChord(notes, duration = '2n', time) {
    if (!this.synth) return;
    // Main pad (detuned saws + chorus)
    this.synth.triggerAttackRelease(notes, duration, time);
    // Sub bass - play root note an octave down
    if (this.subBass && notes.length > 0) {
      const root = notes[0].replace(/\d/, n => Math.max(1, parseInt(n) - 1));
      this.subBass.triggerAttackRelease(root, duration, time);
    }
    // Air pad - play top notes an octave up
    if (this.airPad) {
      const highNotes = notes.slice(-2).map(n => n.replace(/\d/, m => parseInt(m) + 1));
      this.airPad.triggerAttackRelease(highNotes, duration, time);
    }
  },
  
  // Play a progression (loops)
  async play(name = 'dreamy', tempo = 60, loop = true) {
    if (!this.synth) await this.init();
    
    const prog = this.progressions[name];
    if (!prog) {
      console.warn('[Pads] Unknown progression:', name);
      return;
    }
    
    await Tone.start();
    Tone.Transport.bpm.value = tempo;
    
    this.isPlaying = true;
    this.currentProgression = 0;
    
    const chordDuration = '1m'; // 1 measure per chord
    
    // Schedule chord changes
    const playNext = (time) => {
      if (!this.isPlaying) return;
      
      const chord = prog[this.currentProgression % prog.length];
      this.synth.triggerAttackRelease(chord, chordDuration, time);
      this.currentProgression++;
      
      if (loop || this.currentProgression < prog.length) {
        Tone.Transport.scheduleOnce(playNext, '+1m');
      }
    };
    
    Tone.Transport.scheduleOnce(playNext, '+0.1');
    Tone.Transport.start();
    
    console.log(`[Pads] Playing "${name}" at ${tempo} BPM`);
  },
  
  stop() {
    this.isPlaying = false;
    this.playlistIndex = -1;
    if (this.synth) {
      this.synth.releaseAll();
    }
    Tone.Transport.stop();
    Tone.Transport.cancel();
    console.log('[Pads] Stopped');
  },
  
  // Play the full Dilla playlist - each progression loops 2-3x then advances
  async playDilla() {
    if (!this.synth) await this.init();
    await Tone.start();
    
    this.isPlaying = true;
    this.playlistIndex = 0;
    
    console.log('[Pads] 🎹 J Dilla Fantastic Vol 1 & 2 - Starting playlist...');
    this.playNextInPlaylist();
  },
  
  playNextInPlaylist() {
    if (!this.isPlaying || this.playlistIndex >= this.dillaPlaylist.length) {
      if (this.isPlaying) {
        console.log('[Pads] 🎹 Playlist complete - looping...');
        this.playlistIndex = 0;
      } else {
        return;
      }
    }
    
    const item = this.dillaPlaylist[this.playlistIndex];
    const prog = this.progressions[item.name];
    if (!prog) {
      this.playlistIndex++;
      this.playNextInPlaylist();
      return;
    }
    
    Tone.Transport.stop();
    Tone.Transport.cancel();
    Tone.Transport.bpm.value = item.tempo;
    
    const totalChords = prog.length * item.loops;
    let chordIndex = 0;
    
    const trackName = item.name.replace('dilla_', '').replace(/_/g, ' ');
    console.log(`[Pads] ▶ "${trackName}" @ ${item.tempo} BPM (${item.loops}x)`);
    
    const playChordInner = (time) => {
      if (!this.isPlaying) return;
      
      const chord = prog[chordIndex % prog.length];
      // Play all layers with proper timing
      this.playChord(chord, '1m', time);
      console.log(`[Pads] Chord ${chordIndex + 1}/${totalChords}:`, chord[0]);
      chordIndex++;
      
      if (chordIndex < totalChords) {
        Tone.Transport.scheduleOnce(playChordInner, '+1m');
      } else {
        // Move to next in playlist
        Tone.Transport.scheduleOnce(() => {
          this.playlistIndex++;
          this.playNextInPlaylist();
        }, '+1m');
      }
    };
    
    Tone.Transport.scheduleOnce(playChordInner, '+0.1');
    
    // Only start Transport if not already running
    if (Tone.Transport.state !== 'started') {
      Tone.Transport.start();
    }
  },
  
  // Lo-fi effects chain (Dilla/Madlib style)
  async addLofi() {
    if (!this.synth) await this.init();
    
    // Disconnect existing
    this.synth.disconnect();
    
    // Bit crusher (SP-1200 style - 12-bit, 26kHz)
    this.bitcrusher = new Tone.BitCrusher(4).toDestination();
    
    // Chebyshev waveshaper for warm saturation
    this.saturation = new Tone.Chebyshev(50).toDestination();
    
    // Vibrato for tape wobble/wow
    this.wobble = new Tone.Vibrato({
      frequency: 0.5,  // Slow wobble
      depth: 0.1       // Subtle
    }).toDestination();
    
    // AutoFilter for vinyl frequency roll-off
    this.filter = new Tone.AutoFilter({
      frequency: 0.08,
      baseFrequency: 200,
      octaves: 2
    }).toDestination().start();
    
    // Reconnect chain: synth → wobble → saturation → filter → reverb
    this.synth.chain(this.wobble, this.saturation, this.filter, this.reverb);
    
    // Lower bit crusher mix (parallel)
    this.synth.connect(this.bitcrusher);
    this.bitcrusher.wet.value = 0.15;
    
    console.log('[Pads] 📼 Lo-fi mode: tape wobble + saturation + bit crush');
  },
  
  // Vinyl crackle noise layer
  async addVinyl() {
    if (this.vinylNoise) return;
    
    if (typeof Tone === 'undefined') await this.loadToneJS();
    
    // Create filtered noise for vinyl crackle
    this.vinylNoise = new Tone.Noise('brown').start();
    const vinylFilter = new Tone.Filter(800, 'highpass');
    const vinylGain = new Tone.Gain(0.03).toDestination(); // Very quiet
    
    // Random amplitude modulation for crackle effect
    const crackleLFO = new Tone.LFO({
      frequency: 8,
      min: 0,
      max: 0.05
    }).start();
    
    this.vinylNoise.chain(vinylFilter, vinylGain);
    crackleLFO.connect(vinylGain.gain);
    
    console.log('[Pads] 💿 Vinyl crackle added');
  },
  
  removeVinyl() {
    if (this.vinylNoise) {
      this.vinylNoise.stop();
      this.vinylNoise.dispose();
      this.vinylNoise = null;
      console.log('[Pads] Vinyl removed');
    }
  },
  
  // Change synth character
  setType(type) {
    if (!this.synth) return;
    const types = {
      warm: { type: 'fatsawtooth', count: 3, spread: 30 },
      glass: { type: 'sine', partialCount: 8 },
      strings: { type: 'fatsquare', count: 2, spread: 20 },
      organ: { type: 'triangle', partialCount: 4 },
      digital: { type: 'pulse', width: 0.3 },
      // Dilla-style Rhodes/Wurli
      rhodes: { type: 'sine', partialCount: 4 },
      wurli: { type: 'triangle', partialCount: 3 }
    };
    if (types[type]) {
      this.synth.set({ oscillator: types[type] });
      console.log(`[Pads] Synth type: ${type}`);
    }
  },
  
  // List available progressions
  list() {
    return Object.keys(this.progressions);
  },
  
  // List just Dilla progressions
  listDilla() {
    return Object.keys(this.progressions).filter(k => k.startsWith('dilla_'));
  }
};

// Expose globally
window.Pads = Pads;

// ============================================
// DILLA DRUMS - MPC-style with drunk timing
// ============================================
const Drums = {
  kick: null,
  snare: null,
  closedHat: null,
  openHat: null,
  snareFilter: null,
  hatFilter: null,
  isPlaying: false,
  patterns: [],
  
  async init() {
    if (typeof Tone === 'undefined') {
      await Pads.loadToneJS();
    }
    await Tone.start();
    
    // High-pass for kick (remove extreme sub)
    this.kickFilter = new Tone.Filter(60, 'highpass').toDestination();
    
    // 808 Kick - reduced sub, speaker-friendly
    this.kick = new Tone.MembraneSynth({
      pitchDecay: 0.2,    // Shorter pitch drop
      octaves: 3,         // Less deep sweep
      oscillator: { type: 'sine' },
      envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.8 }
    }).connect(this.kickFilter);
    this.kick.volume.value = -12;
    
    // Snare - noise + filter for body
    this.snareFilter = new Tone.Filter(9000, 'lowpass').toDestination();
    this.snare = new Tone.NoiseSynth({
      noise: { type: 'white' },
      envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.1 }
    }).connect(this.snareFilter);
    this.snare.volume.value = -8;
    
    // Closed hi-hat - very short, bright
    this.hatFilter = new Tone.Filter(12000, 'highpass').toDestination();
    this.closedHat = new Tone.NoiseSynth({
      noise: { type: 'white' },
      envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.01 }
    }).connect(this.hatFilter);
    this.closedHat.volume.value = -14;
    
    // Open hi-hat - longer decay
    this.openHat = new Tone.NoiseSynth({
      noise: { type: 'white' },
      envelope: { attack: 0.001, decay: 0.25, sustain: 0, release: 0.1 }
    }).connect(this.hatFilter);
    this.openHat.volume.value = -16;
    
    // Set global swing for Dilla feel
    Tone.Transport.swing = 0.3;         // 30% swing
    Tone.Transport.swingSubdivision = '16n';
    
    console.log('[Drums] 🥁 808 kit ready (swing: 30%)');
  },
  
  // Boom-bap pattern
  async play(tempo = 90) {
    if (!this.kick) await this.init();
    
    // Clear existing patterns without stopping Transport
    this.isPlaying = false;
    this.patterns.forEach(p => { p.stop(); p.dispose(); });
    this.patterns = [];
    
    this.isPlaying = true;
    Tone.Transport.bpm.value = tempo;
    
    // Kick: 1, 1-and-a, 3
    const kickSeq = new Tone.Sequence((time, note) => {
      if (!this.isPlaying || !note) return;
      this.kick.triggerAttackRelease(note, '8n', time);
    }, ['C1', null, null, 'C1', null, null, null, null, 'C1', null, null, null, null, null, null, null], '16n');
    kickSeq.humanize = '20ms';
    
    // Snare: 2 and 4
    const snareSeq = new Tone.Sequence((time, hit) => {
      if (!this.isPlaying || !hit) return;
      this.snare.triggerAttackRelease('8n', time);
    }, [null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null], '16n');
    snareSeq.humanize = '15ms';
    
    // Hats: 16ths with velocity groove (ghost notes)
    const hatSeq = new Tone.Sequence((time, vel) => {
      if (!this.isPlaying) return;
      this.closedHat.volume.value = -14 + (vel * 4);
      this.closedHat.triggerAttackRelease('32n', time);
    }, [1, 0.3, 0.6, 0.3, 0.9, 0.3, 0.5, 0.4, 1, 0.3, 0.6, 0.3, 0.9, 0.3, 0.5, 0.3], '16n');
    hatSeq.humanize = '10ms';
    
    // Open hat on some upbeats
    const openHatSeq = new Tone.Sequence((time, hit) => {
      if (!this.isPlaying || !hit) return;
      this.openHat.triggerAttackRelease('8n', time);
    }, [null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1], '16n');
    
    kickSeq.start(0);
    snareSeq.start(0);
    hatSeq.start(0);
    openHatSeq.start(0);
    
    this.patterns = [kickSeq, snareSeq, hatSeq, openHatSeq];
    
    // Only start Transport if not already running
    if (Tone.Transport.state !== 'started') {
      Tone.Transport.start();
    }
    
    console.log(`[Drums] ▶ Playing @ ${tempo} BPM`);
  },
  
  stop() {
    this.isPlaying = false;
    this.patterns.forEach(p => { p.stop(); p.dispose(); });
    this.patterns = [];
    // Don't stop Transport - Pads may still be using it
    console.log('[Drums] Stopped');
  },
  
  // Adjust Transport swing (0-1)
  setSwing(amount) {
    Tone.Transport.swing = Math.max(0, Math.min(1, amount));
    console.log(`[Drums] Swing: ${Tone.Transport.swing}`);
  }
};

window.Drums = Drums;

// Auto-start Dilla pads + drums on first user interaction
let padsStarted = false;
document.addEventListener('click', async () => {
  if (padsStarted) return;
  padsStarted = true;
  try {
    console.log('[Pads] First click detected, initializing...');
    await Pads.init();
    await Drums.init();
    console.log('[Pads] Synth + Drums initialized');
    // await Pads.addLofi(); // Disabled: requires HTTPS for AudioWorklet
    Pads.playDilla();
    Drums.play(Pads.dillaPlaylist[0].tempo);
    console.log('[Pads] 🎹🥁 Auto-started J Dilla playlist with drums');
  } catch (e) {
    console.error('[Pads] Failed to start:', e);
    padsStarted = false; // Allow retry
  }
}, { once: false }); // not once - allow retry on error

// AudioContext recovery on network/visibility changes
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible' && typeof Tone !== 'undefined') {
    if (Tone.context.state === 'suspended' || Tone.context.state === 'interrupted') {
      console.log('[Audio] Resuming AudioContext after visibility change...');
      await Tone.context.resume();
      if (Tone.Transport.state !== 'started' && Pads.isPlaying) {
        Tone.Transport.start();
      }
    }
  }
});

// Also try to recover on online event
window.addEventListener('online', async () => {
  if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
    console.log('[Audio] Network restored, resuming AudioContext...');
    await Tone.context.resume();
  }
});

// ============================================
// QUICK START
// ============================================
// Pads.playDilla()         - Play all Dilla progressions (loops 2-3x each)
// Pads.addLofi()           - Add tape wobble + saturation + bitcrush
// Pads.addVinyl()          - Add vinyl crackle
// Pads.stop()              - Stop everything
//
// Individual progressions:
// Pads.play('dilla_players', 94)
// Pads.play('dilla_fall_in_love', 92)
// Pads.play('dilla_get_dis_money', 88)
//
// Synth types: warm, glass, strings, organ, digital, rhodes, wurli
// Pads.setType('rhodes')
</script>

</body>
</html>
