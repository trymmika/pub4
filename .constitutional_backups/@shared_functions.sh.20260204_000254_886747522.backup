#!/usr/bin/env zsh
# Shared functions for Rails app generators
# Per master.yml v206 workflow: Extract duplication, DRY, modern zsh

set -euo pipefail
emulate -L zsh
setopt extended_glob warn_create_global

# Generate base application.scss with CSS variables
generate_application_scss() {

  typeset theme_color="${1:-#0066ff}"

  typeset dark_mode="${2:-true}"

  typeset -r target="app/assets/stylesheets/application.scss"

  [[ -d ${target:h} ]] || mkdir -p ${target:h}
  print -r "/* Generated per master.yml v206 */
:root {

  --primary: ${theme_color};

  --bg: #ffffff;

  --surface: #f8f9fa;

  --text: #1a1a1a;

  --border: #dadce0;

  --spacing: 1rem;

}" > $target

  if [[ $dark_mode == true ]]; then
    print -r "

@media (prefers-color-scheme: dark) {

  :root {

    --bg: #1a1a1a;

    --surface: #2a2a2a;

    --text: #ffffff;

    --border: #3a3a3a;

  }

}" >> $target

  fi

  print -r "
* {

  box-sizing: border-box;

  margin: 0;

  padding: 0;

}

body {
  font-family: system-ui, -apple-system, sans-serif;

  background: var(--bg);

  color: var(--text);

  line-height: 1.6;

}

main {
  max-width: 1200px;

  margin: 0 auto;

  padding: var(--spacing);

}" >> $target

}

# Generate secure controller with authentication + authorization
generate_secure_controller() {

  typeset name=$1

  typeset model=${name:l}

  typeset model_class=${(C)name}

  typeset -r target="app/controllers/${model}_controller.rb"

  [[ -d ${target:h} ]] || mkdir -p ${target:h}
  print -r > $target << RUBY
class ${model_class}Controller < ApplicationController

  before_action :authenticate_user!, except: [:index, :show]

  before_action :set_${model}, only: [:show, :edit, :update, :destroy]

  before_action :authorize_user!, only: [:edit, :update, :destroy]

  def index
    @pagy, @${model}s = pagy(${model_class}.all.order(created_at: :desc))

  end

  def show
  end

  def new
    @${model} = current_user.${model}s.build

  end

  def create
    @${model} = current_user.${model}s.build(${model}_params)

    if @${model}.save

      respond_to do |format|

        format.html { redirect_to @${model}, notice: t("${model}.created") }

        format.turbo_stream

      end

    else

      render :new, status: :unprocessable_entity

    end

  end

  def edit
  end

  def update
    if @${model}.update(${model}_params)

      respond_to do |format|

        format.html { redirect_to @${model}, notice: t("${model}.updated") }

        format.turbo_stream

      end

    else

      render :edit, status: :unprocessable_entity

    end

  end

  def destroy
    @${model}.destroy

    redirect_to ${model}s_path, notice: t("${model}.destroyed")

  end

  private
  def set_${model}
    @${model} = ${model_class}.find(params[:id])

  end

  def authorize_user!
    unless @${model}.user == current_user || current_user&.admin?

      redirect_to ${model}s_path, alert: t('unauthorized')

    end

  end

  def ${model}_params
    # Override this method in the calling script with actual permitted params

    params.require(:${model}).permit(:title, :content)

  end

end

RUBY

}

# Generate Stimulus controller boilerplate
generate_stimulus_controller() {

  typeset name=$1

  shift

  typeset -a targets=("$@")

  typeset -r target_dir="app/javascript/controllers"

  typeset -r target="${target_dir}/${name}_controller.js"

  [[ -d $target_dir ]] || mkdir -p $target_dir
  # Convert array to comma-separated quoted strings
  typeset targets_str="${(j:, :)${(@qq)targets}}"

  print -r > $target << JS
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = [${targets_str}]

  connect() {
    console.log("${name} controller connected")

  }

  // Add your actions here
}

JS

}

# Generate application layout with Stimulus/Turbo
generate_application_layout() {

  local app_name="$1"

  local description="$2"

  mkdir -p app/views/layouts
  cat > app/views/layouts/application.html.erb << 'LAYOUT'
<!DOCTYPE html>

<html lang="<%= I18n.locale %>">

<head>

  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width,initial-scale=1">

  <title><%= content_for?(:title) ? yield(:title) + " - ${app_name}" : "${app_name}" %></title>

  <meta name="description" content="<%= content_for?(:description) ? yield(:description) : '${description}' %>">

  <%= csrf_meta_tags %>

  <%= csp_meta_tag %>

  <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>

  <%= javascript_importmap_tags %>

</head>

<body class="<%= controller_name %> <%= action_name %>">

  <%= yield %>

</body>

</html>

LAYOUT

}

# Setup Stimulus Reflex (if needed)
setup_stimulus_reflex() {

  grep -q "stimulus_reflex" Gemfile || cat >> Gemfile << 'GEMS'

# Real-time with Stimulus Reflex
gem "stimulus_reflex", "~> 3.5"

gem "cable_ready", "~> 5.0"

GEMS

  bundle install
  bin/rails stimulus_reflex:install

}

# Add acts_as_votable with proper setup
setup_voting() {

  grep -q "acts_as_votable" Gemfile || cat >> Gemfile << 'GEMS'

gem "acts_as_votable"

GEMS

  bundle install
  bin/rails generate acts_as_votable:migration

  bin/rails db:migrate

}

# Generate voting Stimulus controller
generate_voting_stimulus() {

  cat > app/javascript/controllers/vote_controller.js << 'JS'

import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static values = { type: String, id: Number }

  static targets = ["score", "upvote", "downvote"]

  async vote(event) {
    const action = event.params.action

    const response = await fetch(`/${this.typeValue}/${this.idValue}/${action}`, {

      method: action === 'unvote' ? 'DELETE' : 'POST',

      headers: {

        'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content,

        'Accept': 'application/json'

      }

    })

    if (response.ok) {
      const data = await response.json()

      this.scoreTarget.textContent = data.score

      this.updateButtons(action)

    }

  }

  updateButtons(action) {
    this.upvoteTarget.classList.toggle('active', action === 'upvote')

    this.downvoteTarget.classList.toggle('active', action === 'downvote')

  }

}

JS

}

# Log helper - pure zsh
log() {

  typeset timestamp="${$(strftime '%Y-%m-%d %H:%M:%S' $EPOCHSECONDS)}"

  print -r "[${timestamp}] $*"

}

# Check if app already exists (idempotency)
check_app_exists() {

  typeset app_name=$1

  typeset marker_file=$2

  if [[ -f $marker_file ]]; then
    log "App $app_name already generated (found $marker_file), skipping"

    return 0

  fi

  return 1

}

# Setup Rails 8 authentication
setup_authentication() {

  if grep -q "devise" Gemfile; then

    log "Devise already in Gemfile"

  else

    cat >> Gemfile << 'GEMS'

gem "devise"

gem "devise-guests"

GEMS

    bundle install

    bin/rails generate devise:install

    bin/rails generate devise User

    bin/rails generate devise_guests:install

    bin/rails db:migrate

  fi

}

# ═══════════════════════════════════════════════════════════════════════════════
# ADDITIONAL SHARED FUNCTIONS - Extracted from app generators per master.yml
# ═══════════════════════════════════════════════════════════════════════════════

# Check if command exists
command_exists() {
  command -v "$1" >/dev/null 2>&1 || { log "ERROR: $1 not found"; exit 1; }
}

# Install gem idempotently
install_gem() {
  typeset gem_name="$1"
  grep -q "gem "${gem_name}"" Gemfile || {
    print "gem "${gem_name}"" >> Gemfile
    bundle install
  }
}

# Setup full Rails 8 app with Solid Stack
setup_full_app() {
  typeset app_name="$1"
  typeset app_dir="${BASE_DIR:-/home/dev/rails}/${app_name}"

  [[ -d "$app_dir" ]] || mkdir -p "$app_dir"
  cd "$app_dir"

  if [[ ! -f "config/application.rb" ]]; then
    log "Creating Rails 8 application: $app_name"
    rails new . --database=postgresql --skip-git --css=tailwind --javascript=esbuild
  fi

  # Add Solid Stack if not present
  grep -q "solid_queue" Gemfile || cat >> Gemfile << 'SOLIDGEMS'
gem "solid_queue"
gem "solid_cache"
gem "solid_cable"
SOLIDGEMS

  bundle install
  bin/rails generate solid_queue:install 2>/dev/null || true
  bin/rails generate solid_cache:install 2>/dev/null || true
  bin/rails generate solid_cable:install 2>/dev/null || true
}

# Generate InfiniteScrollReflex for any model
# Usage: generate_infinite_scroll_reflex "Post" "Post.all.order(created_at: :desc)"
generate_infinite_scroll_reflex() {
  typeset model_name="$1"
  typeset query="$2"
  typeset reflex_name="${model_name:l}s"
  typeset class_name="${(C)model_name}sInfiniteScrollReflex"

  mkdir -p app/reflexes
  cat > "app/reflexes/${reflex_name}_infinite_scroll_reflex.rb" << RUBY
class ${class_name} < InfiniteScrollReflex
  def load_more
    @pagy, @collection = pagy(${query}, page: page)
    super
  end
end
RUBY
}

# Generate base InfiniteScrollReflex (parent class)
generate_base_infinite_scroll_reflex() {
  mkdir -p app/reflexes
  cat > app/reflexes/infinite_scroll_reflex.rb << 'RUBY'
class InfiniteScrollReflex < ApplicationReflex
  def load_more
    morph "#items", render(partial: "shared/items", locals: { items: @collection, pagy: @pagy })
  end

  private

  def page
    element.dataset[:page].to_i
  end
end
RUBY
}

# Generate infinite scroll Stimulus controller
generate_infinite_scroll_controller() {
  mkdir -p app/javascript/controllers
  cat > app/javascript/controllers/infinite_scroll_controller.js << 'JS'
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static values = { page: { type: Number, default: 1 }, loading: { type: Boolean, default: false } }

  connect() {
    this.observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting && !this.loadingValue) this.loadMore()
    }, { threshold: 0.1 })
    this.observer.observe(this.element.querySelector("[data-sentinel]") || this.element.lastElementChild)
  }

  disconnect() {
    this.observer?.disconnect()
  }

  async loadMore() {
    this.loadingValue = true
    this.pageValue++
    this.stimulate(`${this.element.dataset.reflex}#load_more`, { page: this.pageValue })
    this.loadingValue = false
  }
}
JS
}

# Generate VoteReflex for votable models
generate_vote_reflex() {
  mkdir -p app/reflexes
  cat > app/reflexes/vote_reflex.rb << 'RUBY'
class VoteReflex < ApplicationReflex
  def upvote
    votable = find_votable
    votable.upvote_by(current_user || guest_user)
    update_vote_display(votable)
  end

  def downvote
    votable = find_votable
    votable.downvote_by(current_user || guest_user)
    update_vote_display(votable)
  end

  def unvote
    votable = find_votable
    votable.unvote_by(current_user || guest_user)
    update_vote_display(votable)
  end

  private

  def find_votable
    element.dataset["votable_type"].constantize.find(element.dataset["votable_id"])
  end

  def update_vote_display(votable)
    cable_ready
      .morph(selector: "#vote-#{votable.class.name.downcase}-#{votable.id}",
             html: render(partial: "shared/vote", locals: { votable: votable }))
      .broadcast
  end

  def guest_user
    User.find_or_create_by(email: "guest@example.com") { |u| u.password = SecureRandom.hex(16) }
  end
end
RUBY
}

# Generate ChatReflex for real-time messaging
generate_chat_reflex() {
  mkdir -p app/reflexes
  cat > app/reflexes/chat_reflex.rb << 'RUBY'
class ChatReflex < ApplicationReflex
  def send_message
    message = Message.create!(
      content: element.dataset["content"],
      user: current_user || guest_user,
      receiver_id: element.dataset["receiver_id"],
      anonymous: element.dataset["anonymous"] == "true"
    )

    cable_ready
      .append(selector: "#messages", html: render(partial: "messages/message", locals: { message: message }))
      .broadcast_to([current_user, message.receiver].sort_by(&:id))
  end

  private

  def guest_user
    User.find_or_create_by(email: "guest@example.com") { |u| u.password = SecureRandom.hex(16) }
  end
end
RUBY
}

# Generate shared vote partial
generate_vote_partial() {
  mkdir -p app/views/shared
  cat > app/views/shared/_vote.html.erb << 'ERB'
<div id="vote-<%= votable.class.name.downcase %>-<%= votable.id %>"
     data-controller="vote"
     data-vote-type-value="<%= votable.class.name.tableize %>"
     data-vote-id-value="<%= votable.id %>">
  <button data-action="vote#vote" data-vote-action-param="upvote" data-vote-target="upvote">▲</button>
  <span data-vote-target="score"><%= votable.cached_votes_score %></span>
  <button data-action="vote#vote" data-vote-action-param="downvote" data-vote-target="downvote">▼</button>
</div>
ERB
}

# Generate Turbo Stream templates for a resource
# Usage: generate_turbo_views "posts" "post"
generate_turbo_views() {
  typeset plural="$1"
  typeset singular="$2"

  mkdir -p "app/views/${plural}"

  cat > "app/views/${plural}/create.turbo_stream.erb" << ERB
<%= turbo_stream.prepend "${plural}", partial: "${plural}/${singular}", locals: { ${singular}: @${singular} } %>
<%= turbo_stream.update "new_${singular}_form", partial: "${plural}/form", locals: { ${singular}: ${singular^}.new } %>
ERB

  cat > "app/views/${plural}/update.turbo_stream.erb" << ERB
<%= turbo_stream.replace @${singular} %>
ERB

  cat > "app/views/${plural}/destroy.turbo_stream.erb" << ERB
<%= turbo_stream.remove @${singular} %>
ERB
}

# Generate search controller with live search
generate_search_controller() {
  mkdir -p app/javascript/controllers
  cat > app/javascript/controllers/search_controller.js << 'JS'
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["input", "results"]
  static values = { url: String, debounce: { type: Number, default: 300 } }

  connect() {
    this.timeout = null
  }

  search() {
    clearTimeout(this.timeout)
    this.timeout = setTimeout(() => this.performSearch(), this.debounceValue)
  }

  async performSearch() {
    const query = this.inputTarget.value.trim()
    if (query.length < 2) { this.resultsTarget.innerHTML = ""; return }

    const response = await fetch(`${this.urlValue}?q=${encodeURIComponent(query)}`, {
      headers: { "Accept": "text/vnd.turbo-stream.html" }
    })

    if (response.ok) {
      this.resultsTarget.innerHTML = await response.text()
    }
  }
}
JS
}
