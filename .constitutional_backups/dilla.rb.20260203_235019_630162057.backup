#!/usr/bin/env ruby
# frozen_string_literal: true

# SOS DILLA v2.1.0 - Cross-Platform Lo-Fi Production System

# Targets: Cygwin (Windows 11), OpenBSD VPS, Android Termux (Samsung)

# Backend: FFmpeg (universal) - replaces SoX for cross-platform compatibility

# Sources:

#   - J Dilla: Fantastic Vol 1 & 2, Donuts, The Shining, unreleased

#   - Flying Lotus: Los Angeles (2008)

#   - Madlib: Madvillainy, Beat Konducta

#   - Sonitex STX-1260, NastyVCS mkII, Moog DFAM

#   - arXiv papers on tape/vinyl emulation

#   - BahadÄ±rhan KoÃ§er: "Understanding Dub Drums" (dub techno)

require "json"

require "fileutils"

require "tempfile"

require "securerandom"

class SOSDilla

  VERSION = "2.1.0"

  CONFIG_FILE = File.join(File.dirname(__FILE__), "dilla_config.json")

  # Load shared config
  def self.load_config
    if File.exist?(CONFIG_FILE)
      JSON.parse(File.read(CONFIG_FILE, encoding: "UTF-8"))
    else
      puts "Config not found at #{CONFIG_FILE}, using defaults"
      {}
    end
  rescue JSON::ParserError => e
    puts "Config parse error: #{e.message}"
    {}
  end

  CONFIG = load_config

  # CHORD PROGRESSIONS (from shared config)
  def self.get_chords(artist, album, track = nil)

    chords = CONFIG.dig("chords", "#{artist}_#{album}")

    return chords[track] if track && chords&.dig(track)

    chords

  end

  DILLA_CHORDS = CONFIG.dig("chords") || {}

  # TIMING PROFILES (from shared config)
  DILLA_TIMING_CONFIG = CONFIG.dig("timing", "dilla_swing") || {

    "sweet_spot" => [53, 56],

    "tempo_range" => [82, 92],

    "nudge_ms" => { "kick" => -8, "snare" => 12, "hihat" => -3 }

  }

  # PLATFORM DETECTION
  module Platform

    def self.detect

      @platform ||= begin

        if ENV['PREFIX']&.include?('com.termux')

          :termux

        elsif RUBY_PLATFORM =~ /cygwin/i

          :cygwin

        elsif RUBY_PLATFORM =~ /openbsd/i

          :openbsd

        elsif RUBY_PLATFORM =~ /darwin/i

          :macos

        elsif RUBY_PLATFORM =~ /linux/i

          :linux

        elsif RUBY_PLATFORM =~ /mingw|mswin/i

          :windows

        else

          :unknown

        end

      end

    end

    def self.termux?;  detect == :termux  end

    def self.cygwin?;  detect == :cygwin  end

    def self.openbsd?; detect == :openbsd end

    def self.home

      ENV['HOME'] || case detect

        when :termux then '/data/data/com.termux/files/home'

        when :cygwin then '/home/' + ENV['USER'].to_s

        else Dir.pwd

      end

    end

    def self.ffmpeg_paths

      case detect

      when :termux

        %w[ffmpeg /data/data/com.termux/files/usr/bin/ffmpeg]

      when :cygwin

        %w[ffmpeg /usr/bin/ffmpeg /cygdrive/c/cygwin64/bin/ffmpeg.exe /cygdrive/c/ffmpeg/bin/ffmpeg.exe]

      when :openbsd

        %w[ffmpeg /usr/local/bin/ffmpeg]

      when :windows

        %w[ffmpeg ffmpeg.exe C:/cygwin64/bin/ffmpeg.exe C:/ffmpeg/bin/ffmpeg.exe]

      else

        %w[ffmpeg /usr/bin/ffmpeg /usr/local/bin/ffmpeg C:/cygwin64/bin/ffmpeg.exe]

      end

    end

    def self.fluidsynth_paths

      case detect

      when :termux

        %w[fluidsynth /data/data/com.termux/files/usr/bin/fluidsynth]

      when :cygwin

        %w[fluidsynth /usr/bin/fluidsynth /cygdrive/c/cygwin64/bin/fluidsynth.exe]

      when :openbsd

        %w[fluidsynth /usr/local/bin/fluidsynth]

      when :windows

        %w[fluidsynth fluidsynth.exe C:/cygwin64/bin/fluidsynth.exe]

      else

        %w[fluidsynth /usr/bin/fluidsynth /usr/local/bin/fluidsynth C:/cygwin64/bin/fluidsynth.exe]

      end

    end

    def self.install_hint

      case detect

      when :termux  then "pkg install ffmpeg ruby"

      when :cygwin  then "apt-cyg install ffmpeg ruby"

      when :openbsd then "pkg_add ffmpeg ruby"

      when :macos   then "brew install ffmpeg"

      else "Install ffmpeg from https://ffmpeg.org"

      end

    end

  end

  # DUB PROGRESSIONS (from transcript: i-v tension, i-iv meditative)
  DUB_PROGRESSIONS = {

    "dub_meditative" => [

      { root: 0, chord: [0, 3, 7], name: "min", function: "i" },

      { root: 5, chord: [0, 3, 7], name: "min", function: "iv" }

    ],

    "dub_tension" => [

      { root: 0, chord: [0, 3, 7], name: "min", function: "i" },

      { root: 7, chord: [0, 3, 7], name: "min", function: "v" }

    ],

    "rhythm_and_sound" => [

      { root: 0, chord: [0, 3, 7, 10], name: "min7", function: "i" },

      { root: 5, chord: [0, 3, 7, 10], name: "min7", function: "iv" }

    ],

    "basic_channel" => [

      { root: 0, chord: [0, 3, 7, 10], name: "min7", function: "i" }

    ]

  }

  # DUB DRUM PATTERNS (from transcript)
  DUB_PATTERNS = {

    one_drop: {

      name: "One-Drop",

      desc: "Strong hit on beat 3, reggae foundation",

      kick:    [0, 0, 1, 0],

      snare:   [0, 0, 1, 0],

      hihat:   [1, 1, 1, 1],

      rimshot: [0, 0, 1, 0]

    },

    steppers: {

      name: "Steppers",

      desc: "Four-on-the-floor mechanized groove",

      kick:    [1, 1, 1, 1],

      snare:   [0, 0, 1, 0],

      hihat:   [1, 1, 1, 1],

      rimshot: [0, 1, 0, 1]

    },

    rockers: {

      name: "Rockers",

      desc: "Syncopated driving rhythm",

      kick:    [1, 0, 0, 1],

      snare:   [0, 1, 0, 1],

      hihat:   [1, 1, 1, 1],

      rimshot: [0, 0, 1, 0]

    },

    atmospheric: {

      name: "Atmospheric",

      desc: "Berlin minimal, mechanized precision",

      kick:    [1, 0, 1, 0],

      snare:   [0, 0, 0, 0],

      hihat:   [1, 1, 1, 1],

      rimshot: [0, 0, 1, 0]

    }

  }

  # TIMING PROFILES
  DUB_TIMING = {

    mechanized: { swing: 0.50, humanize_ms: 2,  desc: "Germanic precision" },

    roots:      { swing: 0.54, humanize_ms: 25, desc: "Laid back, behind beat" },

    hybrid:     { swing: 0.52, humanize_ms: 8,  desc: "Precision with soul" }

  }

  DILLA_TIMING = {

    swing: 0.542,

    micro: { kick: -0.008, snare: 0.012, hats: -0.003, bass: -0.005 },

    humanize: { velocity: 15, timing: 0.018 }

  }

  # DELAY PRESETS (from transcript)
  DUB_DELAYS = {

    echo_16th:    { time_ms: 125, feedback: 0.45 },

    echo_8th_dot: { time_ms: 375, feedback: 0.55 },

    rimshot:      { time_ms: 380, feedback: 0.50 },

    midside:      { time_ms: 188, feedback: 0.45 }

  }

  # VINTAGE EQUIPMENT PROFILES
  VINTAGE = {

    king_tubby:      { reverb: 3.2, echo: 0.6, desc: "King Tubby Jamaica 1970s" },

    basic_channel:   { reverb: 6.0, echo: 0.55, desc: "Berlin minimal meets dub" },

    rhythm_and_sound:{ reverb: 4.5, echo: 0.58, desc: "Warmth with precision" },

    wackie:          { reverb: 2.8, echo: 0.50, desc: "South Bronx grit" },

    mpc3000:         { bits: 14, sat: 0.12, desc: "J Dilla MPC character" },

    sp1200:          { bits: 12, sat: 0.15, desc: "E-mu SP-1200 grit" }

  }

  # FFMPEG PROCESSOR
  class FFmpegProcessor

    attr_reader :sample_rate

    def initialize(sample_rate: 48000)

      @sample_rate = sample_rate

      @ffmpeg = find_ffmpeg

    end

    def find_ffmpeg

      Platform.ffmpeg_paths.each do |p|

        begin

          # Test if ffmpeg exists and is executable

          output = `#{p} -version 2>&1`

          return p if $?.success? && output.include?('ffmpeg version')

        rescue => e

          # Continue to next path

        end

      end

      'ffmpeg' # Fallback

    end

    def available?

      begin

        output = `#{@ffmpeg} -version 2>&1`

        $?.success? && output.include?('ffmpeg version')

      rescue => e

        false

      end

    end

    def run(cmd)

      output = `#{cmd} 2>&1`

      success = $?.success?

      unless success

        puts "âŒ FFmpeg command failed: #{cmd}"

        puts "   Output: #{output.split("
").first(3).join("
   ")}" if output && !output.empty?

        raise "FFmpeg command failed"

      end

      success

    end

    def tone(freq:, duration:, wave: :sine, output:, amp: 0.8)

      w = { sine: 'sine', square: 'square', triangle: 'triangle', sawtooth: 'sawtooth' }[wave] || 'sine'

      run(%Q[#{@ffmpeg} -y -f lavfi -i "#{w}=f=#{freq}:d=#{duration}:r=#{@sample_rate}" -af "volume=#{amp}" "#{output}"])

    end

    def noise(duration:, output:, color: :white, amp: 0.5)

      c = { white: 'white', pink: 'pink', brown: 'brown' }[color] || 'white'

      run(%Q[#{@ffmpeg} -y -f lavfi -i "anoisesrc=d=#{duration}:c=#{c}noise:r=#{@sample_rate}" -af "volume=#{amp}" "#{output}"])

    end

    def filter(input:, output:, chain:)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "#{chain}" "#{output}"])

    end

    def echo(input:, output:, delay_ms: 300, feedback: 0.5, mix: 0.5)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "aecho=0.8:#{mix}:#{delay_ms}:#{feedback}" "#{output}"])

    end

    def reverb(input:, output:, decay: 0.5, size: :medium)

      delays = { small: "50|100", medium: "60|120|180", large: "80|160|240|320", spring: "30|45|60" }[size] || "60|120"

      decays = delays.split('|').map { decay.to_s }.join('|')

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "aecho=0.8:0.7:#{delays}:#{decays}" "#{output}"])

    end

    def eq(input:, output:, bands:)

      f = bands.map { |b| "equalizer=f=#{b[:freq]}:width_type=q:width=#{b[:q]||1}:g=#{b[:gain]}" }.join(',')

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "#{f}" "#{output}"])

    end

    def lowpass(input:, output:, cutoff:)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "lowpass=f=#{cutoff}" "#{output}"])

    end

    def highpass(input:, output:, cutoff:)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "highpass=f=#{cutoff}" "#{output}"])

    end

    def compress(input:, output:, threshold: -20, ratio: 4)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "acompressor=threshold=#{threshold}dB:ratio=#{ratio}" "#{output}"])

    end

    def saturate(input:, output:, drive: 2.0)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "volume=#{drive},atanh,volume=#{1.0/drive}" "#{output}"])

    end

    def bitcrush(input:, output:, bits: 12)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "acrusher=bits=#{bits}:mode=lin" "#{output}"])

    end

    def mix(inputs:, output:, volumes: nil)

      volumes ||= inputs.map { 1.0 }

      args = inputs.map { |f| %Q[-i "#{f}"] }.join(' ')

      vol = inputs.each_with_index.map { |_,i| "[#{i}]volume=#{volumes[i]}[v#{i}]" }.join(';')

      ins = inputs.each_with_index.map { |_,i| "[v#{i}]" }.join

      run(%Q[#{@ffmpeg} -y #{args} -filter_complex "#{vol};#{ins}amix=inputs=#{inputs.length}:duration=longest" "#{output}"])

    end

    def normalize(input:, output:, target: -1)

      run(%Q[#{@ffmpeg} -y -i "#{input}" -af "loudnorm=I=-16:TP=#{target}" "#{output}"])

    end

  end

  # FLUIDSYNTH PROCESSOR for ambient pads and melodic synthesis
  class FluidSynthProcessor

    SOUNDFONT_PATHS = [
      File.join(File.dirname(__FILE__), "FluidR3_GM.sf2"),
      "G:/pub/media/dilla/FluidR3_GM.sf2",
      "/usr/share/sounds/sf2/FluidR3_GM.sf2",
      "/usr/local/share/sounds/sf2/FluidR3_GM.sf2"
    ].freeze

    # GM patch numbers for ambient sounds
    PATCHES = {
      pad_warm:      89,  # Pad 2 (warm)
      pad_polysynth: 90,  # Pad 3 (polysynth)
      pad_choir:     91,  # Pad 4 (choir)
      pad_bowed:     92,  # Pad 5 (bowed)
      pad_metallic:  93,  # Pad 6 (metallic)
      pad_halo:      94,  # Pad 7 (halo)
      pad_sweep:     95,  # Pad 8 (sweep)
      strings:       49,  # String Ensemble 1
      atmosphere:    99,  # FX 4 (atmosphere)
      synth_bass:    38,  # Synth Bass 1
      electric_piano: 5   # Electric Piano 2
    }.freeze

    attr_reader :soundfont

    def initialize
      @fluidsynth = find_fluidsynth
      @soundfont = find_soundfont
    end

    def find_fluidsynth
      Platform.fluidsynth_paths.each do |p|
        begin
          output = `#{p} --version 2>&1`
          return p if $?.success? && output.include?('FluidSynth')
        rescue
        end
      end
      'fluidsynth'
    end

    def find_soundfont
      SOUNDFONT_PATHS.each { |sf| return sf if File.exist?(sf) }
      nil
    end

    def available?
      begin
        output = `#{@fluidsynth} --version 2>&1`
        $?.success? && output.include?('FluidSynth') && @soundfont
      rescue
        false
      end
    end

    # Generate ambient pad from MIDI notes
    def pad(notes:, duration:, output:, patch: :pad_warm, velocity: 80, reverb: 0.6, chorus: 0.4)
      return false unless available?

      midi_file = Tempfile.new(['pad', '.mid'])
      wav_file = Tempfile.new(['pad', '.wav'])

      begin
        # Create simple MIDI for the chord
        write_midi(midi_file.path, notes, duration, PATCHES[patch] || 89, velocity)

        # Render with FluidSynth
        cmd = %Q[#{@fluidsynth} -ni -g 1.0 -R #{reverb > 0 ? 1 : 0} -C #{chorus > 0 ? 1 : 0} "#{@soundfont}" "#{midi_file.path}" -F "#{output}" -r 48000]
        system(cmd)

        File.exist?(output) && File.size(output) > 0
      ensure
        midi_file.close
        midi_file.unlink
      end
    end

    # Generate drone/atmosphere
    def drone(root:, duration:, output:, patch: :atmosphere)
      notes = [root, root + 7, root + 12]  # Root, fifth, octave
      pad(notes: notes, duration: duration, output: output, patch: patch, velocity: 60, reverb: 0.8)
    end

    # Write simple MIDI file
    def write_midi(path, notes, duration_sec, program, velocity)
      # Simple MIDI format 0 writer
      ticks_per_beat = 480
      tempo = 500000  # 120 BPM microseconds per beat
      duration_ticks = (duration_sec * 2 * ticks_per_beat).to_i

      track_data = []
      # Program change
      track_data << [0, 0xC0, program]
      # Note ons
      notes.each_with_index do |note, i|
        track_data << [i == 0 ? 0 : 0, 0x90, note, velocity]
      end
      # Note offs
      notes.each_with_index do |note, i|
        track_data << [i == 0 ? duration_ticks : 0, 0x80, note, 0]
      end

      File.open(path, 'wb') do |f|
        # Header
        f.write("MThd")
        f.write([6, 0, 1, ticks_per_beat].pack('NnnN')[0,10])
        f.write([6].pack('N'))
        f.write([0, 1, ticks_per_beat].pack('nnn'))

        # Build track
        track = []
        # Tempo meta event
        track += [0, 0xFF, 0x51, 3, (tempo >> 16) & 0xFF, (tempo >> 8) & 0xFF, tempo & 0xFF]

        track_data.each do |delta, *bytes|
          track += encode_varlen(delta)
          track += bytes
        end
        track += [0, 0xFF, 0x2F, 0]  # End of track

        f.write("MTrk")
        f.write([track.length].pack('N'))
        f.write(track.pack('C*'))
      end
    end

    def encode_varlen(value)
      return [0] if value == 0
      bytes = []
      bytes.unshift(value & 0x7F)
      value >>= 7
      while value > 0
        bytes.unshift((value & 0x7F) | 0x80)
        value >>= 7
      end
      bytes
    end
  end

  # MAIN CLASS
  attr_reader :ffmpeg, :fluidsynth, :temp_dir, :output_dir

  def initialize

    @temp_dir = Dir.mktmpdir("dilla_")

    @output_dir = File.join(Platform.home, "dilla_output")

    FileUtils.mkdir_p(@output_dir)

    @ffmpeg = FFmpegProcessor.new

    @fluidsynth = FluidSynthProcessor.new

    check_deps

  end

  def check_deps

    unless @ffmpeg.available?

      puts "âŒ FFmpeg not found!"

      puts "   Searched paths:"

      Platform.ffmpeg_paths.each { |p| puts "   - #{p}" }

      puts "
   Install: #{Platform.install_hint}"

      puts "   Or ensure ffmpeg is in your PATH"

      exit 1

    end

    puts "âœ“ FFmpeg ready (#{@ffmpeg.instance_variable_get(:@ffmpeg)}) on #{Platform.detect}"

    if @fluidsynth.available?
      puts "âœ“ FluidSynth ready with #{File.basename(@fluidsynth.soundfont)}"
    else
      puts "âš  FluidSynth not available - using FFmpeg synthesis only"
    end

  end

  def generate_dub(pattern: :one_drop, progression: "dub_meditative", key: "E", bpm: 120, bars: 4)

    puts "ðŸŽšï¸  Generating: #{pattern} | #{progression} | #{key} | #{bpm}BPM"

    duration = (60.0 / bpm) * 4 * bars

    base_freq = note_freq(key, 2)

    drums = generate_drums(duration)

    bass = generate_bass(base_freq, duration)

    chords = generate_chords(base_freq, duration)

    mixed = mix_layers(drums, bass, chords)

    master_track(mixed, "dub_#{pattern}_#{key}_#{bpm}_#{timestamp}.wav")

  end

  def generate_drums(duration)

    kick = temp_file("kick.wav")

    @ffmpeg.tone(freq: AudioConstants::KICK_FREQ, duration: AudioConstants::KICK_DURATION, wave: :sine, output: kick, amp: 0.9)

    @ffmpeg.lowpass(input: kick, output: kick, cutoff: AudioConstants::KICK_CUTOFF)

    hat = temp_file("hat.wav")

    @ffmpeg.noise(duration: AudioConstants::HAT_DURATION, output: hat, amp: 0.15)

    @ffmpeg.highpass(input: hat, output: hat, cutoff: AudioConstants::HAT_CUTOFF)

    drums = temp_file("drums.wav")

    silence = temp_file("silence.wav")

    @ffmpeg.tone(freq: 1, duration: duration, wave: :sine, output: silence, amp: 0)

    @ffmpeg.mix(inputs: [silence, kick, hat], output: drums, volumes: [1, 0.8, 0.3])

    apply_dub_fx(drums, :drums)

  end

  def generate_bass(base_freq, duration)

    bass = temp_file("bass.wav")

    @ffmpeg.tone(freq: base_freq, duration: duration, wave: :sine, output: bass, amp: 0.7)

    @ffmpeg.lowpass(input: bass, output: bass, cutoff: AudioConstants::BASS_CUTOFF)

    apply_dub_fx(bass, :bass)

  end

  def generate_chords(base_freq, duration)

    chords = temp_file("chords.wav")

    @ffmpeg.tone(freq: base_freq * 4, duration: duration, wave: :triangle, output: chords, amp: 0.25)

    apply_dub_fx(chords, :chords)

  end

  def apply_dub_fx(input, type)

    output = temp_file("#{type}_fx.wav")

    case type

    when :drums

      @ffmpeg.reverb(input: input, output: output, decay: 0.4, size: :spring)

      @ffmpeg.echo(input: output, output: output, delay_ms: 375, feedback: 0.35)

    when :bass

      @ffmpeg.compress(input: input, output: output, threshold: AudioConstants::COMPRESS_THRESHOLD, ratio: AudioConstants::COMPRESS_RATIO)

    when :chords

      @ffmpeg.echo(input: input, output: output, delay_ms: 125, feedback: 0.4)

      @ffmpeg.reverb(input: output, output: output, decay: 0.5, size: :large)

    end

    output

  end

  def mix_layers(drums, bass, chords)

    mixed = temp_file("mixed.wav")

    @ffmpeg.mix(inputs: [drums, bass, chords], output: mixed, volumes: [1.0, 0.8, 0.5])

    mixed

  end

  def master_track(input, filename)

    final = File.join(@output_dir, filename)

    master_out = temp_file("master.wav")

    @ffmpeg.eq(input: input, output: master_out, bands: [

      { freq: 60, gain: 2, q: 0.7 },

      { freq: 3000, gain: -1, q: 1.5 }

    ])

    @ffmpeg.normalize(input: master_out, output: final, target: AudioConstants::MASTER_TARGET)

    puts "âœ“ Generated: #{final}"

    final

  end

  def generate_dilla(style: "donuts", key: "C", bpm: 95)

    puts "ðŸŽ¹ Generating Dilla: #{style} | #{key} | #{bpm}BPM"

    duration = 8.0

    base_freq = note_freq(key, 3)

    raw = temp_file("raw.wav")

    @ffmpeg.tone(freq: base_freq, duration: duration, wave: :triangle, output: raw, amp: 0.5)

    processed = apply_dilla_chain(raw)

    final = File.join(@output_dir, "dilla_#{style}_#{key}_#{bpm}_#{timestamp}.wav")

    @ffmpeg.compress(input: processed, output: final, threshold: AudioConstants::COMPRESS_THRESHOLD, ratio: AudioConstants::COMPRESS_RATIO)

    puts "âœ“ Generated: #{final}"

    final

  end

  def apply_dilla_chain(input)

    crushed = temp_file("crushed.wav")

    @ffmpeg.bitcrush(input: input, output: crushed, bits: 14)

    warm = temp_file("warm.wav")

    @ffmpeg.saturate(input: crushed, output: warm, drive: 1.8)

    eq_out = temp_file("eq.wav")

    @ffmpeg.eq(input: warm, output: eq_out, bands: [

      { freq: 100, gain: 3, q: 0.8 },

      { freq: 8000, gain: -2.5, q: 1.2 }

    ])

    eq_out

  end

  def master(input:, era: :rhythm_and_sound)

    puts "ðŸŽ¨ Mastering: #{era}"

    v = VINTAGE[era] || VINTAGE[:rhythm_and_sound]

    puts "   #{v[:desc]}"

    processed = apply_vintage_processing(input, v)

    final = File.join(@output_dir, "master_#{era}_#{timestamp}.wav")

    @ffmpeg.normalize(input: processed, output: final)

    puts "âœ“ Mastered: #{final}"

    final

  end

  def apply_vintage_processing(input, vintage)

    processed = temp_file("master.wav")

    if vintage[:bits]

      @ffmpeg.bitcrush(input: input, output: processed, bits: vintage[:bits])

      @ffmpeg.saturate(input: processed, output: processed, drive: 1.5)

    else

      @ffmpeg.reverb(input: input, output: processed, decay: vintage[:reverb]/10.0, size: :medium)

      @ffmpeg.echo(input: processed, output: processed, delay_ms: 280, feedback: vintage[:echo])

    end

    processed

  end

  def export_config

    {

      version: VERSION,

      platform: Platform.detect,

      patterns: DUB_PATTERNS.transform_values { |p| { name: p[:name], desc: p[:desc] } },

      progressions: DUB_PROGRESSIONS.keys,

      delays: DUB_DELAYS,

      vintage: VINTAGE.transform_values { |v| v[:desc] }

    }.to_json

  end

  def note_freq(note, octave = 4)

    unless note.to_s.match?(/^[A-G]#?$/i)

      raise ArgumentError, "Invalid note: #{note}. Use A-G with optional #"

    end

    unless (0..8).cover?(octave)

      raise ArgumentError, "Invalid octave: #{octave}. Use 0-8"

    end

    semitones = { "C"=>0,"C#"=>1,"D"=>2,"D#"=>3,"E"=>4,"F"=>5,"F#"=>6,"G"=>7,"G#"=>8,"A"=>9,"A#"=>10,"B"=>11 }

    440.0 * (2.0 ** ((semitones[note].to_i - 9 + (octave - 4) * 12) / 12.0))

  end

  def temp_file(name)

    File.join(@temp_dir, name)

  end

  def timestamp; Time.now.strftime("%Y%m%d_%H%M%S") end

  def cleanup; FileUtils.rm_rf(@temp_dir) end

  # GEAR EMULATION - Vintage Sampler Character
  GEAR_PROFILES = {

    sp1200: {

      name: "E-mu SP-1200",

      bits: 12, sample_rate: 26040, filter_hz: 12000,

      saturation: 1.8, character: "punchy_gritty"

    },

    mpc3000: {

      name: "Akai MPC3000",

      bits: 16, sample_rate: 44100, filter_hz: 18000,

      saturation: 1.2, character: "warm_precise"

    },

    mpc60: {

      name: "Akai MPC60",

      bits: 12, sample_rate: 40000, filter_hz: 14000,

      saturation: 1.5, character: "fat_punchy"

    },

    sp303: {

      name: "Boss SP-303",

      bits: 16, sample_rate: 22050, filter_hz: 10000,

      saturation: 1.3, vinyl_sim: true, character: "lofi_cassette_warm"

    },

    sp404: {

      name: "Roland SP-404",

      bits: 16, sample_rate: 44100, filter_hz: 16000,

      saturation: 1.1, character: "harsh_brittle"

    },

    s950: {

      name: "Akai S950",

      bits: 12, sample_rate: 48000, filter_hz: 14000,

      saturation: 1.4, analog_filter: true, character: "warm_classic"

    },

    s900: {

      name: "Akai S900",

      bits: 12, sample_rate: 40000, filter_hz: 12000,

      saturation: 1.6, character: "gritty_raw"

    },

    emax: {

      name: "E-mu Emax",

      bits: 12, sample_rate: 28000, filter_hz: 10000,

      saturation: 1.7, ssm_filter: true, character: "gritty_sp1200_cousin"

    },

    mirage: {

      name: "Ensoniq Mirage",

      bits: 8, sample_rate: 30000, filter_hz: 8000,

      saturation: 2.0, analog_vcf: true, character: "extremely_lofi_harsh"

    }

  }

  # RANDOM EFFECT CHAIN GENERATOR
  module ChainGenerator

    EFFECTS = {

      bitcrush:     { bits: [8, 10, 12, 14], weight: 0.8 },

      resample:     { rates: [8000, 11025, 22050, 26040, 32000], weight: 0.6 },

      lowpass:      { cutoff: [2000, 4000, 8000, 12000, 16000], weight: 0.9 },

      highpass:     { cutoff: [20, 40, 80, 150, 300], weight: 0.5 },

      saturation:   { drive: [1.2, 1.5, 1.8, 2.2, 2.8], weight: 0.85 },

      tape_sat:     { drive: [1.1, 1.3, 1.5, 1.8], weight: 0.7 },

      transformer:  { amount: [0.1, 0.2, 0.3, 0.4], weight: 0.5 },

      tube_sat:     { drive: [1.1, 1.3, 1.6, 2.0], weight: 0.6 },

      vinyl_noise:  { amount: [0.05, 0.1, 0.15, 0.25], weight: 0.7 },

      tape_hiss:    { amount: [0.03, 0.08, 0.12, 0.18], weight: 0.5 },

      wow_flutter:  { rate: [0.2, 0.4, 0.7, 1.0], depth: [0.01, 0.02, 0.03], weight: 0.4 },

      compression:  { ratio: [2, 3, 4, 6, 8], threshold: [-24, -18, -12], weight: 0.75 },

      reverb:       { size: [0.1, 0.2, 0.3, 0.4], decay: [0.3, 0.5, 0.8], weight: 0.3 },

      delay:        { time_ms: [80, 125, 180, 250], feedback: [0.2, 0.35, 0.5], weight: 0.3 },

      chorus:       { rate: [0.5, 1.2, 2.5], depth: [0.2, 0.35, 0.5], weight: 0.2 },

      phaser:       { rate: [0.3, 0.7, 1.5], weight: 0.15 },

      tremolo:      { rate: [2, 4, 6, 8], depth: [0.3, 0.5, 0.7], weight: 0.2 },

      ring_mod:     { freq: [200, 500, 1000, 2000], weight: 0.08 }

    }

    AESTHETICS = {

      dark:      { lowpass: 0.95, saturation: 0.8, reverb: 0.4, bitcrush: 0.3 },

      deep:      { lowpass: 0.95, compression: 0.9, saturation: 0.7, highpass: 0.2 },

      authentic: { bitcrush: 0.9, vinyl_noise: 0.8, tape_sat: 0.7, lowpass: 0.6 },

      tape:      { tape_sat: 0.95, wow_flutter: 0.85, tape_hiss: 0.7, saturation: 0.5 },

      vinyl:     { vinyl_noise: 0.95, lowpass: 0.7, saturation: 0.5, wow_flutter: 0.4 },

      gritty:    { bitcrush: 0.9, saturation: 0.95, resample: 0.7, lowpass: 0.5 },

      cosmic:    { reverb: 0.8, delay: 0.7, chorus: 0.5, phaser: 0.4, lowpass: 0.6 },

      industrial:{ ring_mod: 0.4, saturation: 0.9, bitcrush: 0.7, compression: 0.8 }

    }

    def self.generate(aesthetic: :authentic, length: nil, seed: nil)

      srand(seed) if seed

      prng = Random.new(seed || Random.new_seed)

      weights = AESTHETICS[aesthetic] || AESTHETICS[:authentic]

      chain_length = length || prng.rand(3..7)

      chain = []

      used = Set.new

      chain_length.times do

        candidates = EFFECTS.keys.reject { |e| used.include?(e) }

        break if candidates.empty?

        # Weight selection by aesthetic

        weighted = candidates.map do |effect|

          base_weight = EFFECTS[effect][:weight]

          aesthetic_boost = weights[effect] || 0

          [effect, base_weight + aesthetic_boost]

        end

        total = weighted.sum { |_, w| w }

        roll = prng.rand * total

        selected = nil

        cumulative = 0

        weighted.each do |effect, weight|

          cumulative += weight

          if roll <= cumulative

            selected = effect

            break

          end

        end

        selected ||= candidates.sample(random: prng)

        effect_params = EFFECTS[selected].dup

        effect_params.delete(:weight)

        # Randomize parameters

        params = { type: selected }

        effect_params.each do |param, values|

          params[param] = values.is_a?(Array) ? values.sample(random: prng) : values

        end

        chain << params

        used << selected

      end

      chain

    end

    def self.to_s(chain)

      chain.map { |e| "#{e[:type]}(#{e.except(:type).map { |k,v| "#{k}:#{v}" }.join(',')})" }.join(" â†’ ")

    end

  end

  # DFAM-STYLE ANALOG PERCUSSION SYNTHESIS
  module DFAM

    PRESETS = {

      tribal_kick: {

        osc1: { wave: :sine, freq: 55, decay: 0.3 },

        osc2: { wave: :sine, freq: 110, decay: 0.15 },

        noise: 0.05, filter_env: 0.8, filter_decay: 0.2

      },

      industrial_hit: {

        osc1: { wave: :square, freq: 80, decay: 0.1 },

        osc2: { wave: :saw, freq: 160, decay: 0.08 },

        noise: 0.3, filter_env: 0.9, filter_decay: 0.15, fm: 0.4

      },

      metallic_tom: {

        osc1: { wave: :triangle, freq: 200, decay: 0.25 },

        osc2: { wave: :sine, freq: 350, decay: 0.2 },

        noise: 0.1, filter_env: 0.5, filter_decay: 0.3

      },

      noise_snare: {

        osc1: { wave: :triangle, freq: 180, decay: 0.08 },

        osc2: { wave: :square, freq: 220, decay: 0.05 },

        noise: 0.7, filter_env: 0.6, filter_decay: 0.12

      },

      drone_bass: {

        osc1: { wave: :saw, freq: 40, decay: 2.0 },

        osc2: { wave: :square, freq: 41, decay: 2.0 },

        noise: 0.02, filter_env: 0.3, filter_decay: 1.5

      }

    }

  end

  # SONITEX STX-1260 STYLE PROCESSING
  module Sonitex

    def self.process(ffmpeg, input:, output:, preset: :vintage_vinyl)

      presets = {

        vintage_vinyl: {

          distortion: { type: :saturation, drive: 1.3 },

          vinyl: { warble: 0.02, sibilance: 0.4 },

          tone: { lowpass: 12000, highpass: 40 },

          noise: { type: :vinyl, pops: 0.1, clicks: 0.05, base: 0.08 },

          sampling: { bits: 14, rate: 32000 }

        },

        tape_machine: {

          distortion: { type: :tape, drive: 1.5 },

          vinyl: { warble: 0.03, sibilance: 0.2 },

          tone: { lowpass: 14000, highpass: 30 },

          noise: { type: :tape_hiss, amount: 0.12 },

          sampling: { bits: 16, rate: 44100 }

        },

        sp1200_crunch: {

          distortion: { type: :digital1, drive: 1.8 },

          vinyl: { warble: 0, sibilance: 0 },

          tone: { lowpass: 10000, highpass: 60 },

          noise: { type: :none },

          sampling: { bits: 12, rate: 26040 }

        },

        extreme_lofi: {

          distortion: { type: :distortion, drive: 2.5 },

          vinyl: { warble: 0.05, sibilance: 0.6 },

          tone: { lowpass: 4000, highpass: 200 },

          noise: { type: :vinyl, pops: 0.3, clicks: 0.2, base: 0.25 },

          sampling: { bits: 8, rate: 11025 }

        }

      }

      cfg = presets[preset] || presets[:vintage_vinyl]

      # Apply chain: distortion â†’ tone â†’ sampling â†’ noise

      temp1 = output.sub('.wav', '_s1.wav')

      ffmpeg.saturate(input: input, output: temp1, drive: cfg[:distortion][:drive])

      temp2 = output.sub('.wav', '_s2.wav')

      ffmpeg.lowpass(input: temp1, output: temp2, cutoff: cfg[:tone][:lowpass])

      if cfg[:sampling][:bits] < 16

        temp3 = output.sub('.wav', '_s3.wav')

        ffmpeg.bitcrush(input: temp2, output: temp3, bits: cfg[:sampling][:bits])

        ffmpeg.resample(input: temp3, output: output, rate: cfg[:sampling][:rate])

      else

        FileUtils.cp(temp2, output)

      end

      # Cleanup

      [temp1, temp2].each { |f| File.delete(f) if File.exist?(f) }

    end

  end

  # NASTYVCS-STYLE CONSOLE PROCESSING
  module NastyVCS

    def self.process(ffmpeg, input:, output:, settings: {})

      cfg = {

        input_transformer: true,

        saturation: 0.3,

        eq_air_db: 1.5,

        eq_low_db: 2.0,

        compression_ratio: 3,

        compression_attack: :medium,

        output_transformer: true

      }.merge(settings)

      temp = output.sub('.wav', '_nvcs.wav')

      # Transformer saturation

      ffmpeg.saturate(input: input, output: temp, drive: 1.0 + cfg[:saturation])

      # EQ with console character

      ffmpeg.eq(input: temp, output: output, bands: [

        { freq: 80, gain: cfg[:eq_low_db], q: 0.8 },

        { freq: 12000, gain: cfg[:eq_air_db], q: 0.7 }

      ])

      File.delete(temp) if File.exist?(temp)

    end

  end

  # APPLY GEAR EMULATION
  def apply_gear(input:, output:, gear: :sp1200)

    profile = GEAR_PROFILES[gear] || GEAR_PROFILES[:sp1200]

    puts "ðŸŽ›ï¸  Applying #{profile[:name]} character..."

    resampled = apply_gear_resample(input, profile)

    crushed = apply_gear_bitcrush(resampled, profile)

    filtered = apply_gear_filter(crushed, profile)

    @ffmpeg.saturate(input: filtered, output: output, drive: profile[:saturation])

    puts "   Character: #{profile[:character]}"

    output

  end

  def apply_gear_resample(input, profile)

    temp1 = temp_file("gear1.wav")

    @ffmpeg.resample(input: input, output: temp1, rate: profile[:sample_rate])

    temp1

  end

  def apply_gear_bitcrush(input, profile)

    temp2 = temp_file("gear2.wav")

    @ffmpeg.bitcrush(input: input, output: temp2, bits: profile[:bits])

    temp2

  end

  def apply_gear_filter(input, profile)

    temp3 = temp_file("gear3.wav")

    @ffmpeg.lowpass(input: input, output: temp3, cutoff: profile[:filter_hz])

    temp3

  end

  # GENERATE RANDOM LO-FI CHAIN
  def generate_random_chain(input:, aesthetic: :authentic, seed: nil)

    chain = ChainGenerator.generate(aesthetic: aesthetic, seed: seed)

    puts "ðŸŽ² Random chain (#{aesthetic}): #{ChainGenerator.to_s(chain)}"

    current = input

    chain.each_with_index do |effect, i|

      next_file = temp_file("chain_#{i}.wav")

      current = apply_effect(current, next_file, effect)

    end

    final = File.join(@output_dir, "random_#{aesthetic}_#{SecureRandom.hex(4)}_#{timestamp}.wav")

    @ffmpeg.normalize(input: current, output: final)

    puts "âœ“ Generated: #{final}"

    { file: final, chain: chain }

  end

  def apply_effect(input, output, effect)

    case effect[:type]

    when :bitcrush

      @ffmpeg.bitcrush(input: input, output: output, bits: effect[:bits])

    when :resample

      @ffmpeg.resample(input: input, output: output, rate: effect[:rates])

    when :lowpass

      @ffmpeg.lowpass(input: input, output: output, cutoff: effect[:cutoff])

    when :highpass

      @ffmpeg.highpass(input: input, output: output, cutoff: effect[:cutoff])

    when :saturation, :tape_sat, :tube_sat, :transformer

      drive = effect[:drive] || (1.0 + (effect[:amount] || 0.3))

      @ffmpeg.saturate(input: input, output: output, drive: drive)

    when :compression

      @ffmpeg.compress(input: input, output: output, threshold: effect[:threshold], ratio: effect[:ratio])

    when :reverb

      @ffmpeg.reverb(input: input, output: output, decay: effect[:decay], size: :medium)

    when :delay

      @ffmpeg.echo(input: input, output: output, delay_ms: effect[:time_ms], feedback: effect[:feedback])

    when :tremolo

      @ffmpeg.tremolo(input: input, output: output, rate: effect[:rate], depth: effect[:depth])

    else

      FileUtils.cp(input, output)

    end

    output

  end

  # Audio Constants
  module AudioConstants

    KICK_FREQ = 55          # Hz, sub-bass kick

    KICK_DURATION = 0.3     # seconds

    KICK_CUTOFF = 120       # Hz, removes mud

    BASS_CUTOFF = 200       # Hz, low-pass for bass

    HAT_DURATION = 0.05     # seconds, tight hihat

    HAT_CUTOFF = 8000       # Hz, high-pass for brightness

    COMPRESS_THRESHOLD = -20 # dB

    COMPRESS_RATIO = 4       # 4:1 compression

    MASTER_TARGET = -1       # dB, mastering ceiling

  end

  # CLI Command Handlers
  def self.command_dub(args, dilla)

    dilla.generate_dub(

      pattern: (args[0] || "one_drop").to_sym,

      progression: args[1] || "dub_meditative",

      key: args[2] || "E",

      bpm: (args[3] || "120").to_i

    )

  end

  def self.command_dilla(args, dilla)
    dilla.generate_dilla(

      style: args[0] || "donuts",

      key: args[1] || "C",

      bpm: (args[2] || "95").to_i

    )

  end

  def self.command_random(args, dilla)
    aesthetic = (args[0] || "authentic").to_sym

    seed = args[1] ? args[1].to_i : nil

    test = dilla.send(:temp_file, "test_tone.wav")

    dilla.instance_variable_get(:@ffmpeg).tone(output: test, freq: 440, duration: 4)

    dilla.generate_random_chain(input: test, aesthetic: aesthetic, seed: seed)

  end

  def self.command_gear(args, dilla)
    gear = (args[0] || "sp1200").to_sym

    input = args[1]

    if input && File.exist?(input)

      output = File.join(dilla.instance_variable_get(:@output_dir), "#{gear}_#{dilla.send(:timestamp)}.wav")

      dilla.apply_gear(input: input, output: output, gear: gear)

    else

      puts "Usage: dilla.rb gear <sp1200|mpc3000|sp303|s950|...> <input.wav>"

    end

  end

  def self.command_master(args, dilla)
    return unless args[0] && File.exist?(args[0])

    dilla.master(input: args[0], era: (args[1] || "rhythm_and_sound").to_sym)

  end

  def self.command_chords(args)
    artist = args[0] || "dilla"

    album = args[1] || "fantastic_vol2"

    chords = get_chords(artist, album)

    if chords

      puts JSON.pretty_generate(chords)

    else

      puts "Available: dilla_fantastic_vol1, dilla_fantastic_vol2, dilla_donuts, flying_lotus_la, madlib"

    end

  end

  def self.command_list
    puts "
PATTERNS: #{DUB_PATTERNS.keys.join(', ')}"

    puts "PROGRESSIONS: #{DUB_PROGRESSIONS.keys.join(', ')}"

    puts "ERAS: #{VINTAGE.keys.join(', ')}"

    puts "GEAR: #{GEAR_PROFILES.keys.join(', ')}"

    puts "AESTHETICS: #{ChainGenerator::AESTHETICS.keys.join(', ')}"

  end

  # CLI
  def self.main(args)

    return show_help if args.empty? || args.include?("--help")

    dilla = new

    begin

      case args[0]

      when "dub"    then command_dub(args[1..-1], dilla)

      when "dilla"  then command_dilla(args[1..-1], dilla)

      when "random" then command_random(args[1..-1], dilla)

      when "gear"   then command_gear(args[1..-1], dilla)

      when "master" then command_master(args[1..-1], dilla)

      when "chords" then command_chords(args[1..-1])

      when "list"   then command_list

      when "config" then puts dilla.export_config

      else show_help

      end

    ensure

      dilla.cleanup

    end

  end

  def self.show_help

    puts <<~HELP

      SOS Dilla v#{VERSION} | #{Platform.detect}

      USAGE:

        dilla.rb dub [pattern] [prog] [key] [bpm]    Generate dub techno

        dilla.rb dilla [style] [key] [bpm]           Generate Dilla-style beat

        dilla.rb random [aesthetic] [seed]           Random lo-fi effect chain

        dilla.rb gear <type> <input.wav>             Apply vintage sampler character

        dilla.rb master <file.wav> [era]             Master with vintage color

        dilla.rb chords [artist] [album]             Show chord progressions

        dilla.rb list                                List all options

        dilla.rb config                              Export JSON config

      PATTERNS: one_drop, steppers, rockers, atmospheric

      GEAR: #{GEAR_PROFILES.keys.join(', ')}

      AESTHETICS: dark, deep, authentic, tape, vinyl, gritty, cosmic, industrial

      ERAS: king_tubby, basic_channel, rhythm_and_sound, wackie, mpc3000, sp1200

      INSTALL: #{Platform.install_hint}

    HELP

  end

end

SOSDilla.main(ARGV) if __FILE__ == $PROGRAM_NAME
