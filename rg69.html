<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="color-scheme" content="dark"/>
  <title>Warp Tunnel</title>
  <meta name="theme-color" content="#000000"/>
  <style>
    :root{
      --safe-top:env(safe-area-inset-top,0px);
      --safe-right:env(safe-area-inset-right,0px);
      --safe-bottom:env(safe-area-inset-bottom,0px);
      --safe-left:env(safe-area-inset-left,0px);
    }
    
    html,body{
      margin:0;
      height:100%;
      background:#000;
      color:#dcdcdc;
      font:16px/1.5 Helvetica,Arial,sans-serif;
      overflow:hidden;
      touch-action:none;
    }
    
    canvas{
      position:fixed;
      inset:0;
      width:100dvw;
      height:100dvh;
      display:block;
      background:#000;
      touch-action:none;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
    }
    
    #status{
      position:fixed;
      top:calc(10px + var(--safe-top));
      left:calc(10px + var(--safe-left));
      z-index:95;
      pointer-events:none;
      user-select:none;
      font-weight:700;
      font-size:clamp(16px,4vw,28px);
      color:#dcdcdc;
      letter-spacing:.02em;
      text-transform:uppercase;
    }
    
    #ui{
      position:fixed;
      right:calc(12px + var(--safe-right));
      bottom:calc(10px + var(--safe-bottom));
      color:#dcdcdc;
      font:9px/1.1 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      text-transform:uppercase;
      letter-spacing:.28em;
      white-space:nowrap;
      pointer-events:none;
      user-select:none;
      text-align:right;
      opacity:.86;
    }
    
    #ui .dots{
      display:inline-block;
      width:3ch;
      text-align:left;
    }
    
    #overlay{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      background:rgba(0,0,0,.9);
      color:#9aa;
      cursor:pointer;
      user-select:none;
      z-index:1000;
      text-align:center;
      padding:16px;
      opacity:1;
      transition:opacity .2s ease;
    }
    
    #overlay.ack{opacity:0;pointer-events:none;}
    #overlay[hidden]{display:none;}
    
    #overlay h2{
      margin:0;
      font-size:32px;
      font-weight:300;
      color:#dcdcdc;
      font-family:Helvetica,Arial,sans-serif;
    }
  </style>
</head>
<body>
  <div id="status">WARP</div>
  <div id="ui"><span id="ui-label">Tunnel</span><span class="dots" id="ui-dots"></span></div>
  <div id="overlay" role="dialog" aria-modal="true"><h2>Tap to start</h2></div>
  <canvas id="canvas"></canvas>

  <script>
    "use strict";
    
    // Canvas setup
    const canvas=document.getElementById('canvas');
    const ctx=canvas.getContext('2d',{alpha:false,willReadFrequently:true});
    const statusEl=document.getElementById('status');
    const uiLabel=document.getElementById('ui-label');
    const uiDots=document.getElementById('ui-dots');
    const overlay=document.getElementById('overlay');
    
    let W,H,S;
    const resize=()=>{
      W=window.innerWidth;
      H=window.innerHeight;
      S=Math.min(W,H)/100;
      canvas.width=W;
      canvas.height=H;
      ctx.imageSmoothingEnabled=false;
    };
    window.addEventListener('resize',resize);
    resize();
    
    // Audio system - FIXED: proper context handling
    let audioCtx,analyser,dataArray;
    let audioLevel=0;
    let audioStarted=false;
    
    const initAudio=async()=>{
      if(audioStarted)return;
      audioStarted=true;
      
      try{
        audioCtx=new(window.AudioContext||window.webkitAudioContext)();
        
        // Resume if suspended (iOS requirement)
        if(audioCtx.state==='suspended'){
          await audioCtx.resume();
        }
        
        const stream=await navigator.mediaDevices.getUserMedia({
          audio:{
            echoCancellation:false,
            noiseSuppression:false,
            autoGainControl:false,
            sampleRate:44100
          }
        });
        
        const source=audioCtx.createMediaStreamSource(stream);
        analyser=audioCtx.createAnalyser();
        analyser.fftSize=64; // Smaller = faster
        analyser.smoothingTimeConstant=0.3;
        source.connect(analyser);
        dataArray=new Uint8Array(analyser.frequencyBinCount);
        
        statusEl.textContent='ACTIVE';
      }catch(e){
        console.log('Audio init:',e);
        statusEl.textContent='SILENT';
      }
    };
    
    // Motion sensors
    let tiltX=0,tiltY=0;
    const initMotion=()=>{
      if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
        DeviceOrientationEvent.requestPermission().then(r=>{
          if(r==='granted'){
            window.addEventListener('deviceorientation',e=>{
              tiltX=(e.gamma||0)/45;
              tiltY=(e.beta||0)/45;
            },true);
          }
        });
      }else{
        window.addEventListener('deviceorientation',e=>{
          tiltX=(e.gamma||0)/45;
          tiltY=(e.beta||0)/45;
        },true);
      }
    };
    
    // Touch/Mouse
    let mouseX=0,mouseY=0,mouseDown=false;
    
    const handleMove=e=>{
      const p=e.touches?e.touches[0]:e;
      mouseX=((p.clientX/W)*2-1);
      mouseY=((p.clientY/H)*2-1);
    };
    
    window.addEventListener('mousemove',handleMove);
    window.addEventListener('touchmove',handleMove,{passive:true});
    
    canvas.addEventListener('mousedown',()=>{mouseDown=true;});
    canvas.addEventListener('mouseup',()=>{mouseDown=false;});
    canvas.addEventListener('touchstart',()=>{mouseDown=true;},{passive:true});
    canvas.addEventListener('touchend',()=>{mouseDown=false;},{passive:true});
    
    // Color palettes
    const palettes=[
      {name:'VOID',bg:'#000',dim:'#111',mid:'#333',bright:'#666',active:'#999',pulse:'#fff'},
      {name:'PLASMA',bg:'#0a0014',dim:'#1a0033',mid:'#4a0088',bright:'#8800ff',active:'#cc00ff',pulse:'#ff00ff'},
      {name:'CYAN',bg:'#000a0a',dim:'#001a1a',mid:'#004a4a',bright:'#008888',active:'#00cccc',pulse:'#00ffff'},
      {name:'AMBER',bg:'#140a00',dim:'#331a00',mid:'#884a00',bright:'#cc8800',active:'#ffaa00',pulse:'#ffff00'},
      {name:'FOREST',bg:'#0a1400',dim:'#1a3300',mid:'#4a8800',bright:'#88cc00',active:'#aaff00',pulse:'#ccff00'},
      {name:'BLOOD',bg:'#140000',dim:'#330000',mid:'#880000',bright:'#cc0000',active:'#ff0000',pulse:'#ff6666'},
      {name:'GOLD',bg:'#141000',dim:'#332200',mid:'#886600',bright:'#ccaa00',active:'#ffcc00',pulse:'#ffff66'},
      {name:'ICE',bg:'#001014',dim:'#002233',mid:'#004466',bright:'#0088aa',active:'#00ccff',pulse:'#66ffff'},
      {name:'RUST',bg:'#140800',dim:'#331a0a',mid:'#884422',bright:'#cc6633',active:'#ff8844',pulse:'#ffaa66'},
      {name:'SMOKE',bg:'#0a0a0a',dim:'#1a1a1a',mid:'#4a4a4a',bright:'#888888',active:'#bbbbbb',pulse:'#eeeeee'}
    ];
    
    let currentPalette=0;
    
    const setPalette=idx=>{
      currentPalette=((idx%palettes.length)+palettes.length)%palettes.length;
      uiLabel.textContent=palettes[currentPalette].name;
    };
    
    // Arrow key palette switching
    window.addEventListener('keydown',e=>{
      if(e.key==='ArrowLeft')setPalette(currentPalette-1);
      if(e.key==='ArrowRight')setPalette(currentPalette+1);
    });
    
    // WARP TUNNEL SYSTEM
    const N=1200; // Particle count - reduced for performance
    const particles=[];
    const stars=[];
    
    // Initialize stars
    for(let i=0;i<100;i++){
      stars.push({
        x:(Math.random()-0.5)*W*3,
        y:(Math.random()-0.5)*H*3,
        z:Math.random()*400-200,
        speed:2+Math.random()*3
      });
    }
    
    class Particle{
      constructor(i){
        this.i=i;
        this.reset();
      }
      
      reset(){
        // Ring distribution in XY plane
        const angle=(this.i/N)*Math.PI*8; // Multiple rings
        const radius=20+Math.random()*60;
        
        this.ox=Math.cos(angle)*radius;
        this.oy=Math.sin(angle)*radius;
        this.oz=(Math.random()-0.5)*200;
        
        this.px=this.ox;
        this.py=this.oy;
        this.pz=this.oz;
        
        this.vz=-2-Math.random()*2; // Moving toward viewer
        
        this.size=1+Math.random()*2;
      }
      
      update(){
        const pal=palettes[currentPalette];
        
        // Move in Z (toward viewer)
        this.pz+=this.vz*(1+audioLevel*2);
        
        // Reset when past viewer
        if(this.pz>100){
          this.pz=-200;
          const angle=(this.i/N)*Math.PI*8;
          const radius=20+Math.random()*60;
          this.ox=Math.cos(angle)*radius;
          this.oy=Math.sin(angle)*radius;
        }
        
        // Audio reactivity - expand rings
        const expand=1+audioLevel*1.5;
        this.px=this.ox*expand;
        this.py=this.oy*expand;
        
        // Tilt parallax
        this.px+=tiltX*30*(this.pz/100);
        this.py+=tiltY*30*(this.pz/100);
        
        // Mouse influence
        this.px+=mouseX*20;
        this.py+=mouseY*20;
      }
      
      project(){
        const fl=150;
        if(this.pz<=-fl)return null;
        
        const scale=fl/(fl+this.pz);
        return{
          x:Math.floor(W/2+this.px*S*scale),
          y:Math.floor(H/2+this.py*S*scale),
          z:this.pz,
          scale:scale,
          size:Math.max(1,Math.floor(this.size*scale*S))
        };
      }
    }
    
    // Initialize particles
    for(let i=0;i<N;i++)particles.push(new Particle(i));
    
    // Dots animation
    const dotsPattern=[0,1,2,3,2,1];
    let dotsIdx=0;
    setInterval(()=>{
      uiDots.textContent='.'.repeat(dotsPattern[dotsIdx]);
      dotsIdx=(dotsIdx+1)%dotsPattern.length;
    },400);
    
    // Start
    overlay.addEventListener('click',()=>{
      overlay.classList.add('ack');
      initAudio();
      initMotion();
      setTimeout(()=>overlay.hidden=true,300);
    });
    
    // Draw functions
    const drawLine=(x1,y1,x2,y2,col,alpha)=>{
      ctx.globalAlpha=alpha;
      ctx.strokeStyle=col;
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    };
    
    const drawPlus=(x,y,size,col)=>{
      ctx.globalAlpha=1;
      ctx.fillStyle=col;
      const h=Math.floor(size/2);
      ctx.fillRect(x,y-h,1,size);
      ctx.fillRect(x-h,y,size,1);
    };
    
    // Animation
    let t=0;
    const animate=()=>{
      requestAnimationFrame(animate);
      t+=0.016;
      
      // Get audio data
      if(analyser&&audioCtx&&audioCtx.state==='running'){
        analyser.getByteFrequencyData(dataArray);
        // Focus on bass for reactivity
        let bass=0;
        for(let i=0;i<8;i++)bass+=dataArray[i];
        audioLevel=bass/8/255;
      }else{
        audioLevel*=0.95;
      }
      
      const pal=palettes[currentPalette];
      
      // Clear with fade for trails
      ctx.fillStyle=pal.bg;
      ctx.fillRect(0,0,W,H);
      
      // Draw stars (background)
      ctx.fillStyle=pal.dim;
      for(const s of stars){
        s.z+=s.speed;
        if(s.z>200)s.z=-200;
        
        const fl=300;
        const scale=fl/(fl+s.z);
        const x=Math.floor(W/2+s.x*scale);
        const y=Math.floor(H/2+s.y*scale);
        
        if(x>=0&&x<W&&y>=0&&y<H){
          ctx.globalAlpha=0.3*scale;
          ctx.fillRect(x,y,1,1);
        }
      }
      
      // Update and draw particles
      const proj=[];
      for(const p of particles){
        p.update();
        const pr=p.project();
        if(pr)proj.push(pr);
      }
      
      // Sort by Z (back to front)
      proj.sort((a,b)=>b.z-a.z);
      
      // Draw connections (wireframe effect)
      ctx.globalAlpha=0.15;
      ctx.strokeStyle=pal.mid;
      for(let i=0;i<proj.length-1;i++){
        const p1=proj[i];
        const p2=proj[i+1];
        // Connect nearby particles
        const dx=p1.x-p2.x;
        const dy=p1.y-p2.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist<50&&p1.z>0&&p2.z>0){
          ctx.beginPath();
          ctx.moveTo(p1.x,p1.y);
          ctx.lineTo(p2.x,p2.y);
          ctx.stroke();
        }
      }
      
      // Draw particles
      for(const p of proj){
        // Color based on depth
        let col;
        if(p.z>50)col=pal.dim;
        else if(p.z>0)col=pal.mid;
        else if(p.z>-50)col=pal.bright;
        else if(p.z>-100)col=pal.active;
        else col=pal.pulse;
        
        // Audio pulse makes bright
        if(audioLevel>0.5&&p.z>-50)col=pal.pulse;
        
        drawPlus(p.x,p.y,p.size,col);
      }
      
      // Center orb (the "singularity")
      const orbSize=10+audioLevel*20;
      const orbPulse=Math.sin(t*3)*2*audioLevel;
      
      ctx.globalAlpha=0.8;
      ctx.fillStyle=pal.active;
      const cx=Math.floor(W/2);
      const cy=Math.floor(H/2);
      
      // Draw orb as plus
      drawPlus(cx,cy,orbSize+orbPulse,pal.pulse);
      
      // Glow
      ctx.globalAlpha=0.2;
      ctx.fillStyle=pal.bright;
      for(let r=2;r<6;r++){
        ctx.fillRect(cx-r,cy-r,r*2,r*2);
      }
      
      ctx.globalAlpha=1;
    };
    
    // Random startup palette
    setPalette(Math.floor(Math.random()*palettes.length));
    
    animate();
  </script>
</body>
</html>
